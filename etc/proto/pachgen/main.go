package main

import (
	"fmt"
	"io/ioutil"
	"os"

	"github.com/golang/protobuf/proto"
	descriptor "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

const generatedFileWarning = "// This file is generated by pachgen (etc/proto/pachgen) - do not edit directly.\n"

// If you're ever writing code that generates code, it's a sign that you
// shouldn't be using the targeted language directly.

// Generate:
// Unsupported transaction client (overridden by user code) - existing in client/transaction.go
// Mock server - existing in internal/testpachd/mock_pachd.go
// Mock client - existing in grey/pachctl-testing branch somewhere
// Test fixtures - existing in grey/pachctl-testing branch somewhere

// ProtoCodeGenerator is an interface to be implemented by each type of output
// file we are generating.  'AddProto' is called for each input .proto file, and
// then 'Finish' is called to collect the resulting generated .go file.
type ProtoCodeGenerator interface {
	AddProto(*descriptor.FileDescriptorProto) error
	Finish() (*plugin.CodeGeneratorResponse_File, error)
}

// CodeGenerators is the set of all code generators that will be run for any
// input files.  It is populated by 'init' in each code generator's
// implementation.
var CodeGenerators = []ProtoCodeGenerator{}

// errResponse is a helper function to easily construct an error response to send to protoc.
func errResponse(err error) *plugin.CodeGeneratorResponse {
	errString := err.Error()
	return &plugin.CodeGeneratorResponse{Error: &errString}
}

// runInternal will send each proto file to each code generator, then collect
// their output files into a single response.
func runInternal(req *plugin.CodeGeneratorRequest) *plugin.CodeGeneratorResponse {
	for _, proto := range req.ProtoFile {
		for _, gen := range CodeGenerators {
			if err := gen.AddProto(proto); err != nil {
				return errResponse(err)
			}
		}
	}

	resp := &plugin.CodeGeneratorResponse{}
	for _, gen := range CodeGenerators {
		if respFile, err := gen.Finish(); err != nil {
			fmt.Fprintf(os.Stderr, "error from codegen: %v\n", err)
			// return errResponse(err)
		} else {
			// Add the generated file warning here rather than count on the generators to do it
			newContent := generatedFileWarning + *respFile.Content
			respFile.Content = &newContent
			resp.File = append(resp.File, respFile)
		}
	}

	return resp
}

// run handles the input/output of communicating with 'protoc', reading a
// request from stdin and writing a response to stdout.
func run() error {
	req := &plugin.CodeGeneratorRequest{}
	if data, err := ioutil.ReadAll(os.Stdin); err != nil {
		return err
	} else if err := proto.Unmarshal(data, req); err != nil {
		return err
	}

	resp := runInternal(req)

	if marshalled, err := proto.Marshal(resp); err != nil {
		return err
	} else if _, err := os.Stdout.Write(marshalled); err != nil {
		return err
	} else if resp.Error != nil {
		return fmt.Errorf("%s", *resp.Error)
	}

	return nil
}

// main wraps 'run', which returns an error if we should have a non-zero exit code
func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Fatal error: %v\n", err)
		os.Exit(1)
	}
}
