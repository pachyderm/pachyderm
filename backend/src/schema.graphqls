## TODO: What is the "ID" field for inputs?
type PFSInput {
  name: String!
  repo: Repo!
}

type CronInput {
  name: String!
  repo: Repo!
}

type GitInput {
  name: String!
  url: String!
}

enum InputType {
  PFS
  CRON
  GIT
}

input TimestampInput {
  seconds: Int!
  nanos: Int!
}

type Input {
  id: ID! # This will need to be assigned on the API side
  type: InputType!
  joinedWith: [String!]! # A flat representation of the input tree (list of PipelineInput ids)
  groupedWith: [String!]!
  crossedWith: [String!]!
  unionedWith: [String!]!
  pfsInput: PFSInput
  cronInput: CronInput
  gitInput: GitInput
}

# This enum is replaced with the one from pps on type generation
enum PipelineState {
  PIPELINE_STATE_UNKNOWN
  PIPELINE_STARTING
  PIPELINE_RUNNING
  PIPELINE_RESTARTING
  PIPELINE_FAILURE
  PIPELINE_PAUSED
  PIPELINE_STANDBY
  PIPELINE_CRASHING
}

# This enum is replaced with the one from pps on type generation
enum JobState {
  JOB_STATE_UNKNOWN
  JOB_CREATED
  JOB_STARTING
  JOB_RUNNING
  JOB_FAILURE
  JOB_SUCCESS
  JOB_KILLED
  JOB_EGRESSING
  JOB_FINISHING
  JOB_UNRUNNABLE
}

enum NodeState {
  SUCCESS
  IDLE
  PAUSED
  BUSY
  RUNNING
  ERROR
}

enum DatumState {
  UNKNOWN
  FAILED
  SUCCESS
  SKIPPED
  STARTING
  RECOVERED
}

# UNKNOWN and STARTING statuses are not being used in core.
# There is no need to allow users to filter on these two statuses
enum DatumFilter {
  FAILED
  SUCCESS
  SKIPPED
  RECOVERED
}

enum OriginKind {
  USER
  AUTO
  FSCK
  ALIAS
  ORIGIN_KIND_UNKNOWN
}

enum FileCommitState {
  ADDED
  UPDATED
  DELETED
}

# This enum is replaced with the one from projects on type generation
enum ProjectStatus {
  HEALTHY
  UNHEALTHY
}

enum PipelineType {
  STANDARD
  SPOUT
  SERVICE
}

enum EnterpriseState {
  NONE
  ACTIVE
  EXPIRED
  HEARTBEAT_FAILED
}

type Transform {
  cmdList: [String!]!
  image: String!
  debug: Boolean!
}

input TransformInput {
  cmdList: [String!]!
  image: String!
  stdinList: [String!]
}

type NodeSelector {
  key: String!
  value: String!
}

type SchedulingSpec {
  nodeSelectorMap: [NodeSelector!]!
  priorityClassName: String!
}

type Pipeline {
  id: ID!
  name: String!
  version: Int!
  createdAt: Int!
  state: PipelineState!
  nodeState: NodeState!
  stopped: Boolean!
  recentError: String
  lastJobState: JobState
  lastJobNodeState: NodeState
  description: String
  type: PipelineType!
  datumTimeoutS: Int
  datumTries: Int!
  jobTimeoutS: Int
  outputBranch: String!
  s3OutputRepo: String
  egress: Boolean!
  jsonSpec: String!
  reason: String
}

type InputPipeline {
  id: ID!
}

type Branch {
  name: ID!
  repo: RepoInfo
}

type BranchInfo {
  branch: Branch
  head: Commit
}

type RepoInfo {
  name: String
  type: String
}
type DiffCount {
  count: Int!
  sizeDelta: Float!
}

type Diff {
  size: Float!
  sizeDisplay: String!
  filesAdded: DiffCount!
  filesUpdated: DiffCount!
  filesDeleted: DiffCount!
}

type Commit {
  repoName: String!
  branch: Branch
  description: String
  originKind: OriginKind
  hasLinkedJob: Boolean!
  id: ID!
  started: Int!
  finished: Int!
  sizeBytes: Float!
  sizeDisplay: String!
  diff: Diff
}

type AuthInfo {
  rolesList: [String]
}

type Repo {
  branches: [Branch!]!
  createdAt: Int!
  description: String!
  id: ID!
  name: ID!
  sizeBytes: Float!
  sizeDisplay: String!
  access: Boolean!
  projectId: String!

  # The Dash API will have to derive the following two fields until core pach can expose then for us
  linkedPipeline: Pipeline
  lastCommit: Commit

  authInfo: AuthInfo
}

type Pach {
  id: ID!
}

type Job {
  id: ID!
  createdAt: Int
  startedAt: Int
  finishedAt: Int
  restarts: Int!
  state: JobState!
  nodeState: NodeState!
  pipelineName: String!
  transformString: String
  transform: Transform
  inputString: String
  inputBranch: String
  outputBranch: String
  outputCommit: String
  reason: String
  downloadBytesDisplay: String!
  uploadBytesDisplay: String!
  jsonDetails: String!
  dataProcessed: Int!
  dataSkipped: Int!
  dataFailed: Int!
  dataRecovered: Int!
  dataTotal: Int!
}

enum NodeType {
  PIPELINE
  OUTPUT_REPO
  INPUT_REPO
  EGRESS
}

type Vertex {
  id: String!
  name: String!
  state: PipelineState
  nodeState: NodeState
  access: Boolean!
  parents: [String!]!
  type: NodeType!
  jobState: JobState
  jobNodeState: NodeState
  createdAt: Int
}

input DagQueryArgs {
  projectId: ID!
  jobSetId: ID
}

input JobsQueryArgs {
  projectId: ID!
  limit: Int
  pipelineId: String
  pipelineIds: [String]
  jobSetIds: [String]
  nodeStateFilter: [NodeState]
  cursor: TimestampInput
  reverse: Boolean
}

input JobsByPipelineQueryArgs {
  projectId: ID!
  limit: Int
  pipelineIds: [String]!
}

type Project {
  id: String!
  status: ProjectStatus!
  description: String
}

type ProjectWithoutStatus {
  id: String!
  status: ProjectStatus
  description: String
}

type ProjectDetails {
  repoCount: Int!
  pipelineCount: Int!
  sizeBytes: Float!
  sizeDisplay: String!
  jobSets: [JobSet!]!
}

enum FileType {
  RESERVED
  DIR
  FILE
}

type Timestamp {
  seconds: Int!
  nanos: Int!
}

type File {
  committed: Timestamp
  commitId: String!
  download: String
  hash: String!
  path: String!
  repoName: String!
  sizeBytes: Float!
  sizeDisplay: String!
  type: FileType!
  commitAction: FileCommitState
}

input FileQueryArgs {
  projectId: String!
  commitId: String
  path: String
  repoName: String!
  branchName: String!
  cursorPath: String
  limit: Int
  reverse: Boolean
}

type FileQueryResponse {
  diff: Diff
  files: [File!]!
}

input ProjectDetailsQueryArgs {
  projectId: String!
  jobSetsLimit: Int
}

type Tokens {
  pachToken: String!
  idToken: String!
}

type Account {
  id: ID!
  email: String!
  name: String
}

type SearchResults {
  pipelines: [Pipeline!]!
  repos: [Repo!]!
  jobSet: JobSet
}

type AuthConfig {
  authEndpoint: String!
  clientId: String!
  pachdClientId: String!
}

type JobSet {
  id: ID!
  createdAt: Int
  startedAt: Int
  finishedAt: Int
  inProgress: Boolean!
  state: JobState!
  jobs: [Job!]!
}

input PipelineQueryArgs {
  projectId: String!
  id: ID!
}

input PipelinesQueryArgs {
  projectIds: [String!]!
  jobSetId: ID
}

input BranchQueryArgs {
  projectId: String!
  branch: BranchInput!
}

input BranchesQueryArgs {
  projectId: String!
  repoName: String!
}

input RepoQueryArgs {
  projectId: String!
  id: ID!
}

input ReposQueryArgs {
  projectId: String!
  jobSetId: ID
}

input CommitQueryArgs {
  id: ID
  repoName: String!
  branchName: String
  projectId: String!
  withDiff: Boolean
}

input CommitSearchQueryArgs {
  id: ID!
  repoName: String!
  projectId: String!
}

input CommitsQueryArgs {
  projectId: String!
  repoName: String!
  branchName: String
  pipelineName: String
  originKind: OriginKind
  number: Int
  cursor: TimestampInput
  commitIdCursor: String
  reverse: Boolean
}

input SearchResultQueryArgs {
  projectId: String!
  query: String!
  limit: Int
  globalIdFilter: ID
}

input JobSetQueryArgs {
  id: ID!
  projectId: String!
}

input JobSetsQueryArgs {
  projectId: String!
  cursor: TimestampInput
  limit: Int
  reverse: Boolean
}

input JobQueryArgs {
  id: ID
  projectId: String!
  pipelineName: String!
}

input WorkspaceLogsArgs {
  start: Int
  projectId: String!
}

input LogsArgs {
  projectId: String!
  pipelineName: String!
  master: Boolean
  jobId: String
  datumId: String
  start: Int
  reverse: Boolean
}

input CreateRepoArgs {
  name: String!
  description: String
  update: Boolean
  projectId: String!
}

input CreateProjectArgs {
  name: String!
  description: String
}

input UpdateProjectArgs {
  name: String!
  description: String!
}

input DeleteProjectAndResourcesArgs {
  name: String!
}

input DeleteRepoArgs {
  repo: RepoInput!
  force: Boolean
  projectId: String!
}

input RepoInput {
  name: ID!
  type: String
}

input PFS {
  name: String!
  repo: RepoInput!
  glob: String
  branch: String
}

input CreatePipelineArgs {
  name: String!
  transform: TransformInput!
  pfs: PFS
  crossList: [PFS!]
  projectId: String!
  description: String
  update: Boolean
}

input DeletePipelineArgs {
  name: String!
  projectId: String!
}

input CommitInput {
  id: ID!
  branch: BranchInput
}

input BranchInput {
  name: ID!
  repo: RepoInput!
}

input CreateBranchArgs {
  head: CommitInput
  branch: BranchInput
  provenance: [BranchInput!]
  newCommitSet: Boolean
  projectId: String!
}

input FileFromURL {
  url: String!
  path: String!
}

input PutFilesFromURLsArgs {
  files: [FileFromURL!]!
  branch: String!
  repo: String!
  projectId: String!
}

input DeleteFilesArgs {
  filePaths: [String!]!
  repo: String!
  branch: String!
  force: Boolean
  projectId: String!
}

type Log {
  message: String!
  timestamp: Timestamp
  user: Boolean!
}

type Datum {
  id: ID!
  jobId: ID
  requestedJobId: ID! # Needed for caching
  state: DatumState!
  downloadTimestamp: Timestamp
  uploadTimestamp: Timestamp
  processTimestamp: Timestamp
  downloadBytes: Float
  uploadBytes: Float
}

input DatumsQueryArgs {
  projectId: String!
  jobId: ID!
  pipelineId: ID!
  limit: Int
  filter: [DatumFilter!]
  cursor: String
}

input DatumQueryArgs {
  projectId: String!
  id: ID!
  jobId: ID!
  pipelineId: ID!
}

type EnterpriseInfo {
  state: EnterpriseState!
  expiration: Int!
}

type AdminInfo {
  clusterId: String
}

type Version {
  major: Int
  minor: Int
  micro: Int
  additional: String
  gitCommit: String
  gitTreeModified: String
  buildDate: String
  goVersion: String
  platform: String
}

type VersionInfo {
  pachdVersion: Version
  consoleVersion: String
}

type PageableDatum {
  items: [Datum!]!
  cursor: String
  hasNextPage: Boolean
}

# Paging on the cursor will return commits from all branches, you can not filter out commits from a single branch this way.
# If you want get a paged list of commits for a single branch you can page off of the parentCommit instead of the cursor.
type PageableCommit {
  items: [Commit!]!
  cursor: Timestamp
  parentCommit: String
}

type PageableJob {
  items: [Job!]!
  cursor: Timestamp
  hasNextPage: Boolean
}

type PageableJobSet {
  items: [JobSet!]!
  cursor: Timestamp
  hasNextPage: Boolean
}

type PageableFile {
  cursor: String
  hasNextPage: Boolean
  files: [File!]!
}

input FindCommitsQueryArgs {
  projectId: String!
  repoId: String!
  filePath: String!
  commitId: String
  branchId: String
  limit: Int
}

type FoundCommit {
  id: ID!
  started: Int!
  description: String
  commitAction: FileCommitState
}

type PageableFoundCommits {
  commits: [FoundCommit!]!
  cursor: String
  hasNextPage: Boolean
}

## RBAC

enum Permission {
  PERMISSION_UNKNOWN
  CLUSTER_MODIFY_BINDINGS
  CLUSTER_GET_BINDINGS
  CLUSTER_GET_PACHD_LOGS
  CLUSTER_AUTH_ACTIVATE
  CLUSTER_AUTH_DEACTIVATE
  CLUSTER_AUTH_GET_CONFIG
  CLUSTER_AUTH_SET_CONFIG
  CLUSTER_AUTH_GET_ROBOT_TOKEN
  CLUSTER_AUTH_MODIFY_GROUP_MEMBERS
  CLUSTER_AUTH_GET_GROUPS
  CLUSTER_AUTH_GET_GROUP_USERS
  CLUSTER_AUTH_EXTRACT_TOKENS
  CLUSTER_AUTH_RESTORE_TOKEN
  CLUSTER_AUTH_GET_PERMISSIONS_FOR_PRINCIPAL
  CLUSTER_AUTH_DELETE_EXPIRED_TOKENS
  CLUSTER_AUTH_REVOKE_USER_TOKENS
  CLUSTER_AUTH_ROTATE_ROOT_TOKEN
  CLUSTER_ENTERPRISE_ACTIVATE
  CLUSTER_ENTERPRISE_HEARTBEAT
  CLUSTER_ENTERPRISE_GET_CODE
  CLUSTER_ENTERPRISE_DEACTIVATE
  CLUSTER_ENTERPRISE_PAUSE
  CLUSTER_IDENTITY_SET_CONFIG
  CLUSTER_IDENTITY_GET_CONFIG
  CLUSTER_IDENTITY_CREATE_IDP
  CLUSTER_IDENTITY_UPDATE_IDP
  CLUSTER_IDENTITY_LIST_IDPS
  CLUSTER_IDENTITY_GET_IDP
  CLUSTER_IDENTITY_DELETE_IDP
  CLUSTER_IDENTITY_CREATE_OIDC_CLIENT
  CLUSTER_IDENTITY_UPDATE_OIDC_CLIENT
  CLUSTER_IDENTITY_LIST_OIDC_CLIENTS
  CLUSTER_IDENTITY_GET_OIDC_CLIENT
  CLUSTER_IDENTITY_DELETE_OIDC_CLIENT
  CLUSTER_DEBUG_DUMP
  CLUSTER_LICENSE_ACTIVATE
  CLUSTER_LICENSE_GET_CODE
  CLUSTER_LICENSE_ADD_CLUSTER
  CLUSTER_LICENSE_UPDATE_CLUSTER
  CLUSTER_LICENSE_DELETE_CLUSTER
  CLUSTER_LICENSE_LIST_CLUSTERS
  CLUSTER_CREATE_SECRET
  CLUSTER_LIST_SECRETS
  SECRET_DELETE
  SECRET_INSPECT
  CLUSTER_DELETE_ALL
  REPO_READ
  REPO_WRITE
  REPO_MODIFY_BINDINGS
  REPO_DELETE
  REPO_INSPECT_COMMIT
  REPO_LIST_COMMIT
  REPO_DELETE_COMMIT
  REPO_CREATE_BRANCH
  REPO_LIST_BRANCH
  REPO_DELETE_BRANCH
  REPO_INSPECT_FILE
  REPO_LIST_FILE
  REPO_ADD_PIPELINE_READER
  REPO_REMOVE_PIPELINE_READER
  REPO_ADD_PIPELINE_WRITER
  PIPELINE_LIST_JOB
  PROJECT_CREATE
  PROJECT_DELETE
  PROJECT_LIST_REPO
  PROJECT_CREATE_REPO
  PROJECT_MODIFY_BINDINGS
}

enum ResourceType {
  RESOURCE_TYPE_UNKNOWN
  CLUSTER
  REPO
  SPEC_REPO
  PROJECT
}

input Resource {
  name: String! # project/name
  type: ResourceType!
}

input GetPermissionsArgs {
  resource: Resource!
}

type GetPermissionsResp {
  permissionsList: [Int]! # TODO use Permission
  rolesList: [String!]!
}

input GetRolesArgs {
  resource: Resource!
}

type RolesList {
  principal: String!
  roles: [String]!
}

type GetRolesResp {
  roleBindings: [RolesList]
}

input ModifyRolesArgs {
  resource: Resource!
  principal: String!
  rolesList: [String!]!
}

input GetAuthorizeArgs {
  resource: Resource!
  permissionsList: [Permission!]!
}

type GetAuthorizeResp {
  satisfiedList: [Permission!]!
  missingList: [Permission!]!
  authorized: Boolean
  principal: String!
}

## ----

input FileDownloadArgs {
  projectId: String!
  repoId: String!
  commitId: String! # BranchId and CommitID are interchangeable, either can be passed in here
  paths: [String!]!
}

type Query {
  project(id: ID!): Project!
  projects: [Project!]!
  pipeline(args: PipelineQueryArgs!): Pipeline!
  repo(args: RepoQueryArgs!): Repo!
  pipelines(args: PipelinesQueryArgs!): [Pipeline]!
  repos(args: ReposQueryArgs!): [Repo]!
  projectDetails(args: ProjectDetailsQueryArgs!): ProjectDetails!
  jobs(args: JobsQueryArgs!): PageableJob!
  job(args: JobQueryArgs!): Job!
  jobsByPipeline(args: JobsByPipelineQueryArgs!): [Job!]!
  dag(args: DagQueryArgs!): [Vertex!]!
  files(args: FileQueryArgs!): PageableFile!
  fileDownload(args: FileDownloadArgs!): String!
  account: Account!
  searchResults(args: SearchResultQueryArgs!): SearchResults!
  authConfig: AuthConfig!
  jobSet(args: JobSetQueryArgs!): JobSet!
  jobSets(args: JobSetsQueryArgs!): PageableJobSet!
  workspaceLogs(args: WorkspaceLogsArgs!): [Log]!
  logs(args: LogsArgs!): [Log]!
  commit(args: CommitQueryArgs!): Commit
  commitSearch(args: CommitSearchQueryArgs!): Commit
  commits(args: CommitsQueryArgs!): PageableCommit!
  findCommits(args: FindCommitsQueryArgs!): PageableFoundCommits!
  branch(args: BranchQueryArgs!): Branch!
  branches(args: BranchesQueryArgs!): [Branch]!
  datum(args: DatumQueryArgs!): Datum!
  datumSearch(args: DatumQueryArgs!): Datum
  datums(args: DatumsQueryArgs!): PageableDatum!
  enterpriseInfo: EnterpriseInfo!
  adminInfo: AdminInfo!
  versionInfo: VersionInfo!

  # RBAC
  getPermissions(args: GetPermissionsArgs!): GetPermissionsResp
  getRoles(args: GetRolesArgs!): GetRolesResp
  getAuthorize(args: GetAuthorizeArgs!): GetAuthorizeResp
}

type Subscription {
  dags(args: DagQueryArgs!): [Vertex!]!
  workspaceLogs(args: WorkspaceLogsArgs!): Log!
  logs(args: LogsArgs!): Log!
}

input StartCommitArgs {
  branchName: String!
  repoName: String!
  projectId: String!
}

type OpenCommit {
  branch: Branch!
  id: ID!
}

input OpenCommitInput {
  branch: BranchInput!
  id: ID!
}

input FinishCommitArgs {
  commit: OpenCommitInput!
  projectId: String!
}

type Mutation {
  exchangeCode(code: String!): Tokens!
  createRepo(args: CreateRepoArgs!): Repo!
  deleteRepo(args: DeleteRepoArgs!): Boolean
  createPipeline(args: CreatePipelineArgs!): Pipeline!
  deletePipeline(args: DeletePipelineArgs!): Boolean
  createProject(args: CreateProjectArgs!): Project!
  updateProject(args: UpdateProjectArgs!): Project!
  deleteProjectAndResources(args: DeleteProjectAndResourcesArgs!): Boolean!
  createBranch(args: CreateBranchArgs!): Branch!
  putFilesFromURLs(args: PutFilesFromURLsArgs!): [String!]!
  deleteFiles(args: DeleteFilesArgs!): ID!
  startCommit(args: StartCommitArgs!): OpenCommit!
  finishCommit(args: FinishCommitArgs!): Boolean!

  # RBAC
  modifyRoles(args: ModifyRolesArgs!): Boolean!
}
