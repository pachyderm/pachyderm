// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pjs/pjs.proto

package pjs

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobMultiError, or nil if none found.
func (m *Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return JobMultiError(errors)
	}

	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.ValidateAll() if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

// Validate checks the field values on JobInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobInfoMultiError, or nil if none found.
func (m *JobInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *JobInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParentJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "ParentJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "ParentJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParentJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "ParentJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Result.(type) {
	case *JobInfo_Output:
		if v == nil {
			err := JobInfoValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOutput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JobInfoValidationError{
						field:  "Output",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JobInfoValidationError{
						field:  "Output",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JobInfoValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *JobInfo_Error:
		if v == nil {
			err := JobInfoValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Error
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return JobInfoMultiError(errors)
	}

	return nil
}

// JobInfoMultiError is an error wrapping multiple validation errors returned
// by JobInfo.ValidateAll() if the designated constraints aren't met.
type JobInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobInfoMultiError) AllErrors() []error { return m }

// JobInfoValidationError is the validation error returned by JobInfo.Validate
// if the designated constraints aren't met.
type JobInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobInfoValidationError) ErrorName() string { return "JobInfoValidationError" }

// Error satisfies the builtin error interface
func (e JobInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobInfoValidationError{}

// Validate checks the field values on JobInfoDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobInfoDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobInfoDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JobInfoDetailsMultiError,
// or nil if none found.
func (m *JobInfoDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *JobInfoDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJobInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoDetailsValidationError{
					field:  "JobInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoDetailsValidationError{
					field:  "JobInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJobInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoDetailsValidationError{
				field:  "JobInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JobInfoDetailsMultiError(errors)
	}

	return nil
}

// JobInfoDetailsMultiError is an error wrapping multiple validation errors
// returned by JobInfoDetails.ValidateAll() if the designated constraints
// aren't met.
type JobInfoDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobInfoDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobInfoDetailsMultiError) AllErrors() []error { return m }

// JobInfoDetailsValidationError is the validation error returned by
// JobInfoDetails.Validate if the designated constraints aren't met.
type JobInfoDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobInfoDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobInfoDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobInfoDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobInfoDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobInfoDetailsValidationError) ErrorName() string { return "JobInfoDetailsValidationError" }

// Error satisfies the builtin error interface
func (e JobInfoDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobInfoDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobInfoDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobInfoDetailsValidationError{}

// Validate checks the field values on Queue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Queue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Queue with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in QueueMultiError, or nil if none found.
func (m *Queue) ValidateAll() error {
	return m.validate(true)
}

func (m *Queue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return QueueMultiError(errors)
	}

	return nil
}

// QueueMultiError is an error wrapping multiple validation errors returned by
// Queue.ValidateAll() if the designated constraints aren't met.
type QueueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueueMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueueMultiError) AllErrors() []error { return m }

// QueueValidationError is the validation error returned by Queue.Validate if
// the designated constraints aren't met.
type QueueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueueValidationError) ErrorName() string { return "QueueValidationError" }

// Error satisfies the builtin error interface
func (e QueueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueueValidationError{}

// Validate checks the field values on QueueInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueueInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueueInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueueInfoMultiError, or nil
// if none found.
func (m *QueueInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *QueueInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueueInfoValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueueInfoValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueueInfoValidationError{
				field:  "Queue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueueInfoValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueueInfoValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueueInfoValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return QueueInfoMultiError(errors)
	}

	return nil
}

// QueueInfoMultiError is an error wrapping multiple validation errors returned
// by QueueInfo.ValidateAll() if the designated constraints aren't met.
type QueueInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueueInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueueInfoMultiError) AllErrors() []error { return m }

// QueueInfoValidationError is the validation error returned by
// QueueInfo.Validate if the designated constraints aren't met.
type QueueInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueueInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueueInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueueInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueueInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueueInfoValidationError) ErrorName() string { return "QueueInfoValidationError" }

// Error satisfies the builtin error interface
func (e QueueInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueueInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueueInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueueInfoValidationError{}

// Validate checks the field values on QueueInfoDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *QueueInfoDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueueInfoDetails with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// QueueInfoDetailsMultiError, or nil if none found.
func (m *QueueInfoDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *QueueInfoDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueueInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, QueueInfoDetailsValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, QueueInfoDetailsValidationError{
					field:  "QueueInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueueInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return QueueInfoDetailsValidationError{
				field:  "QueueInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Size

	if len(errors) > 0 {
		return QueueInfoDetailsMultiError(errors)
	}

	return nil
}

// QueueInfoDetailsMultiError is an error wrapping multiple validation errors
// returned by QueueInfoDetails.ValidateAll() if the designated constraints
// aren't met.
type QueueInfoDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueueInfoDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueueInfoDetailsMultiError) AllErrors() []error { return m }

// QueueInfoDetailsValidationError is the validation error returned by
// QueueInfoDetails.Validate if the designated constraints aren't met.
type QueueInfoDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueueInfoDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueueInfoDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueueInfoDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueueInfoDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueueInfoDetailsValidationError) ErrorName() string { return "QueueInfoDetailsValidationError" }

// Error satisfies the builtin error interface
func (e QueueInfoDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueueInfoDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueueInfoDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueueInfoDetailsValidationError{}

// Validate checks the field values on QueueElement with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *QueueElement) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on QueueElement with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in QueueElementMultiError, or
// nil if none found.
func (m *QueueElement) ValidateAll() error {
	return m.validate(true)
}

func (m *QueueElement) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if len(errors) > 0 {
		return QueueElementMultiError(errors)
	}

	return nil
}

// QueueElementMultiError is an error wrapping multiple validation errors
// returned by QueueElement.ValidateAll() if the designated constraints aren't met.
type QueueElementMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m QueueElementMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m QueueElementMultiError) AllErrors() []error { return m }

// QueueElementValidationError is the validation error returned by
// QueueElement.Validate if the designated constraints aren't met.
type QueueElementValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e QueueElementValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e QueueElementValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e QueueElementValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e QueueElementValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e QueueElementValidationError) ErrorName() string { return "QueueElementValidationError" }

// Error satisfies the builtin error interface
func (e QueueElementValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sQueueElement.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = QueueElementValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = QueueElementValidationError{}

// Validate checks the field values on CreateJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateJobRequestMultiError, or nil if none found.
func (m *CreateJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateJobRequestValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateJobRequestValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateJobRequestValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateJobRequestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateJobRequestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateJobRequestValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CacheRead

	// no validation rules for CacheWrite

	if len(errors) > 0 {
		return CreateJobRequestMultiError(errors)
	}

	return nil
}

// CreateJobRequestMultiError is an error wrapping multiple validation errors
// returned by CreateJobRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateJobRequestMultiError) AllErrors() []error { return m }

// CreateJobRequestValidationError is the validation error returned by
// CreateJobRequest.Validate if the designated constraints aren't met.
type CreateJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateJobRequestValidationError) ErrorName() string { return "CreateJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e CreateJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateJobRequestValidationError{}

// Validate checks the field values on CreateJobResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateJobResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateJobResponseMultiError, or nil if none found.
func (m *CreateJobResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateJobResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateJobResponseValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateJobResponseValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateJobResponseValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateJobResponseMultiError(errors)
	}

	return nil
}

// CreateJobResponseMultiError is an error wrapping multiple validation errors
// returned by CreateJobResponse.ValidateAll() if the designated constraints
// aren't met.
type CreateJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateJobResponseMultiError) AllErrors() []error { return m }

// CreateJobResponseValidationError is the validation error returned by
// CreateJobResponse.Validate if the designated constraints aren't met.
type CreateJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateJobResponseValidationError) ErrorName() string {
	return "CreateJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateJobResponseValidationError{}

// Validate checks the field values on CancelJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CancelJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelJobRequestMultiError, or nil if none found.
func (m *CancelJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CancelJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CancelJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CancelJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CancelJobRequestMultiError(errors)
	}

	return nil
}

// CancelJobRequestMultiError is an error wrapping multiple validation errors
// returned by CancelJobRequest.ValidateAll() if the designated constraints
// aren't met.
type CancelJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelJobRequestMultiError) AllErrors() []error { return m }

// CancelJobRequestValidationError is the validation error returned by
// CancelJobRequest.Validate if the designated constraints aren't met.
type CancelJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelJobRequestValidationError) ErrorName() string { return "CancelJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e CancelJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelJobRequestValidationError{}

// Validate checks the field values on CancelJobResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CancelJobResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CancelJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CancelJobResponseMultiError, or nil if none found.
func (m *CancelJobResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CancelJobResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CancelJobResponseMultiError(errors)
	}

	return nil
}

// CancelJobResponseMultiError is an error wrapping multiple validation errors
// returned by CancelJobResponse.ValidateAll() if the designated constraints
// aren't met.
type CancelJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelJobResponseMultiError) AllErrors() []error { return m }

// CancelJobResponseValidationError is the validation error returned by
// CancelJobResponse.Validate if the designated constraints aren't met.
type CancelJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelJobResponseValidationError) ErrorName() string {
	return "CancelJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CancelJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelJobResponseValidationError{}

// Validate checks the field values on DeleteJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteJobRequestMultiError, or nil if none found.
func (m *DeleteJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteJobRequestMultiError(errors)
	}

	return nil
}

// DeleteJobRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteJobRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteJobRequestMultiError) AllErrors() []error { return m }

// DeleteJobRequestValidationError is the validation error returned by
// DeleteJobRequest.Validate if the designated constraints aren't met.
type DeleteJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteJobRequestValidationError) ErrorName() string { return "DeleteJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteJobRequestValidationError{}

// Validate checks the field values on DeleteJobResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteJobResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteJobResponseMultiError, or nil if none found.
func (m *DeleteJobResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteJobResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteJobResponseMultiError(errors)
	}

	return nil
}

// DeleteJobResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteJobResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteJobResponseMultiError) AllErrors() []error { return m }

// DeleteJobResponseValidationError is the validation error returned by
// DeleteJobResponse.Validate if the designated constraints aren't met.
type DeleteJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteJobResponseValidationError) ErrorName() string {
	return "DeleteJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteJobResponseValidationError{}

// Validate checks the field values on ListJobRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListJobRequestMultiError,
// or nil if none found.
func (m *ListJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListJobRequestMultiError(errors)
	}

	return nil
}

// ListJobRequestMultiError is an error wrapping multiple validation errors
// returned by ListJobRequest.ValidateAll() if the designated constraints
// aren't met.
type ListJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListJobRequestMultiError) AllErrors() []error { return m }

// ListJobRequestValidationError is the validation error returned by
// ListJobRequest.Validate if the designated constraints aren't met.
type ListJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListJobRequestValidationError) ErrorName() string { return "ListJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListJobRequestValidationError{}

// Validate checks the field values on WalkJobRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WalkJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalkJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WalkJobRequestMultiError,
// or nil if none found.
func (m *WalkJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WalkJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalkJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalkJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalkJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WalkJobRequestMultiError(errors)
	}

	return nil
}

// WalkJobRequestMultiError is an error wrapping multiple validation errors
// returned by WalkJobRequest.ValidateAll() if the designated constraints
// aren't met.
type WalkJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalkJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalkJobRequestMultiError) AllErrors() []error { return m }

// WalkJobRequestValidationError is the validation error returned by
// WalkJobRequest.Validate if the designated constraints aren't met.
type WalkJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalkJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalkJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalkJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalkJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalkJobRequestValidationError) ErrorName() string { return "WalkJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e WalkJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalkJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalkJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalkJobRequestValidationError{}

// Validate checks the field values on InspectJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InspectJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectJobRequestMultiError, or nil if none found.
func (m *InspectJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectJobRequestMultiError(errors)
	}

	return nil
}

// InspectJobRequestMultiError is an error wrapping multiple validation errors
// returned by InspectJobRequest.ValidateAll() if the designated constraints
// aren't met.
type InspectJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectJobRequestMultiError) AllErrors() []error { return m }

// InspectJobRequestValidationError is the validation error returned by
// InspectJobRequest.Validate if the designated constraints aren't met.
type InspectJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectJobRequestValidationError) ErrorName() string {
	return "InspectJobRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectJobRequestValidationError{}

// Validate checks the field values on ProcessQueueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessQueueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessQueueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessQueueRequestMultiError, or nil if none found.
func (m *ProcessQueueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessQueueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessQueueRequestValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessQueueRequestValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessQueueRequestValidationError{
				field:  "Queue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Result.(type) {
	case *ProcessQueueRequest_Output:
		if v == nil {
			err := ProcessQueueRequestValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOutput()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ProcessQueueRequestValidationError{
						field:  "Output",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ProcessQueueRequestValidationError{
						field:  "Output",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOutput()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ProcessQueueRequestValidationError{
					field:  "Output",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ProcessQueueRequest_Failed:
		if v == nil {
			err := ProcessQueueRequestValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Failed
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ProcessQueueRequestMultiError(errors)
	}

	return nil
}

// ProcessQueueRequestMultiError is an error wrapping multiple validation
// errors returned by ProcessQueueRequest.ValidateAll() if the designated
// constraints aren't met.
type ProcessQueueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessQueueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessQueueRequestMultiError) AllErrors() []error { return m }

// ProcessQueueRequestValidationError is the validation error returned by
// ProcessQueueRequest.Validate if the designated constraints aren't met.
type ProcessQueueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessQueueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessQueueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessQueueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessQueueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessQueueRequestValidationError) ErrorName() string {
	return "ProcessQueueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessQueueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessQueueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessQueueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessQueueRequestValidationError{}

// Validate checks the field values on ProcessQueueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProcessQueueResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessQueueResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProcessQueueResponseMultiError, or nil if none found.
func (m *ProcessQueueResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessQueueResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Context

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessQueueResponseValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessQueueResponseValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessQueueResponseValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProcessQueueResponseMultiError(errors)
	}

	return nil
}

// ProcessQueueResponseMultiError is an error wrapping multiple validation
// errors returned by ProcessQueueResponse.ValidateAll() if the designated
// constraints aren't met.
type ProcessQueueResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessQueueResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessQueueResponseMultiError) AllErrors() []error { return m }

// ProcessQueueResponseValidationError is the validation error returned by
// ProcessQueueResponse.Validate if the designated constraints aren't met.
type ProcessQueueResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessQueueResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessQueueResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessQueueResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessQueueResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessQueueResponseValidationError) ErrorName() string {
	return "ProcessQueueResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ProcessQueueResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessQueueResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessQueueResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessQueueResponseValidationError{}

// Validate checks the field values on ListQueueRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListQueueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListQueueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListQueueRequestMultiError, or nil if none found.
func (m *ListQueueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListQueueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListQueueRequestMultiError(errors)
	}

	return nil
}

// ListQueueRequestMultiError is an error wrapping multiple validation errors
// returned by ListQueueRequest.ValidateAll() if the designated constraints
// aren't met.
type ListQueueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListQueueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListQueueRequestMultiError) AllErrors() []error { return m }

// ListQueueRequestValidationError is the validation error returned by
// ListQueueRequest.Validate if the designated constraints aren't met.
type ListQueueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListQueueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListQueueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListQueueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListQueueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListQueueRequestValidationError) ErrorName() string { return "ListQueueRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListQueueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListQueueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListQueueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListQueueRequestValidationError{}

// Validate checks the field values on InspectQueueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectQueueRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectQueueRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectQueueRequestMultiError, or nil if none found.
func (m *InspectQueueRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectQueueRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetQueue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectQueueRequestValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectQueueRequestValidationError{
					field:  "Queue",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetQueue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectQueueRequestValidationError{
				field:  "Queue",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectQueueRequestMultiError(errors)
	}

	return nil
}

// InspectQueueRequestMultiError is an error wrapping multiple validation
// errors returned by InspectQueueRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectQueueRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectQueueRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectQueueRequestMultiError) AllErrors() []error { return m }

// InspectQueueRequestValidationError is the validation error returned by
// InspectQueueRequest.Validate if the designated constraints aren't met.
type InspectQueueRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectQueueRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectQueueRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectQueueRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectQueueRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectQueueRequestValidationError) ErrorName() string {
	return "InspectQueueRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectQueueRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectQueueRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectQueueRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectQueueRequestValidationError{}
