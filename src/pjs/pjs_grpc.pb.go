// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: pjs/pjs.proto

package pjs

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	API_CreateJob_FullMethodName    = "/pjs.API/CreateJob"
	API_CancelJob_FullMethodName    = "/pjs.API/CancelJob"
	API_DeleteJob_FullMethodName    = "/pjs.API/DeleteJob"
	API_ListJob_FullMethodName      = "/pjs.API/ListJob"
	API_WalkJob_FullMethodName      = "/pjs.API/WalkJob"
	API_InspectJob_FullMethodName   = "/pjs.API/InspectJob"
	API_ProcessQueue_FullMethodName = "/pjs.API/ProcessQueue"
	API_ListQueue_FullMethodName    = "/pjs.API/ListQueue"
	API_InspectQueue_FullMethodName = "/pjs.API/InspectQueue"
	API_Await_FullMethodName        = "/pjs.API/Await"
)

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type APIClient interface {
	// CreateJob creates a new job.
	// Child jobs can be created by setting the context field to the appropriate parent job context.
	CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*CreateJobResponse, error)
	// CancelJob cancels a job.
	// Canceling a job transitions all of the associated QUEUED and PROCESSING jobs to the DONE state and sets their error codes to CANCELED.
	// This will terminate all ongoing processing associated with the job.
	// Nothing will be deleted.
	// A job can only be canceled with the parent job context.
	CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error)
	// DeleteJob deletes a job.
	// DeleteJob first cancels the job, then deletes all of the metadata and filesets associated with the job.
	// A job can only be deleted with the parent job context.
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error)
	// ListJob returns a list of jobs and information about each job.
	// The jobs returned in the list are the child jobs of the provided job.
	// If no job is provided, the list is the child jobs of the provided job context.
	// The provided job must be associated with the provided job context or a descendant of the job associated with the provided job context.
	ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobClient, error)
	// WalkJob returns a list of jobs in a hierarchy and information about each job.
	// Walking a job traverses the job hierarchy rooted at the provided job.
	// The provided job must be associated with the provided job context or a descendant of the job associated with the provided job context.
	WalkJob(ctx context.Context, in *WalkJobRequest, opts ...grpc.CallOption) (API_WalkJobClient, error)
	// InspectJob returns detailed information about a job.
	InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*InspectJobResponse, error)
	// ProcessQueue should be called by workers to process jobs in a queue.
	// The protocol is as follows:
	//
	//	Worker sends an initial request with the queue id.
	//	For each job:
	//	  Server sends a response with a job context and the associated queue element.
	//	  Worker processes the job.
	//	  Worker sends a request with the job output or indicates that the job failed.
	//
	// This RPC should generally be run indefinitely. Workers will be scaled based on demand, so the expectation is that they should be processing queues while they are up.
	// This RPC will be canceled by the server if the current job is canceled. Workers should generally retry the RPC when disconnects occur.
	ProcessQueue(ctx context.Context, opts ...grpc.CallOption) (API_ProcessQueueClient, error)
	// ListQueue returns a list of queues and information about each queue.
	ListQueue(ctx context.Context, in *ListQueueRequest, opts ...grpc.CallOption) (API_ListQueueClient, error)
	// InspectQueue returns detailed information about a queue.
	InspectQueue(ctx context.Context, in *InspectQueueRequest, opts ...grpc.CallOption) (*InspectQueueResponse, error)
	// Await blocks until the job has entered or passed the desired state.
	// Await returns the actual state of the job that met the criteria.
	// Await can timeout with DEADLINE_EXCEEDED.  In this case clients may
	// retry in a new request.
	Await(ctx context.Context, in *AwaitRequest, opts ...grpc.CallOption) (*AwaitResponse, error)
}

type aPIClient struct {
	cc grpc.ClientConnInterface
}

func NewAPIClient(cc grpc.ClientConnInterface) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateJob(ctx context.Context, in *CreateJobRequest, opts ...grpc.CallOption) (*CreateJobResponse, error) {
	out := new(CreateJobResponse)
	err := c.cc.Invoke(ctx, API_CreateJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CancelJob(ctx context.Context, in *CancelJobRequest, opts ...grpc.CallOption) (*CancelJobResponse, error) {
	out := new(CancelJobResponse)
	err := c.cc.Invoke(ctx, API_CancelJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*DeleteJobResponse, error) {
	out := new(DeleteJobResponse)
	err := c.cc.Invoke(ctx, API_DeleteJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobClient, error) {
	stream, err := c.cc.NewStream(ctx, &API_ServiceDesc.Streams[0], API_ListJob_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListJobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListJobClient interface {
	Recv() (*ListJobResponse, error)
	grpc.ClientStream
}

type aPIListJobClient struct {
	grpc.ClientStream
}

func (x *aPIListJobClient) Recv() (*ListJobResponse, error) {
	m := new(ListJobResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) WalkJob(ctx context.Context, in *WalkJobRequest, opts ...grpc.CallOption) (API_WalkJobClient, error) {
	stream, err := c.cc.NewStream(ctx, &API_ServiceDesc.Streams[1], API_WalkJob_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIWalkJobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_WalkJobClient interface {
	Recv() (*ListJobResponse, error)
	grpc.ClientStream
}

type aPIWalkJobClient struct {
	grpc.ClientStream
}

func (x *aPIWalkJobClient) Recv() (*ListJobResponse, error) {
	m := new(ListJobResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*InspectJobResponse, error) {
	out := new(InspectJobResponse)
	err := c.cc.Invoke(ctx, API_InspectJob_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ProcessQueue(ctx context.Context, opts ...grpc.CallOption) (API_ProcessQueueClient, error) {
	stream, err := c.cc.NewStream(ctx, &API_ServiceDesc.Streams[2], API_ProcessQueue_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIProcessQueueClient{stream}
	return x, nil
}

type API_ProcessQueueClient interface {
	Send(*ProcessQueueRequest) error
	Recv() (*ProcessQueueResponse, error)
	grpc.ClientStream
}

type aPIProcessQueueClient struct {
	grpc.ClientStream
}

func (x *aPIProcessQueueClient) Send(m *ProcessQueueRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIProcessQueueClient) Recv() (*ProcessQueueResponse, error) {
	m := new(ProcessQueueResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ListQueue(ctx context.Context, in *ListQueueRequest, opts ...grpc.CallOption) (API_ListQueueClient, error) {
	stream, err := c.cc.NewStream(ctx, &API_ServiceDesc.Streams[3], API_ListQueue_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListQueueClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListQueueClient interface {
	Recv() (*ListQueueResponse, error)
	grpc.ClientStream
}

type aPIListQueueClient struct {
	grpc.ClientStream
}

func (x *aPIListQueueClient) Recv() (*ListQueueResponse, error) {
	m := new(ListQueueResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectQueue(ctx context.Context, in *InspectQueueRequest, opts ...grpc.CallOption) (*InspectQueueResponse, error) {
	out := new(InspectQueueResponse)
	err := c.cc.Invoke(ctx, API_InspectQueue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Await(ctx context.Context, in *AwaitRequest, opts ...grpc.CallOption) (*AwaitResponse, error) {
	out := new(AwaitResponse)
	err := c.cc.Invoke(ctx, API_Await_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIServer is the server API for API service.
// All implementations must embed UnimplementedAPIServer
// for forward compatibility
type APIServer interface {
	// CreateJob creates a new job.
	// Child jobs can be created by setting the context field to the appropriate parent job context.
	CreateJob(context.Context, *CreateJobRequest) (*CreateJobResponse, error)
	// CancelJob cancels a job.
	// Canceling a job transitions all of the associated QUEUED and PROCESSING jobs to the DONE state and sets their error codes to CANCELED.
	// This will terminate all ongoing processing associated with the job.
	// Nothing will be deleted.
	// A job can only be canceled with the parent job context.
	CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error)
	// DeleteJob deletes a job.
	// DeleteJob first cancels the job, then deletes all of the metadata and filesets associated with the job.
	// A job can only be deleted with the parent job context.
	DeleteJob(context.Context, *DeleteJobRequest) (*DeleteJobResponse, error)
	// ListJob returns a list of jobs and information about each job.
	// The jobs returned in the list are the child jobs of the provided job.
	// If no job is provided, the list is the child jobs of the provided job context.
	// The provided job must be associated with the provided job context or a descendant of the job associated with the provided job context.
	ListJob(*ListJobRequest, API_ListJobServer) error
	// WalkJob returns a list of jobs in a hierarchy and information about each job.
	// Walking a job traverses the job hierarchy rooted at the provided job.
	// The provided job must be associated with the provided job context or a descendant of the job associated with the provided job context.
	WalkJob(*WalkJobRequest, API_WalkJobServer) error
	// InspectJob returns detailed information about a job.
	InspectJob(context.Context, *InspectJobRequest) (*InspectJobResponse, error)
	// ProcessQueue should be called by workers to process jobs in a queue.
	// The protocol is as follows:
	//
	//	Worker sends an initial request with the queue id.
	//	For each job:
	//	  Server sends a response with a job context and the associated queue element.
	//	  Worker processes the job.
	//	  Worker sends a request with the job output or indicates that the job failed.
	//
	// This RPC should generally be run indefinitely. Workers will be scaled based on demand, so the expectation is that they should be processing queues while they are up.
	// This RPC will be canceled by the server if the current job is canceled. Workers should generally retry the RPC when disconnects occur.
	ProcessQueue(API_ProcessQueueServer) error
	// ListQueue returns a list of queues and information about each queue.
	ListQueue(*ListQueueRequest, API_ListQueueServer) error
	// InspectQueue returns detailed information about a queue.
	InspectQueue(context.Context, *InspectQueueRequest) (*InspectQueueResponse, error)
	// Await blocks until the job has entered or passed the desired state.
	// Await returns the actual state of the job that met the criteria.
	// Await can timeout with DEADLINE_EXCEEDED.  In this case clients may
	// retry in a new request.
	Await(context.Context, *AwaitRequest) (*AwaitResponse, error)
	mustEmbedUnimplementedAPIServer()
}

// UnimplementedAPIServer must be embedded to have forward compatible implementations.
type UnimplementedAPIServer struct {
}

func (UnimplementedAPIServer) CreateJob(context.Context, *CreateJobRequest) (*CreateJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateJob not implemented")
}
func (UnimplementedAPIServer) CancelJob(context.Context, *CancelJobRequest) (*CancelJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (UnimplementedAPIServer) DeleteJob(context.Context, *DeleteJobRequest) (*DeleteJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (UnimplementedAPIServer) ListJob(*ListJobRequest, API_ListJobServer) error {
	return status.Errorf(codes.Unimplemented, "method ListJob not implemented")
}
func (UnimplementedAPIServer) WalkJob(*WalkJobRequest, API_WalkJobServer) error {
	return status.Errorf(codes.Unimplemented, "method WalkJob not implemented")
}
func (UnimplementedAPIServer) InspectJob(context.Context, *InspectJobRequest) (*InspectJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectJob not implemented")
}
func (UnimplementedAPIServer) ProcessQueue(API_ProcessQueueServer) error {
	return status.Errorf(codes.Unimplemented, "method ProcessQueue not implemented")
}
func (UnimplementedAPIServer) ListQueue(*ListQueueRequest, API_ListQueueServer) error {
	return status.Errorf(codes.Unimplemented, "method ListQueue not implemented")
}
func (UnimplementedAPIServer) InspectQueue(context.Context, *InspectQueueRequest) (*InspectQueueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectQueue not implemented")
}
func (UnimplementedAPIServer) Await(context.Context, *AwaitRequest) (*AwaitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Await not implemented")
}
func (UnimplementedAPIServer) mustEmbedUnimplementedAPIServer() {}

// UnsafeAPIServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to APIServer will
// result in compilation errors.
type UnsafeAPIServer interface {
	mustEmbedUnimplementedAPIServer()
}

func RegisterAPIServer(s grpc.ServiceRegistrar, srv APIServer) {
	s.RegisterService(&API_ServiceDesc, srv)
}

func _API_CreateJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CreateJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateJob(ctx, req.(*CreateJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_CancelJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CancelJob(ctx, req.(*CancelJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_DeleteJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListJob(m, &aPIListJobServer{stream})
}

type API_ListJobServer interface {
	Send(*ListJobResponse) error
	grpc.ServerStream
}

type aPIListJobServer struct {
	grpc.ServerStream
}

func (x *aPIListJobServer) Send(m *ListJobResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_WalkJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WalkJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).WalkJob(m, &aPIWalkJobServer{stream})
}

type API_WalkJobServer interface {
	Send(*ListJobResponse) error
	grpc.ServerStream
}

type aPIWalkJobServer struct {
	grpc.ServerStream
}

func (x *aPIWalkJobServer) Send(m *ListJobResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_InspectJob_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectJob(ctx, req.(*InspectJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ProcessQueue_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).ProcessQueue(&aPIProcessQueueServer{stream})
}

type API_ProcessQueueServer interface {
	Send(*ProcessQueueResponse) error
	Recv() (*ProcessQueueRequest, error)
	grpc.ServerStream
}

type aPIProcessQueueServer struct {
	grpc.ServerStream
}

func (x *aPIProcessQueueServer) Send(m *ProcessQueueResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIProcessQueueServer) Recv() (*ProcessQueueRequest, error) {
	m := new(ProcessQueueRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_ListQueue_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListQueueRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListQueue(m, &aPIListQueueServer{stream})
}

type API_ListQueueServer interface {
	Send(*ListQueueResponse) error
	grpc.ServerStream
}

type aPIListQueueServer struct {
	grpc.ServerStream
}

func (x *aPIListQueueServer) Send(m *ListQueueResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectQueueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_InspectQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectQueue(ctx, req.(*InspectQueueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Await_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AwaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Await(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: API_Await_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Await(ctx, req.(*AwaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// API_ServiceDesc is the grpc.ServiceDesc for API service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var API_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pjs.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateJob",
			Handler:    _API_CreateJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _API_CancelJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _API_DeleteJob_Handler,
		},
		{
			MethodName: "InspectJob",
			Handler:    _API_InspectJob_Handler,
		},
		{
			MethodName: "InspectQueue",
			Handler:    _API_InspectQueue_Handler,
		},
		{
			MethodName: "Await",
			Handler:    _API_Await_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListJob",
			Handler:       _API_ListJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WalkJob",
			Handler:       _API_WalkJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ProcessQueue",
			Handler:       _API_ProcessQueue_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "ListQueue",
			Handler:       _API_ListQueue_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pjs/pjs.proto",
}
