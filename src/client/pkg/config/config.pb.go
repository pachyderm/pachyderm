// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: client/pkg/config/config.proto

package config

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ContextSource int32

const (
	ContextSource_NONE      ContextSource = 0
	ContextSource_CONFIG_V1 ContextSource = 1
	ContextSource_HUB       ContextSource = 2
	ContextSource_IMPORTED  ContextSource = 3
)

var ContextSource_name = map[int32]string{
	0: "NONE",
	1: "CONFIG_V1",
	2: "HUB",
	3: "IMPORTED",
}

var ContextSource_value = map[string]int32{
	"NONE":      0,
	"CONFIG_V1": 1,
	"HUB":       2,
	"IMPORTED":  3,
}

func (x ContextSource) String() string {
	return proto.EnumName(ContextSource_name, int32(x))
}

func (ContextSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_60f651abce1dcdf3, []int{0}
}

// Config specifies the pachyderm config that is read and interpreted by the
// pachctl command-line tool. Right now, this is stored at
// $HOME/.pachyderm/config.
//
// Different versions of the pachyderm config are specified as subfields of this
// message (this allows us to make significant changes to the config structure
// without breaking existing users by defining a new config version).
//
// DO NOT change or remove field numbers from this proto, otherwise ALL
// pachyderm user configs will fail to parse.
type Config struct {
	UserID string `protobuf:"bytes,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// Configuration options. Exactly one of these fields should be set
	// (depending on which version of the config is being used)
	V1                   *ConfigV1 `protobuf:"bytes,2,opt,name=v1,proto3" json:"v1,omitempty"`
	V2                   *ConfigV2 `protobuf:"bytes,3,opt,name=v2,proto3" json:"v2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f651abce1dcdf3, []int{0}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

func (m *Config) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Config) GetV1() *ConfigV1 {
	if m != nil {
		return m.V1
	}
	return nil
}

func (m *Config) GetV2() *ConfigV2 {
	if m != nil {
		return m.V2
	}
	return nil
}

// ConfigV1 specifies v1 of the pachyderm config (June 30 2017 - June 2019)
// DO NOT change or remove field numbers from this proto, as if you do, v1 user
// configs will become unparseable.
type ConfigV1 struct {
	// A host:port pointing pachd at a pachyderm cluster.
	PachdAddress string `protobuf:"bytes,2,opt,name=pachd_address,json=pachdAddress,proto3" json:"pachd_address,omitempty"`
	// Trusted root certificates (overrides installed certificates), formatted
	// as base64-encoded PEM
	ServerCAs string `protobuf:"bytes,3,opt,name=server_cas,json=serverCas,proto3" json:"server_cas,omitempty"`
	// A secret token identifying the current pachctl user within their
	// pachyderm cluster. This is included in all RPCs sent by pachctl, and used
	// to determine if pachctl actions are authorized.
	SessionToken string `protobuf:"bytes,1,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// The currently active transaction for batching together pachctl commands.
	// This can be set or cleared via many of the `pachctl * transaction` commands.
	// This is the ID of the transaction object stored in the pachyderm etcd.
	ActiveTransaction    string   `protobuf:"bytes,4,opt,name=active_transaction,json=activeTransaction,proto3" json:"active_transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConfigV1) Reset()         { *m = ConfigV1{} }
func (m *ConfigV1) String() string { return proto.CompactTextString(m) }
func (*ConfigV1) ProtoMessage()    {}
func (*ConfigV1) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f651abce1dcdf3, []int{1}
}
func (m *ConfigV1) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigV1) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigV1.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigV1) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigV1.Merge(m, src)
}
func (m *ConfigV1) XXX_Size() int {
	return m.Size()
}
func (m *ConfigV1) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigV1.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigV1 proto.InternalMessageInfo

func (m *ConfigV1) GetPachdAddress() string {
	if m != nil {
		return m.PachdAddress
	}
	return ""
}

func (m *ConfigV1) GetServerCAs() string {
	if m != nil {
		return m.ServerCAs
	}
	return ""
}

func (m *ConfigV1) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *ConfigV1) GetActiveTransaction() string {
	if m != nil {
		return m.ActiveTransaction
	}
	return ""
}

// ConfigV2 specifies v2 of the pachyderm config (June 2019 - present)
type ConfigV2 struct {
	ActiveContext        string              `protobuf:"bytes,1,opt,name=active_context,json=activeContext,proto3" json:"active_context,omitempty"`
	Contexts             map[string]*Context `protobuf:"bytes,2,rep,name=contexts,proto3" json:"contexts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Metrics              bool                `protobuf:"varint,3,opt,name=metrics,proto3" json:"metrics,omitempty"`
	MaxShellCompletions  int64               `protobuf:"varint,4,opt,name=max_shell_completions,json=maxShellCompletions,proto3" json:"max_shell_completions,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ConfigV2) Reset()         { *m = ConfigV2{} }
func (m *ConfigV2) String() string { return proto.CompactTextString(m) }
func (*ConfigV2) ProtoMessage()    {}
func (*ConfigV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f651abce1dcdf3, []int{2}
}
func (m *ConfigV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigV2.Merge(m, src)
}
func (m *ConfigV2) XXX_Size() int {
	return m.Size()
}
func (m *ConfigV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigV2.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigV2 proto.InternalMessageInfo

func (m *ConfigV2) GetActiveContext() string {
	if m != nil {
		return m.ActiveContext
	}
	return ""
}

func (m *ConfigV2) GetContexts() map[string]*Context {
	if m != nil {
		return m.Contexts
	}
	return nil
}

func (m *ConfigV2) GetMetrics() bool {
	if m != nil {
		return m.Metrics
	}
	return false
}

func (m *ConfigV2) GetMaxShellCompletions() int64 {
	if m != nil {
		return m.MaxShellCompletions
	}
	return 0
}

type Context struct {
	// Where this context came from
	Source ContextSource `protobuf:"varint,1,opt,name=source,proto3,enum=config.ContextSource" json:"source,omitempty"`
	// The hostname or IP address pointing pachd at a pachyderm cluster.
	PachdAddress string `protobuf:"bytes,2,opt,name=pachd_address,json=pachdAddress,proto3" json:"pachd_address,omitempty"`
	// Trusted root certificates (overrides installed certificates), formatted
	// as base64-encoded PEM.
	ServerCAs string `protobuf:"bytes,3,opt,name=server_cas,json=serverCas,proto3" json:"server_cas,omitempty"`
	// A secret token identifying the current pachctl user within their
	// pachyderm cluster. This is included in all RPCs sent by pachctl, and used
	// to determine if pachctl actions are authorized.
	SessionToken string `protobuf:"bytes,4,opt,name=session_token,json=sessionToken,proto3" json:"session_token,omitempty"`
	// The currently active transaction for batching together pachctl commands.
	// This can be set or cleared via many of the `pachctl * transaction` commands.
	// This is the ID of the transaction object stored in the pachyderm etcd.
	ActiveTransaction string `protobuf:"bytes,5,opt,name=active_transaction,json=activeTransaction,proto3" json:"active_transaction,omitempty"`
	// The k8s cluster name - used to construct a k8s context.
	ClusterName string `protobuf:"bytes,6,opt,name=cluster_name,json=clusterName,proto3" json:"cluster_name,omitempty"`
	// The k8s auth info - used to construct a k8s context.
	AuthInfo string `protobuf:"bytes,7,opt,name=auth_info,json=authInfo,proto3" json:"auth_info,omitempty"`
	// The k8s namespace - used to construct a k8s context.
	Namespace string `protobuf:"bytes,8,opt,name=namespace,proto3" json:"namespace,omitempty"`
	// A unique ID for the cluster. At client initialization time, we ensure
	// this is the same as what the cluster reports back, to prevent us from
	// connecting to the wrong cluster.
	ClusterID string `protobuf:"bytes,9,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	// A mapping of service -> port number, when port forwarding is
	// running for this context.
	PortForwarders       map[string]uint32 `protobuf:"bytes,10,rep,name=port_forwarders,json=portForwarders,proto3" json:"port_forwarders,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Context) Reset()         { *m = Context{} }
func (m *Context) String() string { return proto.CompactTextString(m) }
func (*Context) ProtoMessage()    {}
func (*Context) Descriptor() ([]byte, []int) {
	return fileDescriptor_60f651abce1dcdf3, []int{3}
}
func (m *Context) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Context) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Context.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Context) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Context.Merge(m, src)
}
func (m *Context) XXX_Size() int {
	return m.Size()
}
func (m *Context) XXX_DiscardUnknown() {
	xxx_messageInfo_Context.DiscardUnknown(m)
}

var xxx_messageInfo_Context proto.InternalMessageInfo

func (m *Context) GetSource() ContextSource {
	if m != nil {
		return m.Source
	}
	return ContextSource_NONE
}

func (m *Context) GetPachdAddress() string {
	if m != nil {
		return m.PachdAddress
	}
	return ""
}

func (m *Context) GetServerCAs() string {
	if m != nil {
		return m.ServerCAs
	}
	return ""
}

func (m *Context) GetSessionToken() string {
	if m != nil {
		return m.SessionToken
	}
	return ""
}

func (m *Context) GetActiveTransaction() string {
	if m != nil {
		return m.ActiveTransaction
	}
	return ""
}

func (m *Context) GetClusterName() string {
	if m != nil {
		return m.ClusterName
	}
	return ""
}

func (m *Context) GetAuthInfo() string {
	if m != nil {
		return m.AuthInfo
	}
	return ""
}

func (m *Context) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *Context) GetClusterID() string {
	if m != nil {
		return m.ClusterID
	}
	return ""
}

func (m *Context) GetPortForwarders() map[string]uint32 {
	if m != nil {
		return m.PortForwarders
	}
	return nil
}

func init() {
	proto.RegisterEnum("config.ContextSource", ContextSource_name, ContextSource_value)
	proto.RegisterType((*Config)(nil), "config.Config")
	proto.RegisterType((*ConfigV1)(nil), "config.ConfigV1")
	proto.RegisterType((*ConfigV2)(nil), "config.ConfigV2")
	proto.RegisterMapType((map[string]*Context)(nil), "config.ConfigV2.ContextsEntry")
	proto.RegisterType((*Context)(nil), "config.Context")
	proto.RegisterMapType((map[string]uint32)(nil), "config.Context.PortForwardersEntry")
}

func init() { proto.RegisterFile("client/pkg/config/config.proto", fileDescriptor_60f651abce1dcdf3) }

var fileDescriptor_60f651abce1dcdf3 = []byte{
	// 657 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0xcd, 0x4e, 0xdb, 0x4a,
	0x14, 0xbe, 0x4e, 0x20, 0x89, 0x0f, 0x09, 0xe4, 0x0e, 0x20, 0x59, 0xdc, 0xab, 0x40, 0x83, 0x90,
	0x50, 0x55, 0x12, 0xc5, 0xed, 0xa2, 0x62, 0x53, 0x11, 0x03, 0xad, 0x25, 0x1a, 0x90, 0xf9, 0x59,
	0x74, 0x63, 0x0d, 0xf6, 0x24, 0xb1, 0x88, 0x3d, 0xee, 0xcc, 0x24, 0x85, 0x47, 0xe8, 0xe3, 0xf4,
	0x2d, 0xba, 0xec, 0x13, 0xa0, 0x2a, 0xcf, 0xd1, 0x45, 0x35, 0x33, 0xce, 0x0f, 0x94, 0x4a, 0x5d,
	0x75, 0xe5, 0xe3, 0xef, 0xfb, 0xce, 0x99, 0x73, 0xe6, 0x7c, 0x1a, 0xa8, 0x05, 0x83, 0x88, 0x24,
	0xa2, 0x99, 0xde, 0xf4, 0x9a, 0x01, 0x4d, 0xba, 0xd1, 0xe4, 0xd3, 0x48, 0x19, 0x15, 0x14, 0x15,
	0xf4, 0xdf, 0xc6, 0x5a, 0x8f, 0xf6, 0xa8, 0x82, 0x9a, 0x32, 0xd2, 0x6c, 0xfd, 0x23, 0x14, 0x1c,
	0xc5, 0xa3, 0x6d, 0x28, 0x0e, 0x39, 0x61, 0x7e, 0x14, 0x5a, 0xc6, 0x96, 0xb1, 0x6b, 0xb6, 0x61,
	0x7c, 0xbf, 0x59, 0xb8, 0xe4, 0x84, 0xb9, 0x87, 0x5e, 0x41, 0x52, 0x6e, 0x88, 0xb6, 0x20, 0x37,
	0x6a, 0x59, 0xb9, 0x2d, 0x63, 0x77, 0xc9, 0xae, 0x36, 0xb2, 0x73, 0x74, 0x81, 0xab, 0x96, 0x97,
	0x1b, 0xb5, 0x94, 0xc2, 0xb6, 0xf2, 0x4f, 0x2a, 0x6c, 0x2f, 0x37, 0xb2, 0xeb, 0x5f, 0x0c, 0x28,
	0x4d, 0x52, 0xd0, 0x36, 0x54, 0x52, 0x1c, 0xf4, 0x43, 0x1f, 0x87, 0x21, 0x23, 0x9c, 0xab, 0xda,
	0xa6, 0x57, 0x56, 0xe0, 0x81, 0xc6, 0xd0, 0x0b, 0x00, 0x4e, 0xd8, 0x88, 0x30, 0x3f, 0xc0, 0x5c,
	0xd5, 0x36, 0xdb, 0x95, 0xf1, 0xfd, 0xa6, 0x79, 0xae, 0x50, 0xe7, 0x80, 0x7b, 0xa6, 0x16, 0x38,
	0x98, 0xcb, 0x92, 0x9c, 0x70, 0x1e, 0xd1, 0xc4, 0x17, 0xf4, 0x86, 0x24, 0x7a, 0x1c, 0xaf, 0x9c,
	0x81, 0x17, 0x12, 0x43, 0x7b, 0x80, 0x70, 0x20, 0xa2, 0x11, 0xf1, 0x05, 0xc3, 0x09, 0x97, 0x31,
	0x4d, 0xac, 0x05, 0xa5, 0xfc, 0x57, 0x33, 0x17, 0x33, 0xa2, 0xfe, 0x39, 0x37, 0xed, 0xd9, 0x46,
	0x3b, 0xb0, 0x9c, 0xe5, 0x06, 0x34, 0x11, 0xe4, 0x56, 0x64, 0x27, 0x54, 0x34, 0xea, 0x68, 0x10,
	0xed, 0x43, 0x29, 0xe3, 0xe5, 0x54, 0xf9, 0xdd, 0x25, 0xbb, 0xf6, 0xf8, 0x3e, 0x1a, 0x99, 0x96,
	0x1f, 0x25, 0x82, 0xdd, 0x79, 0x53, 0x3d, 0xb2, 0xa0, 0x18, 0x13, 0xc1, 0xa2, 0x40, 0x8f, 0x5b,
	0xf2, 0x26, 0xbf, 0xc8, 0x86, 0xf5, 0x18, 0xdf, 0xfa, 0xbc, 0x4f, 0x06, 0x03, 0x3f, 0xa0, 0x71,
	0x3a, 0x20, 0xb2, 0x43, 0xae, 0x7a, 0xcf, 0x7b, 0xab, 0x31, 0xbe, 0x3d, 0x97, 0x9c, 0x33, 0xa3,
	0x36, 0x4e, 0xa0, 0xf2, 0xe0, 0x20, 0x54, 0x85, 0xfc, 0x0d, 0xb9, 0xcb, 0xda, 0x96, 0x21, 0xda,
	0x81, 0xc5, 0x11, 0x1e, 0x0c, 0x49, 0xb6, 0xdb, 0x95, 0xb9, 0x4e, 0x65, 0x9e, 0xa7, 0xd9, 0xfd,
	0xdc, 0x6b, 0xa3, 0xfe, 0x23, 0x0f, 0xc5, 0xc9, 0x8c, 0x7b, 0x50, 0xe0, 0x74, 0xc8, 0x02, 0xa2,
	0x6a, 0x2d, 0xdb, 0xeb, 0x8f, 0xf2, 0xce, 0x15, 0xe9, 0x65, 0xa2, 0xbf, 0xb2, 0xed, 0x85, 0x3f,
	0xde, 0xf6, 0xe2, 0x6f, 0xb6, 0x8d, 0x9e, 0x41, 0x39, 0x18, 0x0c, 0xb9, 0x20, 0xcc, 0x4f, 0x70,
	0x4c, 0xac, 0x82, 0x12, 0x2e, 0x65, 0x58, 0x07, 0xc7, 0x04, 0xfd, 0x07, 0x26, 0x1e, 0x8a, 0xbe,
	0x1f, 0x25, 0x5d, 0x6a, 0x15, 0x15, 0x5f, 0x92, 0x80, 0x9b, 0x74, 0x29, 0xfa, 0x1f, 0x4c, 0x99,
	0xc7, 0x53, 0x1c, 0x10, 0xab, 0xa4, 0xc8, 0x19, 0x20, 0xe7, 0x9b, 0x54, 0x8f, 0x42, 0xcb, 0x9c,
	0xcd, 0xe7, 0x68, 0xd4, 0x3d, 0xf4, 0xcc, 0x4c, 0xe0, 0x86, 0xe8, 0x04, 0x56, 0x52, 0xca, 0x84,
	0xdf, 0xa5, 0xec, 0x13, 0x66, 0x21, 0x61, 0xdc, 0x02, 0x65, 0xa6, 0xed, 0x47, 0x57, 0xdd, 0x38,
	0xa3, 0x4c, 0x1c, 0x4f, 0x55, 0xda, 0x51, 0xcb, 0xe9, 0x03, 0x70, 0xe3, 0x00, 0x56, 0x9f, 0x90,
	0x3d, 0xe1, 0x87, 0xb5, 0x79, 0x3f, 0x54, 0xe6, 0xd6, 0xff, 0xfc, 0xcd, 0xd4, 0x4c, 0x7a, 0xb9,
	0xa8, 0x04, 0x0b, 0x9d, 0xd3, 0xce, 0x51, 0xf5, 0x1f, 0x54, 0x01, 0xd3, 0x39, 0xed, 0x1c, 0xbb,
	0x6f, 0xfd, 0xab, 0x56, 0xd5, 0x40, 0x45, 0xc8, 0xbf, 0xbb, 0x6c, 0x57, 0x73, 0xa8, 0x0c, 0x25,
	0xf7, 0xfd, 0xd9, 0xa9, 0x77, 0x71, 0x74, 0x58, 0xcd, 0xb7, 0xdb, 0x5f, 0xc7, 0x35, 0xe3, 0xdb,
	0xb8, 0x66, 0x7c, 0x1f, 0xd7, 0x8c, 0x0f, 0xaf, 0x7a, 0x91, 0xe8, 0x0f, 0xaf, 0x1b, 0x01, 0x8d,
	0x9b, 0xd2, 0x06, 0x77, 0x21, 0x61, 0xf3, 0x11, 0x67, 0x41, 0xf3, 0x97, 0x17, 0xee, 0xba, 0xa0,
	0x5e, 0xaf, 0x97, 0x3f, 0x03, 0x00, 0x00, 0xff, 0xff, 0xa0, 0x9c, 0xaa, 0x6f, 0xfd, 0x04, 0x00,
	0x00,
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.V2 != nil {
		{
			size, err := m.V2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.V1 != nil {
		{
			size, err := m.V1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConfig(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.UserID) > 0 {
		i -= len(m.UserID)
		copy(dAtA[i:], m.UserID)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.UserID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigV1) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigV1) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigV1) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ActiveTransaction) > 0 {
		i -= len(m.ActiveTransaction)
		copy(dAtA[i:], m.ActiveTransaction)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ActiveTransaction)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServerCAs) > 0 {
		i -= len(m.ServerCAs)
		copy(dAtA[i:], m.ServerCAs)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ServerCAs)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PachdAddress) > 0 {
		i -= len(m.PachdAddress)
		copy(dAtA[i:], m.PachdAddress)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.PachdAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MaxShellCompletions != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.MaxShellCompletions))
		i--
		dAtA[i] = 0x20
	}
	if m.Metrics {
		i--
		if m.Metrics {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Contexts) > 0 {
		for k := range m.Contexts {
			v := m.Contexts[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintConfig(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintConfig(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintConfig(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ActiveContext) > 0 {
		i -= len(m.ActiveContext)
		copy(dAtA[i:], m.ActiveContext)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ActiveContext)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Context) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Context) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Context) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PortForwarders) > 0 {
		for k := range m.PortForwarders {
			v := m.PortForwarders[k]
			baseI := i
			i = encodeVarintConfig(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintConfig(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintConfig(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Namespace) > 0 {
		i -= len(m.Namespace)
		copy(dAtA[i:], m.Namespace)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.Namespace)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.AuthInfo) > 0 {
		i -= len(m.AuthInfo)
		copy(dAtA[i:], m.AuthInfo)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.AuthInfo)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ClusterName) > 0 {
		i -= len(m.ClusterName)
		copy(dAtA[i:], m.ClusterName)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ClusterName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ActiveTransaction) > 0 {
		i -= len(m.ActiveTransaction)
		copy(dAtA[i:], m.ActiveTransaction)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ActiveTransaction)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SessionToken) > 0 {
		i -= len(m.SessionToken)
		copy(dAtA[i:], m.SessionToken)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.SessionToken)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ServerCAs) > 0 {
		i -= len(m.ServerCAs)
		copy(dAtA[i:], m.ServerCAs)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.ServerCAs)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PachdAddress) > 0 {
		i -= len(m.PachdAddress)
		copy(dAtA[i:], m.PachdAddress)
		i = encodeVarintConfig(dAtA, i, uint64(len(m.PachdAddress)))
		i--
		dAtA[i] = 0x12
	}
	if m.Source != 0 {
		i = encodeVarintConfig(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintConfig(dAtA []byte, offset int, v uint64) int {
	offset -= sovConfig(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UserID)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.V1 != nil {
		l = m.V1.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.V2 != nil {
		l = m.V2.Size()
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigV1) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.PachdAddress)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ServerCAs)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ActiveTransaction)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ActiveContext)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.Contexts) > 0 {
		for k, v := range m.Contexts {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovConfig(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovConfig(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovConfig(uint64(mapEntrySize))
		}
	}
	if m.Metrics {
		n += 2
	}
	if m.MaxShellCompletions != 0 {
		n += 1 + sovConfig(uint64(m.MaxShellCompletions))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Context) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Source != 0 {
		n += 1 + sovConfig(uint64(m.Source))
	}
	l = len(m.PachdAddress)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ServerCAs)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.SessionToken)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ActiveTransaction)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.AuthInfo)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovConfig(uint64(l))
	}
	if len(m.PortForwarders) > 0 {
		for k, v := range m.PortForwarders {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConfig(uint64(len(k))) + 1 + sovConfig(uint64(v))
			n += mapEntrySize + 1 + sovConfig(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovConfig(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConfig(x uint64) (n int) {
	return sovConfig(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V1 == nil {
				m.V1 = &ConfigV1{}
			}
			if err := m.V1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V2 == nil {
				m.V2 = &ConfigV2{}
			}
			if err := m.V2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigV1) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigV1: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigV1: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PachdAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PachdAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerCAs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTransaction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveTransaction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveContext = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contexts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contexts == nil {
				m.Contexts = make(map[string]*Context)
			}
			var mapkey string
			var mapvalue *Context
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthConfig
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthConfig
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Context{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Contexts[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metrics", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Metrics = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxShellCompletions", wireType)
			}
			m.MaxShellCompletions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxShellCompletions |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Context) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Context: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Context: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= ContextSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PachdAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PachdAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerCAs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerCAs = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveTransaction", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveTransaction = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PortForwarders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConfig
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConfig
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PortForwarders == nil {
				m.PortForwarders = make(map[string]uint32)
			}
			var mapkey string
			var mapvalue uint32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConfig
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConfig
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConfig
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConfig(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthConfig
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PortForwarders[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConfig(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConfig
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConfig(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConfig
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConfig
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConfig
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConfig
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConfig
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConfig        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConfig          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConfig = fmt.Errorf("proto: unexpected end of group")
)
