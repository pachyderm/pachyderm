// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: server/worker/pipeline/transform/transform.proto

package transform

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CreateParallelDatumsTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateParallelDatumsTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateParallelDatumsTask with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateParallelDatumsTaskMultiError, or nil if none found.
func (m *CreateParallelDatumsTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateParallelDatumsTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateParallelDatumsTaskValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateParallelDatumsTaskValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateParallelDatumsTaskValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Salt

	// no validation rules for FileSetId

	// no validation rules for BaseFileSetId

	if all {
		switch v := interface{}(m.GetPathRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateParallelDatumsTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateParallelDatumsTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPathRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateParallelDatumsTaskValidationError{
				field:  "PathRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateParallelDatumsTaskMultiError(errors)
	}

	return nil
}

// CreateParallelDatumsTaskMultiError is an error wrapping multiple validation
// errors returned by CreateParallelDatumsTask.ValidateAll() if the designated
// constraints aren't met.
type CreateParallelDatumsTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateParallelDatumsTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateParallelDatumsTaskMultiError) AllErrors() []error { return m }

// CreateParallelDatumsTaskValidationError is the validation error returned by
// CreateParallelDatumsTask.Validate if the designated constraints aren't met.
type CreateParallelDatumsTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateParallelDatumsTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateParallelDatumsTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateParallelDatumsTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateParallelDatumsTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateParallelDatumsTaskValidationError) ErrorName() string {
	return "CreateParallelDatumsTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CreateParallelDatumsTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateParallelDatumsTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateParallelDatumsTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateParallelDatumsTaskValidationError{}

// Validate checks the field values on CreateParallelDatumsTaskResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateParallelDatumsTaskResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateParallelDatumsTaskResult with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateParallelDatumsTaskResultMultiError, or nil if none found.
func (m *CreateParallelDatumsTaskResult) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateParallelDatumsTaskResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateParallelDatumsTaskResultValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateParallelDatumsTaskResultValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateParallelDatumsTaskResultValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateParallelDatumsTaskResultMultiError(errors)
	}

	return nil
}

// CreateParallelDatumsTaskResultMultiError is an error wrapping multiple
// validation errors returned by CreateParallelDatumsTaskResult.ValidateAll()
// if the designated constraints aren't met.
type CreateParallelDatumsTaskResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateParallelDatumsTaskResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateParallelDatumsTaskResultMultiError) AllErrors() []error { return m }

// CreateParallelDatumsTaskResultValidationError is the validation error
// returned by CreateParallelDatumsTaskResult.Validate if the designated
// constraints aren't met.
type CreateParallelDatumsTaskResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateParallelDatumsTaskResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateParallelDatumsTaskResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateParallelDatumsTaskResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateParallelDatumsTaskResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateParallelDatumsTaskResultValidationError) ErrorName() string {
	return "CreateParallelDatumsTaskResultValidationError"
}

// Error satisfies the builtin error interface
func (e CreateParallelDatumsTaskResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateParallelDatumsTaskResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateParallelDatumsTaskResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateParallelDatumsTaskResultValidationError{}

// Validate checks the field values on CreateSerialDatumsTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSerialDatumsTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSerialDatumsTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSerialDatumsTaskMultiError, or nil if none found.
func (m *CreateSerialDatumsTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSerialDatumsTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSerialDatumsTaskValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Salt

	// no validation rules for FileSetId

	if all {
		switch v := interface{}(m.GetBaseMetaCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskValidationError{
					field:  "BaseMetaCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskValidationError{
					field:  "BaseMetaCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBaseMetaCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSerialDatumsTaskValidationError{
				field:  "BaseMetaCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NoSkip

	if all {
		switch v := interface{}(m.GetPathRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPathRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSerialDatumsTaskValidationError{
				field:  "PathRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSerialDatumsTaskMultiError(errors)
	}

	return nil
}

// CreateSerialDatumsTaskMultiError is an error wrapping multiple validation
// errors returned by CreateSerialDatumsTask.ValidateAll() if the designated
// constraints aren't met.
type CreateSerialDatumsTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSerialDatumsTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSerialDatumsTaskMultiError) AllErrors() []error { return m }

// CreateSerialDatumsTaskValidationError is the validation error returned by
// CreateSerialDatumsTask.Validate if the designated constraints aren't met.
type CreateSerialDatumsTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSerialDatumsTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSerialDatumsTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSerialDatumsTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSerialDatumsTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSerialDatumsTaskValidationError) ErrorName() string {
	return "CreateSerialDatumsTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSerialDatumsTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSerialDatumsTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSerialDatumsTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSerialDatumsTaskValidationError{}

// Validate checks the field values on CreateSerialDatumsTaskResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSerialDatumsTaskResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSerialDatumsTaskResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSerialDatumsTaskResultMultiError, or nil if none found.
func (m *CreateSerialDatumsTaskResult) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSerialDatumsTaskResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	// no validation rules for OutputDeleteFileSetId

	// no validation rules for MetaDeleteFileSetId

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskResultValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateSerialDatumsTaskResultValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateSerialDatumsTaskResultValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateSerialDatumsTaskResultMultiError(errors)
	}

	return nil
}

// CreateSerialDatumsTaskResultMultiError is an error wrapping multiple
// validation errors returned by CreateSerialDatumsTaskResult.ValidateAll() if
// the designated constraints aren't met.
type CreateSerialDatumsTaskResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSerialDatumsTaskResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSerialDatumsTaskResultMultiError) AllErrors() []error { return m }

// CreateSerialDatumsTaskResultValidationError is the validation error returned
// by CreateSerialDatumsTaskResult.Validate if the designated constraints
// aren't met.
type CreateSerialDatumsTaskResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSerialDatumsTaskResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSerialDatumsTaskResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSerialDatumsTaskResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSerialDatumsTaskResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSerialDatumsTaskResultValidationError) ErrorName() string {
	return "CreateSerialDatumsTaskResultValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSerialDatumsTaskResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSerialDatumsTaskResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSerialDatumsTaskResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSerialDatumsTaskResultValidationError{}

// Validate checks the field values on CreateDatumSetsTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDatumSetsTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDatumSetsTask with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDatumSetsTaskMultiError, or nil if none found.
func (m *CreateDatumSetsTask) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDatumSetsTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	if all {
		switch v := interface{}(m.GetPathRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDatumSetsTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDatumSetsTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPathRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDatumSetsTaskValidationError{
				field:  "PathRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateDatumSetsTaskValidationError{
					field:  "SetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateDatumSetsTaskValidationError{
					field:  "SetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateDatumSetsTaskValidationError{
				field:  "SetSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreateDatumSetsTaskMultiError(errors)
	}

	return nil
}

// CreateDatumSetsTaskMultiError is an error wrapping multiple validation
// errors returned by CreateDatumSetsTask.ValidateAll() if the designated
// constraints aren't met.
type CreateDatumSetsTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDatumSetsTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDatumSetsTaskMultiError) AllErrors() []error { return m }

// CreateDatumSetsTaskValidationError is the validation error returned by
// CreateDatumSetsTask.Validate if the designated constraints aren't met.
type CreateDatumSetsTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDatumSetsTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDatumSetsTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDatumSetsTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDatumSetsTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDatumSetsTaskValidationError) ErrorName() string {
	return "CreateDatumSetsTaskValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDatumSetsTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDatumSetsTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDatumSetsTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDatumSetsTaskValidationError{}

// Validate checks the field values on CreateDatumSetsTaskResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateDatumSetsTaskResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateDatumSetsTaskResult with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateDatumSetsTaskResultMultiError, or nil if none found.
func (m *CreateDatumSetsTaskResult) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateDatumSetsTaskResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDatumSets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateDatumSetsTaskResultValidationError{
						field:  fmt.Sprintf("DatumSets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateDatumSetsTaskResultValidationError{
						field:  fmt.Sprintf("DatumSets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateDatumSetsTaskResultValidationError{
					field:  fmt.Sprintf("DatumSets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateDatumSetsTaskResultMultiError(errors)
	}

	return nil
}

// CreateDatumSetsTaskResultMultiError is an error wrapping multiple validation
// errors returned by CreateDatumSetsTaskResult.ValidateAll() if the
// designated constraints aren't met.
type CreateDatumSetsTaskResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateDatumSetsTaskResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateDatumSetsTaskResultMultiError) AllErrors() []error { return m }

// CreateDatumSetsTaskResultValidationError is the validation error returned by
// CreateDatumSetsTaskResult.Validate if the designated constraints aren't met.
type CreateDatumSetsTaskResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateDatumSetsTaskResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateDatumSetsTaskResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateDatumSetsTaskResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateDatumSetsTaskResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateDatumSetsTaskResultValidationError) ErrorName() string {
	return "CreateDatumSetsTaskResultValidationError"
}

// Error satisfies the builtin error interface
func (e CreateDatumSetsTaskResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateDatumSetsTaskResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateDatumSetsTaskResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateDatumSetsTaskResultValidationError{}

// Validate checks the field values on DatumSetTask with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatumSetTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatumSetTask with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatumSetTaskMultiError, or
// nil if none found.
func (m *DatumSetTask) ValidateAll() error {
	return m.validate(true)
}

func (m *DatumSetTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumSetTaskValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumSetTaskValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumSetTaskValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileSetId

	if all {
		switch v := interface{}(m.GetPathRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumSetTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumSetTaskValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPathRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumSetTaskValidationError{
				field:  "PathRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutputCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumSetTaskValidationError{
					field:  "OutputCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumSetTaskValidationError{
					field:  "OutputCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumSetTaskValidationError{
				field:  "OutputCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DatumSetTaskMultiError(errors)
	}

	return nil
}

// DatumSetTaskMultiError is an error wrapping multiple validation errors
// returned by DatumSetTask.ValidateAll() if the designated constraints aren't met.
type DatumSetTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatumSetTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatumSetTaskMultiError) AllErrors() []error { return m }

// DatumSetTaskValidationError is the validation error returned by
// DatumSetTask.Validate if the designated constraints aren't met.
type DatumSetTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatumSetTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatumSetTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatumSetTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatumSetTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatumSetTaskValidationError) ErrorName() string { return "DatumSetTaskValidationError" }

// Error satisfies the builtin error interface
func (e DatumSetTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatumSetTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatumSetTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatumSetTaskValidationError{}

// Validate checks the field values on DatumSetTaskResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DatumSetTaskResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatumSetTaskResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DatumSetTaskResultMultiError, or nil if none found.
func (m *DatumSetTaskResult) ValidateAll() error {
	return m.validate(true)
}

func (m *DatumSetTaskResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutputFileSetId

	// no validation rules for MetaFileSetId

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumSetTaskResultValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumSetTaskResultValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumSetTaskResultValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DatumSetTaskResultMultiError(errors)
	}

	return nil
}

// DatumSetTaskResultMultiError is an error wrapping multiple validation errors
// returned by DatumSetTaskResult.ValidateAll() if the designated constraints
// aren't met.
type DatumSetTaskResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatumSetTaskResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatumSetTaskResultMultiError) AllErrors() []error { return m }

// DatumSetTaskResultValidationError is the validation error returned by
// DatumSetTaskResult.Validate if the designated constraints aren't met.
type DatumSetTaskResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatumSetTaskResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatumSetTaskResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatumSetTaskResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatumSetTaskResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatumSetTaskResultValidationError) ErrorName() string {
	return "DatumSetTaskResultValidationError"
}

// Error satisfies the builtin error interface
func (e DatumSetTaskResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatumSetTaskResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatumSetTaskResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatumSetTaskResultValidationError{}
