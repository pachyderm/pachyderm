// Code generated by protoc-gen-zap (etc/proto/protoc-gen-zap). DO NOT EDIT.
//
// source: cdr/cdr.proto

package cdr

import (
	fmt "fmt"
	protoextensions "github.com/pachyderm/pachyderm/v2/src/protoextensions"
	zapcore "go.uber.org/zap/zapcore"
)

func (x *Ref) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	if obj, ok := interface{}(x.GetHttp()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("http", obj)
	} else {
		enc.AddReflected("http", x.GetHttp())
	}
	if obj, ok := interface{}(x.GetContentHash()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("content_hash", obj)
	} else {
		enc.AddReflected("content_hash", x.GetContentHash())
	}
	if obj, ok := interface{}(x.GetSizeLimits()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("size_limits", obj)
	} else {
		enc.AddReflected("size_limits", x.GetSizeLimits())
	}
	if obj, ok := interface{}(x.GetCipher()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("cipher", obj)
	} else {
		enc.AddReflected("cipher", x.GetCipher())
	}
	if obj, ok := interface{}(x.GetCompress()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("compress", obj)
	} else {
		enc.AddReflected("compress", x.GetCompress())
	}
	if obj, ok := interface{}(x.GetSlice()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("slice", obj)
	} else {
		enc.AddReflected("slice", x.GetSlice())
	}
	if obj, ok := interface{}(x.GetConcat()).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("concat", obj)
	} else {
		enc.AddReflected("concat", x.GetConcat())
	}
	return nil
}

func (x *HTTP) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	enc.AddString("url", x.Url)
	enc.AddObject("headers", zapcore.ObjectMarshalerFunc(func(enc zapcore.ObjectEncoder) error {
		for k, v := range x.Headers {
			enc.AddString(fmt.Sprintf("%v", k), v)
		}
		return nil
	}))
	return nil
}

func (x *ContentHash) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	if obj, ok := interface{}(x.Inner).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("inner", obj)
	} else {
		enc.AddReflected("inner", x.Inner)
	}
	enc.AddString("algo", x.Algo.String())
	protoextensions.AddBytes(enc, "hash", x.Hash)
	return nil
}

func (x *SizeLimits) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	if obj, ok := interface{}(x.Inner).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("inner", obj)
	} else {
		enc.AddReflected("inner", x.Inner)
	}
	enc.AddInt64("min", x.Min)
	enc.AddInt64("max", x.Max)
	return nil
}

func (x *Cipher) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	if obj, ok := interface{}(x.Inner).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("inner", obj)
	} else {
		enc.AddReflected("inner", x.Inner)
	}
	enc.AddString("algo", x.Algo.String())
	protoextensions.AddBytes(enc, "key", x.Key)
	protoextensions.AddBytes(enc, "nonce", x.Nonce)
	return nil
}

func (x *Compress) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	if obj, ok := interface{}(x.Inner).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("inner", obj)
	} else {
		enc.AddReflected("inner", x.Inner)
	}
	enc.AddString("algo", x.Algo.String())
	return nil
}

func (x *Slice) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	if obj, ok := interface{}(x.Inner).(zapcore.ObjectMarshaler); ok {
		enc.AddObject("inner", obj)
	} else {
		enc.AddReflected("inner", x.Inner)
	}
	enc.AddUint64("start", x.Start)
	enc.AddUint64("end", x.End)
	return nil
}

func (x *Concat) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	if x == nil {
		return nil
	}
	refsArrMarshaller := func(enc zapcore.ArrayEncoder) error {
		for _, v := range x.Refs {
			if obj, ok := interface{}(v).(zapcore.ObjectMarshaler); ok {
				enc.AppendObject(obj)
			} else {
				enc.AppendReflected(v)
			}
		}
		return nil
	}
	enc.AddArray("refs", zapcore.ArrayMarshalerFunc(refsArrMarshaller))
	return nil
}
