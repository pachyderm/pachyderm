// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pps/pps.proto

package pps

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on SecretMount with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretMount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretMount with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretMountMultiError, or
// nil if none found.
func (m *SecretMount) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretMount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Key

	// no validation rules for MountPath

	// no validation rules for EnvVar

	if len(errors) > 0 {
		return SecretMountMultiError(errors)
	}

	return nil
}

// SecretMountMultiError is an error wrapping multiple validation errors
// returned by SecretMount.ValidateAll() if the designated constraints aren't met.
type SecretMountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretMountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretMountMultiError) AllErrors() []error { return m }

// SecretMountValidationError is the validation error returned by
// SecretMount.Validate if the designated constraints aren't met.
type SecretMountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretMountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretMountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretMountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretMountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretMountValidationError) ErrorName() string { return "SecretMountValidationError" }

// Error satisfies the builtin error interface
func (e SecretMountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretMount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretMountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretMountValidationError{}

// Validate checks the field values on Transform with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transform) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transform with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransformMultiError, or nil
// if none found.
func (m *Transform) ValidateAll() error {
	return m.validate(true)
}

func (m *Transform) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Image

	// no validation rules for Env

	for idx, item := range m.GetSecrets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransformValidationError{
						field:  fmt.Sprintf("Secrets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransformValidationError{
						field:  fmt.Sprintf("Secrets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransformValidationError{
					field:  fmt.Sprintf("Secrets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Debug

	// no validation rules for User

	// no validation rules for WorkingDir

	// no validation rules for Dockerfile

	// no validation rules for MemoryVolume

	// no validation rules for DatumBatching

	if len(errors) > 0 {
		return TransformMultiError(errors)
	}

	return nil
}

// TransformMultiError is an error wrapping multiple validation errors returned
// by Transform.ValidateAll() if the designated constraints aren't met.
type TransformMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransformMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransformMultiError) AllErrors() []error { return m }

// TransformValidationError is the validation error returned by
// Transform.Validate if the designated constraints aren't met.
type TransformValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransformValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransformValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransformValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransformValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransformValidationError) ErrorName() string { return "TransformValidationError" }

// Error satisfies the builtin error interface
func (e TransformValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransform.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransformValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransformValidationError{}

// Validate checks the field values on TFJob with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TFJob) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TFJob with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TFJobMultiError, or nil if none found.
func (m *TFJob) ValidateAll() error {
	return m.validate(true)
}

func (m *TFJob) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TfJob

	if len(errors) > 0 {
		return TFJobMultiError(errors)
	}

	return nil
}

// TFJobMultiError is an error wrapping multiple validation errors returned by
// TFJob.ValidateAll() if the designated constraints aren't met.
type TFJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TFJobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TFJobMultiError) AllErrors() []error { return m }

// TFJobValidationError is the validation error returned by TFJob.Validate if
// the designated constraints aren't met.
type TFJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TFJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TFJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TFJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TFJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TFJobValidationError) ErrorName() string { return "TFJobValidationError" }

// Error satisfies the builtin error interface
func (e TFJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTFJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TFJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TFJobValidationError{}

// Validate checks the field values on Egress with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Egress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Egress with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EgressMultiError, or nil if none found.
func (m *Egress) ValidateAll() error {
	return m.validate(true)
}

func (m *Egress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for URL

	switch v := m.Target.(type) {
	case *Egress_ObjectStorage:
		if v == nil {
			err := EgressValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Egress_SqlDatabase:
		if v == nil {
			err := EgressValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSqlDatabase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressValidationError{
						field:  "SqlDatabase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressValidationError{
						field:  "SqlDatabase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSqlDatabase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressValidationError{
					field:  "SqlDatabase",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EgressMultiError(errors)
	}

	return nil
}

// EgressMultiError is an error wrapping multiple validation errors returned by
// Egress.ValidateAll() if the designated constraints aren't met.
type EgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EgressMultiError) AllErrors() []error { return m }

// EgressValidationError is the validation error returned by Egress.Validate if
// the designated constraints aren't met.
type EgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EgressValidationError) ErrorName() string { return "EgressValidationError" }

// Error satisfies the builtin error interface
func (e EgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EgressValidationError{}

// Validate checks the field values on Determined with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Determined) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Determined with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeterminedMultiError, or
// nil if none found.
func (m *Determined) ValidateAll() error {
	return m.validate(true)
}

func (m *Determined) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeterminedMultiError(errors)
	}

	return nil
}

// DeterminedMultiError is an error wrapping multiple validation errors
// returned by Determined.ValidateAll() if the designated constraints aren't met.
type DeterminedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeterminedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeterminedMultiError) AllErrors() []error { return m }

// DeterminedValidationError is the validation error returned by
// Determined.Validate if the designated constraints aren't met.
type DeterminedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeterminedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeterminedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeterminedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeterminedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeterminedValidationError) ErrorName() string { return "DeterminedValidationError" }

// Error satisfies the builtin error interface
func (e DeterminedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDetermined.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeterminedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeterminedValidationError{}

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Job) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Job with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobMultiError, or nil if none found.
func (m *Job) ValidateAll() error {
	return m.validate(true)
}

func (m *Job) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return JobMultiError(errors)
	}

	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.ValidateAll() if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

// Validate checks the field values on Metadata with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Metadata with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in MetadataMultiError, or nil
// if none found.
func (m *Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Annotations

	// no validation rules for Labels

	if len(errors) > 0 {
		return MetadataMultiError(errors)
	}

	return nil
}

// MetadataMultiError is an error wrapping multiple validation errors returned
// by Metadata.ValidateAll() if the designated constraints aren't met.
type MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MetadataMultiError) AllErrors() []error { return m }

// MetadataValidationError is the validation error returned by
// Metadata.Validate if the designated constraints aren't met.
type MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MetadataValidationError) ErrorName() string { return "MetadataValidationError" }

// Error satisfies the builtin error interface
func (e MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MetadataValidationError{}

// Validate checks the field values on Service with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Service) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Service with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ServiceMultiError, or nil if none found.
func (m *Service) ValidateAll() error {
	return m.validate(true)
}

func (m *Service) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for InternalPort

	// no validation rules for ExternalPort

	// no validation rules for Ip

	// no validation rules for Type

	if len(errors) > 0 {
		return ServiceMultiError(errors)
	}

	return nil
}

// ServiceMultiError is an error wrapping multiple validation errors returned
// by Service.ValidateAll() if the designated constraints aren't met.
type ServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceMultiError) AllErrors() []error { return m }

// ServiceValidationError is the validation error returned by Service.Validate
// if the designated constraints aren't met.
type ServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceValidationError) ErrorName() string { return "ServiceValidationError" }

// Error satisfies the builtin error interface
func (e ServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceValidationError{}

// Validate checks the field values on Spout with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Spout) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Spout with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SpoutMultiError, or nil if none found.
func (m *Spout) ValidateAll() error {
	return m.validate(true)
}

func (m *Spout) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SpoutValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SpoutValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SpoutValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SpoutMultiError(errors)
	}

	return nil
}

// SpoutMultiError is an error wrapping multiple validation errors returned by
// Spout.ValidateAll() if the designated constraints aren't met.
type SpoutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SpoutMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SpoutMultiError) AllErrors() []error { return m }

// SpoutValidationError is the validation error returned by Spout.Validate if
// the designated constraints aren't met.
type SpoutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SpoutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SpoutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SpoutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SpoutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SpoutValidationError) ErrorName() string { return "SpoutValidationError" }

// Error satisfies the builtin error interface
func (e SpoutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSpout.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SpoutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SpoutValidationError{}

// Validate checks the field values on PFSInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PFSInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PFSInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PFSInputMultiError, or nil
// if none found.
func (m *PFSInput) ValidateAll() error {
	return m.validate(true)
}

func (m *PFSInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Project

	// no validation rules for Name

	// no validation rules for Repo

	// no validation rules for RepoType

	// no validation rules for Branch

	// no validation rules for Commit

	// no validation rules for Glob

	// no validation rules for JoinOn

	// no validation rules for OuterJoin

	// no validation rules for GroupBy

	// no validation rules for Lazy

	// no validation rules for EmptyFiles

	// no validation rules for S3

	if all {
		switch v := interface{}(m.GetTrigger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PFSInputValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PFSInputValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrigger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PFSInputValidationError{
				field:  "Trigger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PFSInputMultiError(errors)
	}

	return nil
}

// PFSInputMultiError is an error wrapping multiple validation errors returned
// by PFSInput.ValidateAll() if the designated constraints aren't met.
type PFSInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PFSInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PFSInputMultiError) AllErrors() []error { return m }

// PFSInputValidationError is the validation error returned by
// PFSInput.Validate if the designated constraints aren't met.
type PFSInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PFSInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PFSInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PFSInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PFSInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PFSInputValidationError) ErrorName() string { return "PFSInputValidationError" }

// Error satisfies the builtin error interface
func (e PFSInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPFSInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PFSInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PFSInputValidationError{}

// Validate checks the field values on CronInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CronInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CronInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CronInputMultiError, or nil
// if none found.
func (m *CronInput) ValidateAll() error {
	return m.validate(true)
}

func (m *CronInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Project

	// no validation rules for Repo

	// no validation rules for Commit

	// no validation rules for Spec

	// no validation rules for Overwrite

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CronInputValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CronInputValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CronInputValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CronInputMultiError(errors)
	}

	return nil
}

// CronInputMultiError is an error wrapping multiple validation errors returned
// by CronInput.ValidateAll() if the designated constraints aren't met.
type CronInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CronInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CronInputMultiError) AllErrors() []error { return m }

// CronInputValidationError is the validation error returned by
// CronInput.Validate if the designated constraints aren't met.
type CronInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CronInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CronInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CronInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CronInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CronInputValidationError) ErrorName() string { return "CronInputValidationError" }

// Error satisfies the builtin error interface
func (e CronInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCronInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CronInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CronInputValidationError{}

// Validate checks the field values on Input with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Input) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Input with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InputMultiError, or nil if none found.
func (m *Input) ValidateAll() error {
	return m.validate(true)
}

func (m *Input) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPfs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InputValidationError{
					field:  "Pfs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InputValidationError{
					field:  "Pfs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPfs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InputValidationError{
				field:  "Pfs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetJoin() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Join[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Join[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InputValidationError{
					field:  fmt.Sprintf("Join[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetGroup() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Group[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Group[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InputValidationError{
					field:  fmt.Sprintf("Group[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetCross() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Cross[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Cross[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InputValidationError{
					field:  fmt.Sprintf("Cross[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetUnion() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Union[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InputValidationError{
						field:  fmt.Sprintf("Union[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InputValidationError{
					field:  fmt.Sprintf("Union[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCron()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InputValidationError{
					field:  "Cron",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InputValidationError{
					field:  "Cron",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCron()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InputValidationError{
				field:  "Cron",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InputMultiError(errors)
	}

	return nil
}

// InputMultiError is an error wrapping multiple validation errors returned by
// Input.ValidateAll() if the designated constraints aren't met.
type InputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InputMultiError) AllErrors() []error { return m }

// InputValidationError is the validation error returned by Input.Validate if
// the designated constraints aren't met.
type InputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InputValidationError) ErrorName() string { return "InputValidationError" }

// Error satisfies the builtin error interface
func (e InputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InputValidationError{}

// Validate checks the field values on JobInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JobInputMultiError, or nil
// if none found.
func (m *JobInput) ValidateAll() error {
	return m.validate(true)
}

func (m *JobInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInputValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInputValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInputValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Glob

	// no validation rules for Lazy

	if len(errors) > 0 {
		return JobInputMultiError(errors)
	}

	return nil
}

// JobInputMultiError is an error wrapping multiple validation errors returned
// by JobInput.ValidateAll() if the designated constraints aren't met.
type JobInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobInputMultiError) AllErrors() []error { return m }

// JobInputValidationError is the validation error returned by
// JobInput.Validate if the designated constraints aren't met.
type JobInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobInputValidationError) ErrorName() string { return "JobInputValidationError" }

// Error satisfies the builtin error interface
func (e JobInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobInputValidationError{}

// Validate checks the field values on ParallelismSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ParallelismSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ParallelismSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ParallelismSpecMultiError, or nil if none found.
func (m *ParallelismSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ParallelismSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Constant

	if len(errors) > 0 {
		return ParallelismSpecMultiError(errors)
	}

	return nil
}

// ParallelismSpecMultiError is an error wrapping multiple validation errors
// returned by ParallelismSpec.ValidateAll() if the designated constraints
// aren't met.
type ParallelismSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ParallelismSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ParallelismSpecMultiError) AllErrors() []error { return m }

// ParallelismSpecValidationError is the validation error returned by
// ParallelismSpec.Validate if the designated constraints aren't met.
type ParallelismSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ParallelismSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ParallelismSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ParallelismSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ParallelismSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ParallelismSpecValidationError) ErrorName() string { return "ParallelismSpecValidationError" }

// Error satisfies the builtin error interface
func (e ParallelismSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sParallelismSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ParallelismSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ParallelismSpecValidationError{}

// Validate checks the field values on InputFile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InputFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InputFile with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in InputFileMultiError, or nil
// if none found.
func (m *InputFile) ValidateAll() error {
	return m.validate(true)
}

func (m *InputFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Hash

	if len(errors) > 0 {
		return InputFileMultiError(errors)
	}

	return nil
}

// InputFileMultiError is an error wrapping multiple validation errors returned
// by InputFile.ValidateAll() if the designated constraints aren't met.
type InputFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InputFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InputFileMultiError) AllErrors() []error { return m }

// InputFileValidationError is the validation error returned by
// InputFile.Validate if the designated constraints aren't met.
type InputFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InputFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InputFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InputFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InputFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InputFileValidationError) ErrorName() string { return "InputFileValidationError" }

// Error satisfies the builtin error interface
func (e InputFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInputFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InputFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InputFileValidationError{}

// Validate checks the field values on Datum with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Datum) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Datum with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in DatumMultiError, or nil if none found.
func (m *Datum) ValidateAll() error {
	return m.validate(true)
}

func (m *Datum) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return DatumMultiError(errors)
	}

	return nil
}

// DatumMultiError is an error wrapping multiple validation errors returned by
// Datum.ValidateAll() if the designated constraints aren't met.
type DatumMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatumMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatumMultiError) AllErrors() []error { return m }

// DatumValidationError is the validation error returned by Datum.Validate if
// the designated constraints aren't met.
type DatumValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatumValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatumValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatumValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatumValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatumValidationError) ErrorName() string { return "DatumValidationError" }

// Error satisfies the builtin error interface
func (e DatumValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatum.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatumValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatumValidationError{}

// Validate checks the field values on DatumInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatumInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatumInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatumInfoMultiError, or nil
// if none found.
func (m *DatumInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *DatumInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDatum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumInfoValidationError{
					field:  "Datum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumInfoValidationError{
					field:  "Datum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumInfoValidationError{
				field:  "Datum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumInfoValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumInfoValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumInfoValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPfsState()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumInfoValidationError{
					field:  "PfsState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumInfoValidationError{
					field:  "PfsState",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPfsState()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumInfoValidationError{
				field:  "PfsState",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatumInfoValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatumInfoValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatumInfoValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for ImageId

	if len(errors) > 0 {
		return DatumInfoMultiError(errors)
	}

	return nil
}

// DatumInfoMultiError is an error wrapping multiple validation errors returned
// by DatumInfo.ValidateAll() if the designated constraints aren't met.
type DatumInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatumInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatumInfoMultiError) AllErrors() []error { return m }

// DatumInfoValidationError is the validation error returned by
// DatumInfo.Validate if the designated constraints aren't met.
type DatumInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatumInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatumInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatumInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatumInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatumInfoValidationError) ErrorName() string { return "DatumInfoValidationError" }

// Error satisfies the builtin error interface
func (e DatumInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatumInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatumInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatumInfoValidationError{}

// Validate checks the field values on Aggregate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Aggregate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Aggregate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AggregateMultiError, or nil
// if none found.
func (m *Aggregate) ValidateAll() error {
	return m.validate(true)
}

func (m *Aggregate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	// no validation rules for Mean

	// no validation rules for Stddev

	// no validation rules for FifthPercentile

	// no validation rules for NinetyFifthPercentile

	if len(errors) > 0 {
		return AggregateMultiError(errors)
	}

	return nil
}

// AggregateMultiError is an error wrapping multiple validation errors returned
// by Aggregate.ValidateAll() if the designated constraints aren't met.
type AggregateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregateMultiError) AllErrors() []error { return m }

// AggregateValidationError is the validation error returned by
// Aggregate.Validate if the designated constraints aren't met.
type AggregateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregateValidationError) ErrorName() string { return "AggregateValidationError" }

// Error satisfies the builtin error interface
func (e AggregateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregateValidationError{}

// Validate checks the field values on ProcessStats with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProcessStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProcessStats with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProcessStatsMultiError, or
// nil if none found.
func (m *ProcessStats) ValidateAll() error {
	return m.validate(true)
}

func (m *ProcessStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDownloadTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessStatsValidationError{
					field:  "DownloadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessStatsValidationError{
					field:  "DownloadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownloadTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessStatsValidationError{
				field:  "DownloadTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProcessTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessStatsValidationError{
					field:  "ProcessTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessStatsValidationError{
					field:  "ProcessTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProcessTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessStatsValidationError{
				field:  "ProcessTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUploadTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProcessStatsValidationError{
					field:  "UploadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProcessStatsValidationError{
					field:  "UploadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUploadTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProcessStatsValidationError{
				field:  "UploadTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DownloadBytes

	// no validation rules for UploadBytes

	if len(errors) > 0 {
		return ProcessStatsMultiError(errors)
	}

	return nil
}

// ProcessStatsMultiError is an error wrapping multiple validation errors
// returned by ProcessStats.ValidateAll() if the designated constraints aren't met.
type ProcessStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProcessStatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProcessStatsMultiError) AllErrors() []error { return m }

// ProcessStatsValidationError is the validation error returned by
// ProcessStats.Validate if the designated constraints aren't met.
type ProcessStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProcessStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProcessStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProcessStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProcessStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProcessStatsValidationError) ErrorName() string { return "ProcessStatsValidationError" }

// Error satisfies the builtin error interface
func (e ProcessStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProcessStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProcessStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProcessStatsValidationError{}

// Validate checks the field values on AggregateProcessStats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AggregateProcessStats) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AggregateProcessStats with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AggregateProcessStatsMultiError, or nil if none found.
func (m *AggregateProcessStats) ValidateAll() error {
	return m.validate(true)
}

func (m *AggregateProcessStats) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDownloadTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "DownloadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "DownloadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownloadTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateProcessStatsValidationError{
				field:  "DownloadTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProcessTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "ProcessTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "ProcessTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProcessTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateProcessStatsValidationError{
				field:  "ProcessTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUploadTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "UploadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "UploadTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUploadTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateProcessStatsValidationError{
				field:  "UploadTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDownloadBytes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "DownloadBytes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "DownloadBytes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDownloadBytes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateProcessStatsValidationError{
				field:  "DownloadBytes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUploadBytes()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "UploadBytes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AggregateProcessStatsValidationError{
					field:  "UploadBytes",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUploadBytes()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AggregateProcessStatsValidationError{
				field:  "UploadBytes",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AggregateProcessStatsMultiError(errors)
	}

	return nil
}

// AggregateProcessStatsMultiError is an error wrapping multiple validation
// errors returned by AggregateProcessStats.ValidateAll() if the designated
// constraints aren't met.
type AggregateProcessStatsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AggregateProcessStatsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AggregateProcessStatsMultiError) AllErrors() []error { return m }

// AggregateProcessStatsValidationError is the validation error returned by
// AggregateProcessStats.Validate if the designated constraints aren't met.
type AggregateProcessStatsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AggregateProcessStatsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AggregateProcessStatsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AggregateProcessStatsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AggregateProcessStatsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AggregateProcessStatsValidationError) ErrorName() string {
	return "AggregateProcessStatsValidationError"
}

// Error satisfies the builtin error interface
func (e AggregateProcessStatsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAggregateProcessStats.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AggregateProcessStatsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AggregateProcessStatsValidationError{}

// Validate checks the field values on WorkerStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WorkerStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WorkerStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WorkerStatusMultiError, or
// nil if none found.
func (m *WorkerStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *WorkerStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WorkerId

	// no validation rules for JobId

	if all {
		switch v := interface{}(m.GetDatumStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WorkerStatusValidationError{
					field:  "DatumStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WorkerStatusValidationError{
					field:  "DatumStatus",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WorkerStatusValidationError{
				field:  "DatumStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WorkerStatusMultiError(errors)
	}

	return nil
}

// WorkerStatusMultiError is an error wrapping multiple validation errors
// returned by WorkerStatus.ValidateAll() if the designated constraints aren't met.
type WorkerStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkerStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkerStatusMultiError) AllErrors() []error { return m }

// WorkerStatusValidationError is the validation error returned by
// WorkerStatus.Validate if the designated constraints aren't met.
type WorkerStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkerStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkerStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkerStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkerStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkerStatusValidationError) ErrorName() string { return "WorkerStatusValidationError" }

// Error satisfies the builtin error interface
func (e WorkerStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorkerStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkerStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkerStatusValidationError{}

// Validate checks the field values on DatumStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatumStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatumStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatumStatusMultiError, or
// nil if none found.
func (m *DatumStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *DatumStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetStarted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DatumStatusValidationError{
					field:  "Started",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DatumStatusValidationError{
					field:  "Started",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStarted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DatumStatusValidationError{
				field:  "Started",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DatumStatusValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DatumStatusValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DatumStatusValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DatumStatusMultiError(errors)
	}

	return nil
}

// DatumStatusMultiError is an error wrapping multiple validation errors
// returned by DatumStatus.ValidateAll() if the designated constraints aren't met.
type DatumStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatumStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatumStatusMultiError) AllErrors() []error { return m }

// DatumStatusValidationError is the validation error returned by
// DatumStatus.Validate if the designated constraints aren't met.
type DatumStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatumStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatumStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatumStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatumStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatumStatusValidationError) ErrorName() string { return "DatumStatusValidationError" }

// Error satisfies the builtin error interface
func (e DatumStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatumStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatumStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatumStatusValidationError{}

// Validate checks the field values on ResourceSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResourceSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResourceSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResourceSpecMultiError, or
// nil if none found.
func (m *ResourceSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ResourceSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cpu

	// no validation rules for Memory

	if all {
		switch v := interface{}(m.GetGpu()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ResourceSpecValidationError{
					field:  "Gpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ResourceSpecValidationError{
					field:  "Gpu",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetGpu()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ResourceSpecValidationError{
				field:  "Gpu",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Disk

	if len(errors) > 0 {
		return ResourceSpecMultiError(errors)
	}

	return nil
}

// ResourceSpecMultiError is an error wrapping multiple validation errors
// returned by ResourceSpec.ValidateAll() if the designated constraints aren't met.
type ResourceSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResourceSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResourceSpecMultiError) AllErrors() []error { return m }

// ResourceSpecValidationError is the validation error returned by
// ResourceSpec.Validate if the designated constraints aren't met.
type ResourceSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResourceSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResourceSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResourceSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResourceSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResourceSpecValidationError) ErrorName() string { return "ResourceSpecValidationError" }

// Error satisfies the builtin error interface
func (e ResourceSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResourceSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResourceSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResourceSpecValidationError{}

// Validate checks the field values on GPUSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GPUSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GPUSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in GPUSpecMultiError, or nil if none found.
func (m *GPUSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *GPUSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Number

	if len(errors) > 0 {
		return GPUSpecMultiError(errors)
	}

	return nil
}

// GPUSpecMultiError is an error wrapping multiple validation errors returned
// by GPUSpec.ValidateAll() if the designated constraints aren't met.
type GPUSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GPUSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GPUSpecMultiError) AllErrors() []error { return m }

// GPUSpecValidationError is the validation error returned by GPUSpec.Validate
// if the designated constraints aren't met.
type GPUSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GPUSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GPUSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GPUSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GPUSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GPUSpecValidationError) ErrorName() string { return "GPUSpecValidationError" }

// Error satisfies the builtin error interface
func (e GPUSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGPUSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GPUSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GPUSpecValidationError{}

// Validate checks the field values on JobSetInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobSetInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobSetInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in JobSetInfoMultiError, or
// nil if none found.
func (m *JobSetInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *JobSetInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJobSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobSetInfoValidationError{
					field:  "JobSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobSetInfoValidationError{
					field:  "JobSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJobSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobSetInfoValidationError{
				field:  "JobSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetJobs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JobSetInfoValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JobSetInfoValidationError{
						field:  fmt.Sprintf("Jobs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JobSetInfoValidationError{
					field:  fmt.Sprintf("Jobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return JobSetInfoMultiError(errors)
	}

	return nil
}

// JobSetInfoMultiError is an error wrapping multiple validation errors
// returned by JobSetInfo.ValidateAll() if the designated constraints aren't met.
type JobSetInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobSetInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobSetInfoMultiError) AllErrors() []error { return m }

// JobSetInfoValidationError is the validation error returned by
// JobSetInfo.Validate if the designated constraints aren't met.
type JobSetInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobSetInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobSetInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobSetInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobSetInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobSetInfoValidationError) ErrorName() string { return "JobSetInfoValidationError" }

// Error satisfies the builtin error interface
func (e JobSetInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobSetInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobSetInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobSetInfoValidationError{}

// Validate checks the field values on JobInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobInfoMultiError, or nil if none found.
func (m *JobInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *JobInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PipelineVersion

	if all {
		switch v := interface{}(m.GetOutputCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "OutputCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "OutputCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "OutputCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Restart

	// no validation rules for DataProcessed

	// no validation rules for DataSkipped

	// no validation rules for DataTotal

	// no validation rules for DataFailed

	// no validation rules for DataRecovered

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStarted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Started",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Started",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStarted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Started",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinished()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Finished",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Finished",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinished()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Finished",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfoValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AuthToken

	if len(errors) > 0 {
		return JobInfoMultiError(errors)
	}

	return nil
}

// JobInfoMultiError is an error wrapping multiple validation errors returned
// by JobInfo.ValidateAll() if the designated constraints aren't met.
type JobInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobInfoMultiError) AllErrors() []error { return m }

// JobInfoValidationError is the validation error returned by JobInfo.Validate
// if the designated constraints aren't met.
type JobInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobInfoValidationError) ErrorName() string { return "JobInfoValidationError" }

// Error satisfies the builtin error interface
func (e JobInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobInfoValidationError{}

// Validate checks the field values on Worker with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Worker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Worker with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WorkerMultiError, or nil if none found.
func (m *Worker) ValidateAll() error {
	return m.validate(true)
}

func (m *Worker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for State

	if len(errors) > 0 {
		return WorkerMultiError(errors)
	}

	return nil
}

// WorkerMultiError is an error wrapping multiple validation errors returned by
// Worker.ValidateAll() if the designated constraints aren't met.
type WorkerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WorkerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WorkerMultiError) AllErrors() []error { return m }

// WorkerValidationError is the validation error returned by Worker.Validate if
// the designated constraints aren't met.
type WorkerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WorkerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WorkerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WorkerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WorkerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WorkerValidationError) ErrorName() string { return "WorkerValidationError" }

// Error satisfies the builtin error interface
func (e WorkerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWorker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WorkerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WorkerValidationError{}

// Validate checks the field values on Pipeline with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Pipeline) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Pipeline with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineMultiError, or nil
// if none found.
func (m *Pipeline) ValidateAll() error {
	return m.validate(true)
}

func (m *Pipeline) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(m.GetName()) < 1 {
		err := PipelineValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PipelineMultiError(errors)
	}

	return nil
}

// PipelineMultiError is an error wrapping multiple validation errors returned
// by Pipeline.ValidateAll() if the designated constraints aren't met.
type PipelineMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineMultiError) AllErrors() []error { return m }

// PipelineValidationError is the validation error returned by
// Pipeline.Validate if the designated constraints aren't met.
type PipelineValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineValidationError) ErrorName() string { return "PipelineValidationError" }

// Error satisfies the builtin error interface
func (e PipelineValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipeline.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineValidationError{}

// Validate checks the field values on Toleration with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Toleration) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Toleration with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TolerationMultiError, or
// nil if none found.
func (m *Toleration) ValidateAll() error {
	return m.validate(true)
}

func (m *Toleration) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	// no validation rules for Operator

	// no validation rules for Value

	// no validation rules for Effect

	if all {
		switch v := interface{}(m.GetTolerationSeconds()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TolerationValidationError{
					field:  "TolerationSeconds",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TolerationValidationError{
					field:  "TolerationSeconds",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTolerationSeconds()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TolerationValidationError{
				field:  "TolerationSeconds",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TolerationMultiError(errors)
	}

	return nil
}

// TolerationMultiError is an error wrapping multiple validation errors
// returned by Toleration.ValidateAll() if the designated constraints aren't met.
type TolerationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TolerationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TolerationMultiError) AllErrors() []error { return m }

// TolerationValidationError is the validation error returned by
// Toleration.Validate if the designated constraints aren't met.
type TolerationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TolerationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TolerationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TolerationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TolerationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TolerationValidationError) ErrorName() string { return "TolerationValidationError" }

// Error satisfies the builtin error interface
func (e TolerationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sToleration.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TolerationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TolerationValidationError{}

// Validate checks the field values on PipelineInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineInfoMultiError, or
// nil if none found.
func (m *PipelineInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfoValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfoValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfoValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetSpecCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfoValidationError{
					field:  "SpecCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfoValidationError{
					field:  "SpecCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpecCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfoValidationError{
				field:  "SpecCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Stopped

	// no validation rules for State

	// no validation rules for Reason

	// no validation rules for LastJobState

	// no validation rules for Parallelism

	// no validation rules for Type

	// no validation rules for AuthToken

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfoValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserSpecJson

	// no validation rules for EffectiveSpecJson

	if len(errors) > 0 {
		return PipelineInfoMultiError(errors)
	}

	return nil
}

// PipelineInfoMultiError is an error wrapping multiple validation errors
// returned by PipelineInfo.ValidateAll() if the designated constraints aren't met.
type PipelineInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineInfoMultiError) AllErrors() []error { return m }

// PipelineInfoValidationError is the validation error returned by
// PipelineInfo.Validate if the designated constraints aren't met.
type PipelineInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineInfoValidationError) ErrorName() string { return "PipelineInfoValidationError" }

// Error satisfies the builtin error interface
func (e PipelineInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineInfoValidationError{}

// Validate checks the field values on PipelineInfos with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PipelineInfos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineInfos with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PipelineInfosMultiError, or
// nil if none found.
func (m *PipelineInfos) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineInfos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPipelineInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineInfosValidationError{
						field:  fmt.Sprintf("PipelineInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineInfosValidationError{
						field:  fmt.Sprintf("PipelineInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineInfosValidationError{
					field:  fmt.Sprintf("PipelineInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PipelineInfosMultiError(errors)
	}

	return nil
}

// PipelineInfosMultiError is an error wrapping multiple validation errors
// returned by PipelineInfos.ValidateAll() if the designated constraints
// aren't met.
type PipelineInfosMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineInfosMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineInfosMultiError) AllErrors() []error { return m }

// PipelineInfosValidationError is the validation error returned by
// PipelineInfos.Validate if the designated constraints aren't met.
type PipelineInfosValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineInfosValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineInfosValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineInfosValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineInfosValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineInfosValidationError) ErrorName() string { return "PipelineInfosValidationError" }

// Error satisfies the builtin error interface
func (e PipelineInfosValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineInfos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineInfosValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineInfosValidationError{}

// Validate checks the field values on JobSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *JobSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobSet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in JobSetMultiError, or nil if none found.
func (m *JobSet) ValidateAll() error {
	return m.validate(true)
}

func (m *JobSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return JobSetMultiError(errors)
	}

	return nil
}

// JobSetMultiError is an error wrapping multiple validation errors returned by
// JobSet.ValidateAll() if the designated constraints aren't met.
type JobSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobSetMultiError) AllErrors() []error { return m }

// JobSetValidationError is the validation error returned by JobSet.Validate if
// the designated constraints aren't met.
type JobSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobSetValidationError) ErrorName() string { return "JobSetValidationError" }

// Error satisfies the builtin error interface
func (e JobSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobSetValidationError{}

// Validate checks the field values on InspectJobSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectJobSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectJobSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectJobSetRequestMultiError, or nil if none found.
func (m *InspectJobSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectJobSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetJobSet() == nil {
		err := InspectJobSetRequestValidationError{
			field:  "JobSet",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetJobSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectJobSetRequestValidationError{
					field:  "JobSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectJobSetRequestValidationError{
					field:  "JobSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJobSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectJobSetRequestValidationError{
				field:  "JobSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Wait

	// no validation rules for Details

	if len(errors) > 0 {
		return InspectJobSetRequestMultiError(errors)
	}

	return nil
}

// InspectJobSetRequestMultiError is an error wrapping multiple validation
// errors returned by InspectJobSetRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectJobSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectJobSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectJobSetRequestMultiError) AllErrors() []error { return m }

// InspectJobSetRequestValidationError is the validation error returned by
// InspectJobSetRequest.Validate if the designated constraints aren't met.
type InspectJobSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectJobSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectJobSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectJobSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectJobSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectJobSetRequestValidationError) ErrorName() string {
	return "InspectJobSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectJobSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectJobSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectJobSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectJobSetRequestValidationError{}

// Validate checks the field values on ListJobSetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListJobSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListJobSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListJobSetRequestMultiError, or nil if none found.
func (m *ListJobSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListJobSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Details

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListJobSetRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListJobSetRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListJobSetRequestValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPaginationMarker()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListJobSetRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListJobSetRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaginationMarker()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListJobSetRequestValidationError{
				field:  "PaginationMarker",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Number

	// no validation rules for Reverse

	// no validation rules for JqFilter

	if len(errors) > 0 {
		return ListJobSetRequestMultiError(errors)
	}

	return nil
}

// ListJobSetRequestMultiError is an error wrapping multiple validation errors
// returned by ListJobSetRequest.ValidateAll() if the designated constraints
// aren't met.
type ListJobSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListJobSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListJobSetRequestMultiError) AllErrors() []error { return m }

// ListJobSetRequestValidationError is the validation error returned by
// ListJobSetRequest.Validate if the designated constraints aren't met.
type ListJobSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListJobSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListJobSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListJobSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListJobSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListJobSetRequestValidationError) ErrorName() string {
	return "ListJobSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListJobSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListJobSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListJobSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListJobSetRequestValidationError{}

// Validate checks the field values on InspectJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *InspectJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectJobRequestMultiError, or nil if none found.
func (m *InspectJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Wait

	// no validation rules for Details

	if len(errors) > 0 {
		return InspectJobRequestMultiError(errors)
	}

	return nil
}

// InspectJobRequestMultiError is an error wrapping multiple validation errors
// returned by InspectJobRequest.ValidateAll() if the designated constraints
// aren't met.
type InspectJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectJobRequestMultiError) AllErrors() []error { return m }

// InspectJobRequestValidationError is the validation error returned by
// InspectJobRequest.Validate if the designated constraints aren't met.
type InspectJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectJobRequestValidationError) ErrorName() string {
	return "InspectJobRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectJobRequestValidationError{}

// Validate checks the field values on ListJobRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListJobRequestMultiError,
// or nil if none found.
func (m *ListJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListJobRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListJobRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListJobRequestValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListJobRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListJobRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListJobRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetInputCommit() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListJobRequestValidationError{
						field:  fmt.Sprintf("InputCommit[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListJobRequestValidationError{
						field:  fmt.Sprintf("InputCommit[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListJobRequestValidationError{
					field:  fmt.Sprintf("InputCommit[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for History

	// no validation rules for Details

	// no validation rules for JqFilter

	if all {
		switch v := interface{}(m.GetPaginationMarker()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListJobRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListJobRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaginationMarker()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListJobRequestValidationError{
				field:  "PaginationMarker",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Number

	// no validation rules for Reverse

	if len(errors) > 0 {
		return ListJobRequestMultiError(errors)
	}

	return nil
}

// ListJobRequestMultiError is an error wrapping multiple validation errors
// returned by ListJobRequest.ValidateAll() if the designated constraints
// aren't met.
type ListJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListJobRequestMultiError) AllErrors() []error { return m }

// ListJobRequestValidationError is the validation error returned by
// ListJobRequest.Validate if the designated constraints aren't met.
type ListJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListJobRequestValidationError) ErrorName() string { return "ListJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListJobRequestValidationError{}

// Validate checks the field values on SubscribeJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeJobRequestMultiError, or nil if none found.
func (m *SubscribeJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscribeJobRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscribeJobRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscribeJobRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Details

	if len(errors) > 0 {
		return SubscribeJobRequestMultiError(errors)
	}

	return nil
}

// SubscribeJobRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeJobRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeJobRequestMultiError) AllErrors() []error { return m }

// SubscribeJobRequestValidationError is the validation error returned by
// SubscribeJobRequest.Validate if the designated constraints aren't met.
type SubscribeJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeJobRequestValidationError) ErrorName() string {
	return "SubscribeJobRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeJobRequestValidationError{}

// Validate checks the field values on DeleteJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteJobRequestMultiError, or nil if none found.
func (m *DeleteJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteJobRequestMultiError(errors)
	}

	return nil
}

// DeleteJobRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteJobRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteJobRequestMultiError) AllErrors() []error { return m }

// DeleteJobRequestValidationError is the validation error returned by
// DeleteJobRequest.Validate if the designated constraints aren't met.
type DeleteJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteJobRequestValidationError) ErrorName() string { return "DeleteJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteJobRequestValidationError{}

// Validate checks the field values on StopJobRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StopJobRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StopJobRequestMultiError,
// or nil if none found.
func (m *StopJobRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopJobRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StopJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StopJobRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StopJobRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reason

	if len(errors) > 0 {
		return StopJobRequestMultiError(errors)
	}

	return nil
}

// StopJobRequestMultiError is an error wrapping multiple validation errors
// returned by StopJobRequest.ValidateAll() if the designated constraints
// aren't met.
type StopJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopJobRequestMultiError) AllErrors() []error { return m }

// StopJobRequestValidationError is the validation error returned by
// StopJobRequest.Validate if the designated constraints aren't met.
type StopJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopJobRequestValidationError) ErrorName() string { return "StopJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e StopJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopJobRequestValidationError{}

// Validate checks the field values on UpdateJobStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateJobStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateJobStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateJobStateRequestMultiError, or nil if none found.
func (m *UpdateJobStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateJobStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetJob() == nil {
		err := UpdateJobStateRequestValidationError{
			field:  "Job",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateJobStateRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateJobStateRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateJobStateRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for Reason

	// no validation rules for Restart

	// no validation rules for DataProcessed

	// no validation rules for DataSkipped

	// no validation rules for DataFailed

	// no validation rules for DataRecovered

	// no validation rules for DataTotal

	if all {
		switch v := interface{}(m.GetStats()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateJobStateRequestValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateJobStateRequestValidationError{
					field:  "Stats",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStats()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateJobStateRequestValidationError{
				field:  "Stats",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateJobStateRequestMultiError(errors)
	}

	return nil
}

// UpdateJobStateRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateJobStateRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdateJobStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateJobStateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateJobStateRequestMultiError) AllErrors() []error { return m }

// UpdateJobStateRequestValidationError is the validation error returned by
// UpdateJobStateRequest.Validate if the designated constraints aren't met.
type UpdateJobStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateJobStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateJobStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateJobStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateJobStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateJobStateRequestValidationError) ErrorName() string {
	return "UpdateJobStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateJobStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateJobStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateJobStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateJobStateRequestValidationError{}

// Validate checks the field values on GetLogsRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetLogsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetLogsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetLogsRequestMultiError,
// or nil if none found.
func (m *GetLogsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetLogsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLogsRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLogsRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Datum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Datum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLogsRequestValidationError{
				field:  "Datum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Master

	// no validation rules for Follow

	// no validation rules for Tail

	// no validation rules for UseLokiBackend

	if all {
		switch v := interface{}(m.GetSince()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Since",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetLogsRequestValidationError{
					field:  "Since",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSince()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetLogsRequestValidationError{
				field:  "Since",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetLogsRequestMultiError(errors)
	}

	return nil
}

// GetLogsRequestMultiError is an error wrapping multiple validation errors
// returned by GetLogsRequest.ValidateAll() if the designated constraints
// aren't met.
type GetLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLogsRequestMultiError) AllErrors() []error { return m }

// GetLogsRequestValidationError is the validation error returned by
// GetLogsRequest.Validate if the designated constraints aren't met.
type GetLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLogsRequestValidationError) ErrorName() string { return "GetLogsRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLogsRequestValidationError{}

// Validate checks the field values on LogMessage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LogMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LogMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LogMessageMultiError, or
// nil if none found.
func (m *LogMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *LogMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectName

	// no validation rules for PipelineName

	// no validation rules for JobId

	// no validation rules for WorkerId

	// no validation rules for DatumId

	// no validation rules for Master

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LogMessageValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LogMessageValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LogMessageValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for User

	if all {
		switch v := interface{}(m.GetTs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LogMessageValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LogMessageValidationError{
					field:  "Ts",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LogMessageValidationError{
				field:  "Ts",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if len(errors) > 0 {
		return LogMessageMultiError(errors)
	}

	return nil
}

// LogMessageMultiError is an error wrapping multiple validation errors
// returned by LogMessage.ValidateAll() if the designated constraints aren't met.
type LogMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LogMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LogMessageMultiError) AllErrors() []error { return m }

// LogMessageValidationError is the validation error returned by
// LogMessage.Validate if the designated constraints aren't met.
type LogMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LogMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LogMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LogMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LogMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LogMessageValidationError) ErrorName() string { return "LogMessageValidationError" }

// Error satisfies the builtin error interface
func (e LogMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLogMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LogMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LogMessageValidationError{}

// Validate checks the field values on RestartDatumRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RestartDatumRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RestartDatumRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RestartDatumRequestMultiError, or nil if none found.
func (m *RestartDatumRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RestartDatumRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RestartDatumRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RestartDatumRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RestartDatumRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RestartDatumRequestMultiError(errors)
	}

	return nil
}

// RestartDatumRequestMultiError is an error wrapping multiple validation
// errors returned by RestartDatumRequest.ValidateAll() if the designated
// constraints aren't met.
type RestartDatumRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RestartDatumRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RestartDatumRequestMultiError) AllErrors() []error { return m }

// RestartDatumRequestValidationError is the validation error returned by
// RestartDatumRequest.Validate if the designated constraints aren't met.
type RestartDatumRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RestartDatumRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RestartDatumRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RestartDatumRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RestartDatumRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RestartDatumRequestValidationError) ErrorName() string {
	return "RestartDatumRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RestartDatumRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRestartDatumRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RestartDatumRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RestartDatumRequestValidationError{}

// Validate checks the field values on InspectDatumRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectDatumRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectDatumRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectDatumRequestMultiError, or nil if none found.
func (m *InspectDatumRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectDatumRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDatum()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectDatumRequestValidationError{
					field:  "Datum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectDatumRequestValidationError{
					field:  "Datum",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatum()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectDatumRequestValidationError{
				field:  "Datum",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectDatumRequestMultiError(errors)
	}

	return nil
}

// InspectDatumRequestMultiError is an error wrapping multiple validation
// errors returned by InspectDatumRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectDatumRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectDatumRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectDatumRequestMultiError) AllErrors() []error { return m }

// InspectDatumRequestValidationError is the validation error returned by
// InspectDatumRequest.Validate if the designated constraints aren't met.
type InspectDatumRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectDatumRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectDatumRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectDatumRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectDatumRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectDatumRequestValidationError) ErrorName() string {
	return "InspectDatumRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectDatumRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectDatumRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectDatumRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectDatumRequestValidationError{}

// Validate checks the field values on ListDatumRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListDatumRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDatumRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDatumRequestMultiError, or nil if none found.
func (m *ListDatumRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDatumRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDatumRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDatumRequestValidationError{
					field:  "Job",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDatumRequestValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDatumRequestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDatumRequestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDatumRequestValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFilter()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListDatumRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListDatumRequestValidationError{
					field:  "Filter",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFilter()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListDatumRequestValidationError{
				field:  "Filter",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PaginationMarker

	// no validation rules for Number

	// no validation rules for Reverse

	if len(errors) > 0 {
		return ListDatumRequestMultiError(errors)
	}

	return nil
}

// ListDatumRequestMultiError is an error wrapping multiple validation errors
// returned by ListDatumRequest.ValidateAll() if the designated constraints
// aren't met.
type ListDatumRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDatumRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDatumRequestMultiError) AllErrors() []error { return m }

// ListDatumRequestValidationError is the validation error returned by
// ListDatumRequest.Validate if the designated constraints aren't met.
type ListDatumRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDatumRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDatumRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDatumRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDatumRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDatumRequestValidationError) ErrorName() string { return "ListDatumRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListDatumRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDatumRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDatumRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDatumRequestValidationError{}

// Validate checks the field values on DatumSetSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DatumSetSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DatumSetSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DatumSetSpecMultiError, or
// nil if none found.
func (m *DatumSetSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *DatumSetSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	// no validation rules for SizeBytes

	// no validation rules for PerWorker

	if len(errors) > 0 {
		return DatumSetSpecMultiError(errors)
	}

	return nil
}

// DatumSetSpecMultiError is an error wrapping multiple validation errors
// returned by DatumSetSpec.ValidateAll() if the designated constraints aren't met.
type DatumSetSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DatumSetSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DatumSetSpecMultiError) AllErrors() []error { return m }

// DatumSetSpecValidationError is the validation error returned by
// DatumSetSpec.Validate if the designated constraints aren't met.
type DatumSetSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DatumSetSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DatumSetSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DatumSetSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DatumSetSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DatumSetSpecValidationError) ErrorName() string { return "DatumSetSpecValidationError" }

// Error satisfies the builtin error interface
func (e DatumSetSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDatumSetSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DatumSetSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DatumSetSpecValidationError{}

// Validate checks the field values on SchedulingSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SchedulingSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SchedulingSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SchedulingSpecMultiError,
// or nil if none found.
func (m *SchedulingSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *SchedulingSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NodeSelector

	// no validation rules for PriorityClassName

	if len(errors) > 0 {
		return SchedulingSpecMultiError(errors)
	}

	return nil
}

// SchedulingSpecMultiError is an error wrapping multiple validation errors
// returned by SchedulingSpec.ValidateAll() if the designated constraints
// aren't met.
type SchedulingSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SchedulingSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SchedulingSpecMultiError) AllErrors() []error { return m }

// SchedulingSpecValidationError is the validation error returned by
// SchedulingSpec.Validate if the designated constraints aren't met.
type SchedulingSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SchedulingSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SchedulingSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SchedulingSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SchedulingSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SchedulingSpecValidationError) ErrorName() string { return "SchedulingSpecValidationError" }

// Error satisfies the builtin error interface
func (e SchedulingSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSchedulingSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SchedulingSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SchedulingSpecValidationError{}

// Validate checks the field values on RerunPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RerunPipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RerunPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RerunPipelineRequestMultiError, or nil if none found.
func (m *RerunPipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RerunPipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPipeline() == nil {
		err := RerunPipelineRequestValidationError{
			field:  "Pipeline",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RerunPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RerunPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RerunPipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reprocess

	if len(errors) > 0 {
		return RerunPipelineRequestMultiError(errors)
	}

	return nil
}

// RerunPipelineRequestMultiError is an error wrapping multiple validation
// errors returned by RerunPipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type RerunPipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RerunPipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RerunPipelineRequestMultiError) AllErrors() []error { return m }

// RerunPipelineRequestValidationError is the validation error returned by
// RerunPipelineRequest.Validate if the designated constraints aren't met.
type RerunPipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RerunPipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RerunPipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RerunPipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RerunPipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RerunPipelineRequestValidationError) ErrorName() string {
	return "RerunPipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RerunPipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRerunPipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RerunPipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RerunPipelineRequestValidationError{}

// Validate checks the field values on CreatePipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePipelineRequestMultiError, or nil if none found.
func (m *CreatePipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTfJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "TfJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "TfJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTfJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "TfJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransform()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Transform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Transform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransform()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Transform",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParallelismSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "ParallelismSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "ParallelismSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParallelismSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "ParallelismSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Egress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Egress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Egress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Update

	// no validation rules for OutputBranch

	// no validation rules for S3Out

	if all {
		switch v := interface{}(m.GetResourceRequests()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "ResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "ResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceRequests()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "ResourceRequests",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResourceLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "ResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "ResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "ResourceLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSidecarResourceLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SidecarResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SidecarResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSidecarResourceLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "SidecarResourceLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Reprocess

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Spout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Spout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Spout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatumSetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "DatumSetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "DatumSetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumSetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "DatumSetSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatumTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "DatumTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "DatumTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "DatumTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJobTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "JobTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "JobTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJobTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "JobTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Salt

	// no validation rules for DatumTries

	if all {
		switch v := interface{}(m.GetSchedulingSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SchedulingSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SchedulingSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchedulingSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "SchedulingSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PodSpec

	// no validation rules for PodPatch

	if all {
		switch v := interface{}(m.GetSpecCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SpecCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SpecCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpecCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "SpecCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReprocessSpec

	// no validation rules for Autoscaling

	for idx, item := range m.GetTolerations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreatePipelineRequestValidationError{
						field:  fmt.Sprintf("Tolerations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreatePipelineRequestValidationError{
						field:  fmt.Sprintf("Tolerations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreatePipelineRequestValidationError{
					field:  fmt.Sprintf("Tolerations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSidecarResourceRequests()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SidecarResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "SidecarResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSidecarResourceRequests()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "SidecarResourceRequests",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DryRun

	if all {
		switch v := interface{}(m.GetDetermined()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Determined",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineRequestValidationError{
					field:  "Determined",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetermined()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineRequestValidationError{
				field:  "Determined",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CreatePipelineRequestMultiError(errors)
	}

	return nil
}

// CreatePipelineRequestMultiError is an error wrapping multiple validation
// errors returned by CreatePipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type CreatePipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePipelineRequestMultiError) AllErrors() []error { return m }

// CreatePipelineRequestValidationError is the validation error returned by
// CreatePipelineRequest.Validate if the designated constraints aren't met.
type CreatePipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePipelineRequestValidationError) ErrorName() string {
	return "CreatePipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePipelineRequestValidationError{}

// Validate checks the field values on CreatePipelineV2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePipelineV2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePipelineV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePipelineV2RequestMultiError, or nil if none found.
func (m *CreatePipelineV2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePipelineV2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CreatePipelineRequestJson

	// no validation rules for DryRun

	// no validation rules for Update

	// no validation rules for Reprocess

	if len(errors) > 0 {
		return CreatePipelineV2RequestMultiError(errors)
	}

	return nil
}

// CreatePipelineV2RequestMultiError is an error wrapping multiple validation
// errors returned by CreatePipelineV2Request.ValidateAll() if the designated
// constraints aren't met.
type CreatePipelineV2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePipelineV2RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePipelineV2RequestMultiError) AllErrors() []error { return m }

// CreatePipelineV2RequestValidationError is the validation error returned by
// CreatePipelineV2Request.Validate if the designated constraints aren't met.
type CreatePipelineV2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePipelineV2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePipelineV2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePipelineV2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePipelineV2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePipelineV2RequestValidationError) ErrorName() string {
	return "CreatePipelineV2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePipelineV2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePipelineV2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePipelineV2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePipelineV2RequestValidationError{}

// Validate checks the field values on CreatePipelineV2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePipelineV2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePipelineV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePipelineV2ResponseMultiError, or nil if none found.
func (m *CreatePipelineV2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePipelineV2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EffectiveCreatePipelineRequestJson

	if len(errors) > 0 {
		return CreatePipelineV2ResponseMultiError(errors)
	}

	return nil
}

// CreatePipelineV2ResponseMultiError is an error wrapping multiple validation
// errors returned by CreatePipelineV2Response.ValidateAll() if the designated
// constraints aren't met.
type CreatePipelineV2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePipelineV2ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePipelineV2ResponseMultiError) AllErrors() []error { return m }

// CreatePipelineV2ResponseValidationError is the validation error returned by
// CreatePipelineV2Response.Validate if the designated constraints aren't met.
type CreatePipelineV2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePipelineV2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePipelineV2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePipelineV2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePipelineV2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePipelineV2ResponseValidationError) ErrorName() string {
	return "CreatePipelineV2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePipelineV2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePipelineV2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePipelineV2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePipelineV2ResponseValidationError{}

// Validate checks the field values on InspectPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectPipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectPipelineRequestMultiError, or nil if none found.
func (m *InspectPipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectPipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPipeline() == nil {
		err := InspectPipelineRequestValidationError{
			field:  "Pipeline",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectPipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Details

	if len(errors) > 0 {
		return InspectPipelineRequestMultiError(errors)
	}

	return nil
}

// InspectPipelineRequestMultiError is an error wrapping multiple validation
// errors returned by InspectPipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectPipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectPipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectPipelineRequestMultiError) AllErrors() []error { return m }

// InspectPipelineRequestValidationError is the validation error returned by
// InspectPipelineRequest.Validate if the designated constraints aren't met.
type InspectPipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectPipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectPipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectPipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectPipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectPipelineRequestValidationError) ErrorName() string {
	return "InspectPipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectPipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectPipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectPipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectPipelineRequestValidationError{}

// Validate checks the field values on ListPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListPipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPipelineRequestMultiError, or nil if none found.
func (m *ListPipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for History

	// no validation rules for Details

	// no validation rules for JqFilter

	if all {
		switch v := interface{}(m.GetCommitSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPipelineRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPipelineRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPipelineRequestValidationError{
				field:  "CommitSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListPipelineRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListPipelineRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListPipelineRequestValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListPipelineRequestMultiError(errors)
	}

	return nil
}

// ListPipelineRequestMultiError is an error wrapping multiple validation
// errors returned by ListPipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type ListPipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPipelineRequestMultiError) AllErrors() []error { return m }

// ListPipelineRequestValidationError is the validation error returned by
// ListPipelineRequest.Validate if the designated constraints aren't met.
type ListPipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPipelineRequestValidationError) ErrorName() string {
	return "ListPipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPipelineRequestValidationError{}

// Validate checks the field values on DeletePipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePipelineRequestMultiError, or nil if none found.
func (m *DeletePipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPipeline() == nil {
		err := DeletePipelineRequestValidationError{
			field:  "Pipeline",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeletePipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeletePipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeletePipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for All

	// no validation rules for Force

	// no validation rules for KeepRepo

	// no validation rules for MustExist

	if len(errors) > 0 {
		return DeletePipelineRequestMultiError(errors)
	}

	return nil
}

// DeletePipelineRequestMultiError is an error wrapping multiple validation
// errors returned by DeletePipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type DeletePipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePipelineRequestMultiError) AllErrors() []error { return m }

// DeletePipelineRequestValidationError is the validation error returned by
// DeletePipelineRequest.Validate if the designated constraints aren't met.
type DeletePipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePipelineRequestValidationError) ErrorName() string {
	return "DeletePipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePipelineRequestValidationError{}

// Validate checks the field values on DeletePipelinesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePipelinesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePipelinesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePipelinesRequestMultiError, or nil if none found.
func (m *DeletePipelinesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePipelinesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeletePipelinesRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeletePipelinesRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeletePipelinesRequestValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Force

	// no validation rules for KeepRepo

	// no validation rules for All

	if len(errors) > 0 {
		return DeletePipelinesRequestMultiError(errors)
	}

	return nil
}

// DeletePipelinesRequestMultiError is an error wrapping multiple validation
// errors returned by DeletePipelinesRequest.ValidateAll() if the designated
// constraints aren't met.
type DeletePipelinesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePipelinesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePipelinesRequestMultiError) AllErrors() []error { return m }

// DeletePipelinesRequestValidationError is the validation error returned by
// DeletePipelinesRequest.Validate if the designated constraints aren't met.
type DeletePipelinesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePipelinesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePipelinesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePipelinesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePipelinesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePipelinesRequestValidationError) ErrorName() string {
	return "DeletePipelinesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePipelinesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePipelinesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePipelinesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePipelinesRequestValidationError{}

// Validate checks the field values on DeletePipelinesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeletePipelinesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeletePipelinesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeletePipelinesResponseMultiError, or nil if none found.
func (m *DeletePipelinesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeletePipelinesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPipelines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeletePipelinesResponseValidationError{
						field:  fmt.Sprintf("Pipelines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeletePipelinesResponseValidationError{
						field:  fmt.Sprintf("Pipelines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeletePipelinesResponseValidationError{
					field:  fmt.Sprintf("Pipelines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeletePipelinesResponseMultiError(errors)
	}

	return nil
}

// DeletePipelinesResponseMultiError is an error wrapping multiple validation
// errors returned by DeletePipelinesResponse.ValidateAll() if the designated
// constraints aren't met.
type DeletePipelinesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePipelinesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePipelinesResponseMultiError) AllErrors() []error { return m }

// DeletePipelinesResponseValidationError is the validation error returned by
// DeletePipelinesResponse.Validate if the designated constraints aren't met.
type DeletePipelinesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePipelinesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePipelinesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePipelinesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePipelinesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePipelinesResponseValidationError) ErrorName() string {
	return "DeletePipelinesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePipelinesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePipelinesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePipelinesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePipelinesResponseValidationError{}

// Validate checks the field values on StartPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartPipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartPipelineRequestMultiError, or nil if none found.
func (m *StartPipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartPipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartPipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartPipelineRequestMultiError(errors)
	}

	return nil
}

// StartPipelineRequestMultiError is an error wrapping multiple validation
// errors returned by StartPipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type StartPipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartPipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartPipelineRequestMultiError) AllErrors() []error { return m }

// StartPipelineRequestValidationError is the validation error returned by
// StartPipelineRequest.Validate if the designated constraints aren't met.
type StartPipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartPipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartPipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartPipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartPipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartPipelineRequestValidationError) ErrorName() string {
	return "StartPipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartPipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartPipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartPipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartPipelineRequestValidationError{}

// Validate checks the field values on StopPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StopPipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StopPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StopPipelineRequestMultiError, or nil if none found.
func (m *StopPipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StopPipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StopPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StopPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StopPipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MustExist

	if len(errors) > 0 {
		return StopPipelineRequestMultiError(errors)
	}

	return nil
}

// StopPipelineRequestMultiError is an error wrapping multiple validation
// errors returned by StopPipelineRequest.ValidateAll() if the designated
// constraints aren't met.
type StopPipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopPipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopPipelineRequestMultiError) AllErrors() []error { return m }

// StopPipelineRequestValidationError is the validation error returned by
// StopPipelineRequest.Validate if the designated constraints aren't met.
type StopPipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopPipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopPipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopPipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopPipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopPipelineRequestValidationError) ErrorName() string {
	return "StopPipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StopPipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStopPipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopPipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopPipelineRequestValidationError{}

// Validate checks the field values on RunPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunPipelineRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunPipelineRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunPipelineRequestMultiError, or nil if none found.
func (m *RunPipelineRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RunPipelineRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunPipelineRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunPipelineRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProvenance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RunPipelineRequestValidationError{
						field:  fmt.Sprintf("Provenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RunPipelineRequestValidationError{
						field:  fmt.Sprintf("Provenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RunPipelineRequestValidationError{
					field:  fmt.Sprintf("Provenance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for JobId

	if len(errors) > 0 {
		return RunPipelineRequestMultiError(errors)
	}

	return nil
}

// RunPipelineRequestMultiError is an error wrapping multiple validation errors
// returned by RunPipelineRequest.ValidateAll() if the designated constraints
// aren't met.
type RunPipelineRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunPipelineRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunPipelineRequestMultiError) AllErrors() []error { return m }

// RunPipelineRequestValidationError is the validation error returned by
// RunPipelineRequest.Validate if the designated constraints aren't met.
type RunPipelineRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunPipelineRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunPipelineRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunPipelineRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunPipelineRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunPipelineRequestValidationError) ErrorName() string {
	return "RunPipelineRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RunPipelineRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunPipelineRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunPipelineRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunPipelineRequestValidationError{}

// Validate checks the field values on RunCronRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunCronRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunCronRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunCronRequestMultiError,
// or nil if none found.
func (m *RunCronRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RunCronRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPipeline() == nil {
		err := RunCronRequestValidationError{
			field:  "Pipeline",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetPipeline()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunCronRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunCronRequestValidationError{
					field:  "Pipeline",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPipeline()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunCronRequestValidationError{
				field:  "Pipeline",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RunCronRequestMultiError(errors)
	}

	return nil
}

// RunCronRequestMultiError is an error wrapping multiple validation errors
// returned by RunCronRequest.ValidateAll() if the designated constraints
// aren't met.
type RunCronRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunCronRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunCronRequestMultiError) AllErrors() []error { return m }

// RunCronRequestValidationError is the validation error returned by
// RunCronRequest.Validate if the designated constraints aren't met.
type RunCronRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunCronRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunCronRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunCronRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunCronRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunCronRequestValidationError) ErrorName() string { return "RunCronRequestValidationError" }

// Error satisfies the builtin error interface
func (e RunCronRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunCronRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunCronRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunCronRequestValidationError{}

// Validate checks the field values on CreateSecretRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateSecretRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateSecretRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateSecretRequestMultiError, or nil if none found.
func (m *CreateSecretRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateSecretRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for File

	if len(errors) > 0 {
		return CreateSecretRequestMultiError(errors)
	}

	return nil
}

// CreateSecretRequestMultiError is an error wrapping multiple validation
// errors returned by CreateSecretRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateSecretRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateSecretRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateSecretRequestMultiError) AllErrors() []error { return m }

// CreateSecretRequestValidationError is the validation error returned by
// CreateSecretRequest.Validate if the designated constraints aren't met.
type CreateSecretRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateSecretRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateSecretRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateSecretRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateSecretRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateSecretRequestValidationError) ErrorName() string {
	return "CreateSecretRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateSecretRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateSecretRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateSecretRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateSecretRequestValidationError{}

// Validate checks the field values on DeleteSecretRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteSecretRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteSecretRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteSecretRequestMultiError, or nil if none found.
func (m *DeleteSecretRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteSecretRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSecret() == nil {
		err := DeleteSecretRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteSecretRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteSecretRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteSecretRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DeleteSecretRequestMultiError(errors)
	}

	return nil
}

// DeleteSecretRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteSecretRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteSecretRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteSecretRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteSecretRequestMultiError) AllErrors() []error { return m }

// DeleteSecretRequestValidationError is the validation error returned by
// DeleteSecretRequest.Validate if the designated constraints aren't met.
type DeleteSecretRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteSecretRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteSecretRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteSecretRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteSecretRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteSecretRequestValidationError) ErrorName() string {
	return "DeleteSecretRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteSecretRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteSecretRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteSecretRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteSecretRequestValidationError{}

// Validate checks the field values on InspectSecretRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectSecretRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectSecretRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectSecretRequestMultiError, or nil if none found.
func (m *InspectSecretRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectSecretRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetSecret() == nil {
		err := InspectSecretRequestValidationError{
			field:  "Secret",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectSecretRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectSecretRequestValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectSecretRequestValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectSecretRequestMultiError(errors)
	}

	return nil
}

// InspectSecretRequestMultiError is an error wrapping multiple validation
// errors returned by InspectSecretRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectSecretRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectSecretRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectSecretRequestMultiError) AllErrors() []error { return m }

// InspectSecretRequestValidationError is the validation error returned by
// InspectSecretRequest.Validate if the designated constraints aren't met.
type InspectSecretRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectSecretRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectSecretRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectSecretRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectSecretRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectSecretRequestValidationError) ErrorName() string {
	return "InspectSecretRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectSecretRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectSecretRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectSecretRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectSecretRequestValidationError{}

// Validate checks the field values on Secret with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Secret) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Secret with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SecretMultiError, or nil if none found.
func (m *Secret) ValidateAll() error {
	return m.validate(true)
}

func (m *Secret) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return SecretMultiError(errors)
	}

	return nil
}

// SecretMultiError is an error wrapping multiple validation errors returned by
// Secret.ValidateAll() if the designated constraints aren't met.
type SecretMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretMultiError) AllErrors() []error { return m }

// SecretValidationError is the validation error returned by Secret.Validate if
// the designated constraints aren't met.
type SecretValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretValidationError) ErrorName() string { return "SecretValidationError" }

// Error satisfies the builtin error interface
func (e SecretValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecret.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretValidationError{}

// Validate checks the field values on SecretInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretInfoMultiError, or
// nil if none found.
func (m *SecretInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecretInfoValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecretInfoValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecretInfoValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetCreationTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SecretInfoValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SecretInfoValidationError{
					field:  "CreationTimestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreationTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SecretInfoValidationError{
				field:  "CreationTimestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SecretInfoMultiError(errors)
	}

	return nil
}

// SecretInfoMultiError is an error wrapping multiple validation errors
// returned by SecretInfo.ValidateAll() if the designated constraints aren't met.
type SecretInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretInfoMultiError) AllErrors() []error { return m }

// SecretInfoValidationError is the validation error returned by
// SecretInfo.Validate if the designated constraints aren't met.
type SecretInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretInfoValidationError) ErrorName() string { return "SecretInfoValidationError" }

// Error satisfies the builtin error interface
func (e SecretInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretInfoValidationError{}

// Validate checks the field values on SecretInfos with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SecretInfos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SecretInfos with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SecretInfosMultiError, or
// nil if none found.
func (m *SecretInfos) ValidateAll() error {
	return m.validate(true)
}

func (m *SecretInfos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSecretInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SecretInfosValidationError{
						field:  fmt.Sprintf("SecretInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SecretInfosValidationError{
						field:  fmt.Sprintf("SecretInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SecretInfosValidationError{
					field:  fmt.Sprintf("SecretInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SecretInfosMultiError(errors)
	}

	return nil
}

// SecretInfosMultiError is an error wrapping multiple validation errors
// returned by SecretInfos.ValidateAll() if the designated constraints aren't met.
type SecretInfosMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SecretInfosMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SecretInfosMultiError) AllErrors() []error { return m }

// SecretInfosValidationError is the validation error returned by
// SecretInfos.Validate if the designated constraints aren't met.
type SecretInfosValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SecretInfosValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SecretInfosValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SecretInfosValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SecretInfosValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SecretInfosValidationError) ErrorName() string { return "SecretInfosValidationError" }

// Error satisfies the builtin error interface
func (e SecretInfosValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSecretInfos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SecretInfosValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SecretInfosValidationError{}

// Validate checks the field values on ActivateAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateAuthRequestMultiError, or nil if none found.
func (m *ActivateAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ActivateAuthRequestMultiError(errors)
	}

	return nil
}

// ActivateAuthRequestMultiError is an error wrapping multiple validation
// errors returned by ActivateAuthRequest.ValidateAll() if the designated
// constraints aren't met.
type ActivateAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateAuthRequestMultiError) AllErrors() []error { return m }

// ActivateAuthRequestValidationError is the validation error returned by
// ActivateAuthRequest.Validate if the designated constraints aren't met.
type ActivateAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateAuthRequestValidationError) ErrorName() string {
	return "ActivateAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateAuthRequestValidationError{}

// Validate checks the field values on ActivateAuthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateAuthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateAuthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateAuthResponseMultiError, or nil if none found.
func (m *ActivateAuthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateAuthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ActivateAuthResponseMultiError(errors)
	}

	return nil
}

// ActivateAuthResponseMultiError is an error wrapping multiple validation
// errors returned by ActivateAuthResponse.ValidateAll() if the designated
// constraints aren't met.
type ActivateAuthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateAuthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateAuthResponseMultiError) AllErrors() []error { return m }

// ActivateAuthResponseValidationError is the validation error returned by
// ActivateAuthResponse.Validate if the designated constraints aren't met.
type ActivateAuthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateAuthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateAuthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateAuthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateAuthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateAuthResponseValidationError) ErrorName() string {
	return "ActivateAuthResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateAuthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateAuthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateAuthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateAuthResponseValidationError{}

// Validate checks the field values on RunLoadTestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunLoadTestRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunLoadTestRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunLoadTestRequestMultiError, or nil if none found.
func (m *RunLoadTestRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RunLoadTestRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DagSpec

	// no validation rules for LoadSpec

	// no validation rules for Seed

	// no validation rules for Parallelism

	// no validation rules for PodPatch

	// no validation rules for StateId

	if len(errors) > 0 {
		return RunLoadTestRequestMultiError(errors)
	}

	return nil
}

// RunLoadTestRequestMultiError is an error wrapping multiple validation errors
// returned by RunLoadTestRequest.ValidateAll() if the designated constraints
// aren't met.
type RunLoadTestRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunLoadTestRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunLoadTestRequestMultiError) AllErrors() []error { return m }

// RunLoadTestRequestValidationError is the validation error returned by
// RunLoadTestRequest.Validate if the designated constraints aren't met.
type RunLoadTestRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunLoadTestRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunLoadTestRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunLoadTestRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunLoadTestRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunLoadTestRequestValidationError) ErrorName() string {
	return "RunLoadTestRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RunLoadTestRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunLoadTestRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunLoadTestRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunLoadTestRequestValidationError{}

// Validate checks the field values on RunLoadTestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RunLoadTestResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunLoadTestResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RunLoadTestResponseMultiError, or nil if none found.
func (m *RunLoadTestResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RunLoadTestResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Error

	// no validation rules for StateId

	if len(errors) > 0 {
		return RunLoadTestResponseMultiError(errors)
	}

	return nil
}

// RunLoadTestResponseMultiError is an error wrapping multiple validation
// errors returned by RunLoadTestResponse.ValidateAll() if the designated
// constraints aren't met.
type RunLoadTestResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunLoadTestResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunLoadTestResponseMultiError) AllErrors() []error { return m }

// RunLoadTestResponseValidationError is the validation error returned by
// RunLoadTestResponse.Validate if the designated constraints aren't met.
type RunLoadTestResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunLoadTestResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunLoadTestResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunLoadTestResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunLoadTestResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunLoadTestResponseValidationError) ErrorName() string {
	return "RunLoadTestResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RunLoadTestResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunLoadTestResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunLoadTestResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunLoadTestResponseValidationError{}

// Validate checks the field values on RenderTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenderTemplateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenderTemplateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenderTemplateRequestMultiError, or nil if none found.
func (m *RenderTemplateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenderTemplateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Template

	// no validation rules for Args

	if len(errors) > 0 {
		return RenderTemplateRequestMultiError(errors)
	}

	return nil
}

// RenderTemplateRequestMultiError is an error wrapping multiple validation
// errors returned by RenderTemplateRequest.ValidateAll() if the designated
// constraints aren't met.
type RenderTemplateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenderTemplateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenderTemplateRequestMultiError) AllErrors() []error { return m }

// RenderTemplateRequestValidationError is the validation error returned by
// RenderTemplateRequest.Validate if the designated constraints aren't met.
type RenderTemplateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenderTemplateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenderTemplateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenderTemplateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenderTemplateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenderTemplateRequestValidationError) ErrorName() string {
	return "RenderTemplateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenderTemplateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenderTemplateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenderTemplateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenderTemplateRequestValidationError{}

// Validate checks the field values on RenderTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenderTemplateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenderTemplateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenderTemplateResponseMultiError, or nil if none found.
func (m *RenderTemplateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RenderTemplateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Json

	for idx, item := range m.GetSpecs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RenderTemplateResponseValidationError{
						field:  fmt.Sprintf("Specs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RenderTemplateResponseValidationError{
						field:  fmt.Sprintf("Specs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RenderTemplateResponseValidationError{
					field:  fmt.Sprintf("Specs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RenderTemplateResponseMultiError(errors)
	}

	return nil
}

// RenderTemplateResponseMultiError is an error wrapping multiple validation
// errors returned by RenderTemplateResponse.ValidateAll() if the designated
// constraints aren't met.
type RenderTemplateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenderTemplateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenderTemplateResponseMultiError) AllErrors() []error { return m }

// RenderTemplateResponseValidationError is the validation error returned by
// RenderTemplateResponse.Validate if the designated constraints aren't met.
type RenderTemplateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenderTemplateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenderTemplateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenderTemplateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenderTemplateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenderTemplateResponseValidationError) ErrorName() string {
	return "RenderTemplateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RenderTemplateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenderTemplateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenderTemplateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenderTemplateResponseValidationError{}

// Validate checks the field values on LokiRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LokiRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LokiRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LokiRequestMultiError, or
// nil if none found.
func (m *LokiRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *LokiRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetSince()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LokiRequestValidationError{
					field:  "Since",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LokiRequestValidationError{
					field:  "Since",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSince()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LokiRequestValidationError{
				field:  "Since",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Query

	if len(errors) > 0 {
		return LokiRequestMultiError(errors)
	}

	return nil
}

// LokiRequestMultiError is an error wrapping multiple validation errors
// returned by LokiRequest.ValidateAll() if the designated constraints aren't met.
type LokiRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LokiRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LokiRequestMultiError) AllErrors() []error { return m }

// LokiRequestValidationError is the validation error returned by
// LokiRequest.Validate if the designated constraints aren't met.
type LokiRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LokiRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LokiRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LokiRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LokiRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LokiRequestValidationError) ErrorName() string { return "LokiRequestValidationError" }

// Error satisfies the builtin error interface
func (e LokiRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLokiRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LokiRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LokiRequestValidationError{}

// Validate checks the field values on LokiLogMessage with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LokiLogMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LokiLogMessage with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LokiLogMessageMultiError,
// or nil if none found.
func (m *LokiLogMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *LokiLogMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return LokiLogMessageMultiError(errors)
	}

	return nil
}

// LokiLogMessageMultiError is an error wrapping multiple validation errors
// returned by LokiLogMessage.ValidateAll() if the designated constraints
// aren't met.
type LokiLogMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LokiLogMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LokiLogMessageMultiError) AllErrors() []error { return m }

// LokiLogMessageValidationError is the validation error returned by
// LokiLogMessage.Validate if the designated constraints aren't met.
type LokiLogMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LokiLogMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LokiLogMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LokiLogMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LokiLogMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LokiLogMessageValidationError) ErrorName() string { return "LokiLogMessageValidationError" }

// Error satisfies the builtin error interface
func (e LokiLogMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLokiLogMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LokiLogMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LokiLogMessageValidationError{}

// Validate checks the field values on ClusterDefaults with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClusterDefaults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterDefaults with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClusterDefaultsMultiError, or nil if none found.
func (m *ClusterDefaults) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterDefaults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatePipelineRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterDefaultsValidationError{
					field:  "CreatePipelineRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterDefaultsValidationError{
					field:  "CreatePipelineRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatePipelineRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterDefaultsValidationError{
				field:  "CreatePipelineRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClusterDefaultsMultiError(errors)
	}

	return nil
}

// ClusterDefaultsMultiError is an error wrapping multiple validation errors
// returned by ClusterDefaults.ValidateAll() if the designated constraints
// aren't met.
type ClusterDefaultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterDefaultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterDefaultsMultiError) AllErrors() []error { return m }

// ClusterDefaultsValidationError is the validation error returned by
// ClusterDefaults.Validate if the designated constraints aren't met.
type ClusterDefaultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterDefaultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterDefaultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterDefaultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterDefaultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterDefaultsValidationError) ErrorName() string { return "ClusterDefaultsValidationError" }

// Error satisfies the builtin error interface
func (e ClusterDefaultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterDefaults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterDefaultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterDefaultsValidationError{}

// Validate checks the field values on GetClusterDefaultsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterDefaultsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterDefaultsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterDefaultsRequestMultiError, or nil if none found.
func (m *GetClusterDefaultsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterDefaultsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetClusterDefaultsRequestMultiError(errors)
	}

	return nil
}

// GetClusterDefaultsRequestMultiError is an error wrapping multiple validation
// errors returned by GetClusterDefaultsRequest.ValidateAll() if the
// designated constraints aren't met.
type GetClusterDefaultsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterDefaultsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterDefaultsRequestMultiError) AllErrors() []error { return m }

// GetClusterDefaultsRequestValidationError is the validation error returned by
// GetClusterDefaultsRequest.Validate if the designated constraints aren't met.
type GetClusterDefaultsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterDefaultsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterDefaultsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterDefaultsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterDefaultsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterDefaultsRequestValidationError) ErrorName() string {
	return "GetClusterDefaultsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterDefaultsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterDefaultsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterDefaultsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterDefaultsRequestValidationError{}

// Validate checks the field values on GetClusterDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetClusterDefaultsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetClusterDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetClusterDefaultsResponseMultiError, or nil if none found.
func (m *GetClusterDefaultsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetClusterDefaultsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ClusterDefaultsJson

	if len(errors) > 0 {
		return GetClusterDefaultsResponseMultiError(errors)
	}

	return nil
}

// GetClusterDefaultsResponseMultiError is an error wrapping multiple
// validation errors returned by GetClusterDefaultsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetClusterDefaultsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetClusterDefaultsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetClusterDefaultsResponseMultiError) AllErrors() []error { return m }

// GetClusterDefaultsResponseValidationError is the validation error returned
// by GetClusterDefaultsResponse.Validate if the designated constraints aren't met.
type GetClusterDefaultsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetClusterDefaultsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetClusterDefaultsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetClusterDefaultsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetClusterDefaultsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetClusterDefaultsResponseValidationError) ErrorName() string {
	return "GetClusterDefaultsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetClusterDefaultsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetClusterDefaultsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetClusterDefaultsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetClusterDefaultsResponseValidationError{}

// Validate checks the field values on SetClusterDefaultsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetClusterDefaultsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetClusterDefaultsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetClusterDefaultsRequestMultiError, or nil if none found.
func (m *SetClusterDefaultsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetClusterDefaultsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Regenerate

	// no validation rules for Reprocess

	// no validation rules for DryRun

	// no validation rules for ClusterDefaultsJson

	if len(errors) > 0 {
		return SetClusterDefaultsRequestMultiError(errors)
	}

	return nil
}

// SetClusterDefaultsRequestMultiError is an error wrapping multiple validation
// errors returned by SetClusterDefaultsRequest.ValidateAll() if the
// designated constraints aren't met.
type SetClusterDefaultsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetClusterDefaultsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetClusterDefaultsRequestMultiError) AllErrors() []error { return m }

// SetClusterDefaultsRequestValidationError is the validation error returned by
// SetClusterDefaultsRequest.Validate if the designated constraints aren't met.
type SetClusterDefaultsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetClusterDefaultsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetClusterDefaultsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetClusterDefaultsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetClusterDefaultsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetClusterDefaultsRequestValidationError) ErrorName() string {
	return "SetClusterDefaultsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetClusterDefaultsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetClusterDefaultsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetClusterDefaultsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetClusterDefaultsRequestValidationError{}

// Validate checks the field values on SetClusterDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetClusterDefaultsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetClusterDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetClusterDefaultsResponseMultiError, or nil if none found.
func (m *SetClusterDefaultsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetClusterDefaultsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAffectedPipelines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetClusterDefaultsResponseValidationError{
						field:  fmt.Sprintf("AffectedPipelines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetClusterDefaultsResponseValidationError{
						field:  fmt.Sprintf("AffectedPipelines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetClusterDefaultsResponseValidationError{
					field:  fmt.Sprintf("AffectedPipelines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetClusterDefaultsResponseMultiError(errors)
	}

	return nil
}

// SetClusterDefaultsResponseMultiError is an error wrapping multiple
// validation errors returned by SetClusterDefaultsResponse.ValidateAll() if
// the designated constraints aren't met.
type SetClusterDefaultsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetClusterDefaultsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetClusterDefaultsResponseMultiError) AllErrors() []error { return m }

// SetClusterDefaultsResponseValidationError is the validation error returned
// by SetClusterDefaultsResponse.Validate if the designated constraints aren't met.
type SetClusterDefaultsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetClusterDefaultsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetClusterDefaultsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetClusterDefaultsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetClusterDefaultsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetClusterDefaultsResponseValidationError) ErrorName() string {
	return "SetClusterDefaultsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetClusterDefaultsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetClusterDefaultsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetClusterDefaultsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetClusterDefaultsResponseValidationError{}

// Validate checks the field values on CreatePipelineTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreatePipelineTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreatePipelineTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreatePipelineTransactionMultiError, or nil if none found.
func (m *CreatePipelineTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *CreatePipelineTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatePipelineRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreatePipelineTransactionValidationError{
					field:  "CreatePipelineRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreatePipelineTransactionValidationError{
					field:  "CreatePipelineRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatePipelineRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreatePipelineTransactionValidationError{
				field:  "CreatePipelineRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for UserJson

	// no validation rules for EffectiveJson

	if len(errors) > 0 {
		return CreatePipelineTransactionMultiError(errors)
	}

	return nil
}

// CreatePipelineTransactionMultiError is an error wrapping multiple validation
// errors returned by CreatePipelineTransaction.ValidateAll() if the
// designated constraints aren't met.
type CreatePipelineTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePipelineTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePipelineTransactionMultiError) AllErrors() []error { return m }

// CreatePipelineTransactionValidationError is the validation error returned by
// CreatePipelineTransaction.Validate if the designated constraints aren't met.
type CreatePipelineTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePipelineTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePipelineTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePipelineTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePipelineTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePipelineTransactionValidationError) ErrorName() string {
	return "CreatePipelineTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePipelineTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePipelineTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePipelineTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePipelineTransactionValidationError{}

// Validate checks the field values on ProjectDefaults with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ProjectDefaults) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectDefaults with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProjectDefaultsMultiError, or nil if none found.
func (m *ProjectDefaults) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectDefaults) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreatePipelineRequest()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectDefaultsValidationError{
					field:  "CreatePipelineRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectDefaultsValidationError{
					field:  "CreatePipelineRequest",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatePipelineRequest()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectDefaultsValidationError{
				field:  "CreatePipelineRequest",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ProjectDefaultsMultiError(errors)
	}

	return nil
}

// ProjectDefaultsMultiError is an error wrapping multiple validation errors
// returned by ProjectDefaults.ValidateAll() if the designated constraints
// aren't met.
type ProjectDefaultsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectDefaultsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectDefaultsMultiError) AllErrors() []error { return m }

// ProjectDefaultsValidationError is the validation error returned by
// ProjectDefaults.Validate if the designated constraints aren't met.
type ProjectDefaultsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectDefaultsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectDefaultsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectDefaultsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectDefaultsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectDefaultsValidationError) ErrorName() string { return "ProjectDefaultsValidationError" }

// Error satisfies the builtin error interface
func (e ProjectDefaultsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectDefaults.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectDefaultsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectDefaultsValidationError{}

// Validate checks the field values on GetProjectDefaultsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectDefaultsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectDefaultsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectDefaultsRequestMultiError, or nil if none found.
func (m *GetProjectDefaultsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectDefaultsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetProjectDefaultsRequestMultiError(errors)
	}

	return nil
}

// GetProjectDefaultsRequestMultiError is an error wrapping multiple validation
// errors returned by GetProjectDefaultsRequest.ValidateAll() if the
// designated constraints aren't met.
type GetProjectDefaultsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectDefaultsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectDefaultsRequestMultiError) AllErrors() []error { return m }

// GetProjectDefaultsRequestValidationError is the validation error returned by
// GetProjectDefaultsRequest.Validate if the designated constraints aren't met.
type GetProjectDefaultsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectDefaultsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectDefaultsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectDefaultsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectDefaultsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectDefaultsRequestValidationError) ErrorName() string {
	return "GetProjectDefaultsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectDefaultsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectDefaultsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectDefaultsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectDefaultsRequestValidationError{}

// Validate checks the field values on GetProjectDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetProjectDefaultsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetProjectDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetProjectDefaultsResponseMultiError, or nil if none found.
func (m *GetProjectDefaultsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetProjectDefaultsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProjectDefaultsJson

	if len(errors) > 0 {
		return GetProjectDefaultsResponseMultiError(errors)
	}

	return nil
}

// GetProjectDefaultsResponseMultiError is an error wrapping multiple
// validation errors returned by GetProjectDefaultsResponse.ValidateAll() if
// the designated constraints aren't met.
type GetProjectDefaultsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetProjectDefaultsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetProjectDefaultsResponseMultiError) AllErrors() []error { return m }

// GetProjectDefaultsResponseValidationError is the validation error returned
// by GetProjectDefaultsResponse.Validate if the designated constraints aren't met.
type GetProjectDefaultsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetProjectDefaultsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetProjectDefaultsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetProjectDefaultsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetProjectDefaultsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetProjectDefaultsResponseValidationError) ErrorName() string {
	return "GetProjectDefaultsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetProjectDefaultsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetProjectDefaultsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetProjectDefaultsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetProjectDefaultsResponseValidationError{}

// Validate checks the field values on SetProjectDefaultsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetProjectDefaultsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetProjectDefaultsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetProjectDefaultsRequestMultiError, or nil if none found.
func (m *SetProjectDefaultsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SetProjectDefaultsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Regenerate

	// no validation rules for Reprocess

	// no validation rules for DryRun

	// no validation rules for ProjectDefaultsJson

	if len(errors) > 0 {
		return SetProjectDefaultsRequestMultiError(errors)
	}

	return nil
}

// SetProjectDefaultsRequestMultiError is an error wrapping multiple validation
// errors returned by SetProjectDefaultsRequest.ValidateAll() if the
// designated constraints aren't met.
type SetProjectDefaultsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetProjectDefaultsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetProjectDefaultsRequestMultiError) AllErrors() []error { return m }

// SetProjectDefaultsRequestValidationError is the validation error returned by
// SetProjectDefaultsRequest.Validate if the designated constraints aren't met.
type SetProjectDefaultsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetProjectDefaultsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetProjectDefaultsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetProjectDefaultsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetProjectDefaultsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetProjectDefaultsRequestValidationError) ErrorName() string {
	return "SetProjectDefaultsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetProjectDefaultsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetProjectDefaultsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetProjectDefaultsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetProjectDefaultsRequestValidationError{}

// Validate checks the field values on SetProjectDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetProjectDefaultsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetProjectDefaultsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetProjectDefaultsResponseMultiError, or nil if none found.
func (m *SetProjectDefaultsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SetProjectDefaultsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAffectedPipelines() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SetProjectDefaultsResponseValidationError{
						field:  fmt.Sprintf("AffectedPipelines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SetProjectDefaultsResponseValidationError{
						field:  fmt.Sprintf("AffectedPipelines[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SetProjectDefaultsResponseValidationError{
					field:  fmt.Sprintf("AffectedPipelines[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SetProjectDefaultsResponseMultiError(errors)
	}

	return nil
}

// SetProjectDefaultsResponseMultiError is an error wrapping multiple
// validation errors returned by SetProjectDefaultsResponse.ValidateAll() if
// the designated constraints aren't met.
type SetProjectDefaultsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetProjectDefaultsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetProjectDefaultsResponseMultiError) AllErrors() []error { return m }

// SetProjectDefaultsResponseValidationError is the validation error returned
// by SetProjectDefaultsResponse.Validate if the designated constraints aren't met.
type SetProjectDefaultsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetProjectDefaultsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetProjectDefaultsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetProjectDefaultsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetProjectDefaultsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetProjectDefaultsResponseValidationError) ErrorName() string {
	return "SetProjectDefaultsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetProjectDefaultsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetProjectDefaultsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetProjectDefaultsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetProjectDefaultsResponseValidationError{}

// Validate checks the field values on JobInfo_Details with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *JobInfo_Details) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JobInfo_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// JobInfo_DetailsMultiError, or nil if none found.
func (m *JobInfo_Details) ValidateAll() error {
	return m.validate(true)
}

func (m *JobInfo_Details) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransform()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Transform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Transform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransform()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "Transform",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParallelismSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "ParallelismSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "ParallelismSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParallelismSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "ParallelismSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Egress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Egress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "Egress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Spout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Spout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "Spout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetWorkerStatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, JobInfo_DetailsValidationError{
						field:  fmt.Sprintf("WorkerStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, JobInfo_DetailsValidationError{
						field:  fmt.Sprintf("WorkerStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return JobInfo_DetailsValidationError{
					field:  fmt.Sprintf("WorkerStatus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetResourceRequests()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "ResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "ResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceRequests()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "ResourceRequests",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResourceLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "ResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "ResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "ResourceLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSidecarResourceLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "SidecarResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "SidecarResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSidecarResourceLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "SidecarResourceLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Salt

	if all {
		switch v := interface{}(m.GetDatumSetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "DatumSetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "DatumSetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumSetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "DatumSetSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatumTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "DatumTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "DatumTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "DatumTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJobTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "JobTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "JobTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJobTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "JobTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DatumTries

	if all {
		switch v := interface{}(m.GetSchedulingSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "SchedulingSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "SchedulingSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchedulingSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "SchedulingSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PodSpec

	// no validation rules for PodPatch

	if all {
		switch v := interface{}(m.GetSidecarResourceRequests()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "SidecarResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, JobInfo_DetailsValidationError{
					field:  "SidecarResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSidecarResourceRequests()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return JobInfo_DetailsValidationError{
				field:  "SidecarResourceRequests",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return JobInfo_DetailsMultiError(errors)
	}

	return nil
}

// JobInfo_DetailsMultiError is an error wrapping multiple validation errors
// returned by JobInfo_Details.ValidateAll() if the designated constraints
// aren't met.
type JobInfo_DetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobInfo_DetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobInfo_DetailsMultiError) AllErrors() []error { return m }

// JobInfo_DetailsValidationError is the validation error returned by
// JobInfo_Details.Validate if the designated constraints aren't met.
type JobInfo_DetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobInfo_DetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobInfo_DetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobInfo_DetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobInfo_DetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobInfo_DetailsValidationError) ErrorName() string { return "JobInfo_DetailsValidationError" }

// Error satisfies the builtin error interface
func (e JobInfo_DetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobInfo_Details.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobInfo_DetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobInfo_DetailsValidationError{}

// Validate checks the field values on PipelineInfo_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PipelineInfo_Details) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PipelineInfo_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PipelineInfo_DetailsMultiError, or nil if none found.
func (m *PipelineInfo_Details) ValidateAll() error {
	return m.validate(true)
}

func (m *PipelineInfo_Details) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTransform()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Transform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Transform",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransform()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Transform",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTfJob()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "TfJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "TfJob",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTfJob()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "TfJob",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetParallelismSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "ParallelismSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "ParallelismSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParallelismSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "ParallelismSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEgress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Egress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Egress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEgress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Egress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for RecentError

	// no validation rules for WorkersRequested

	// no validation rules for WorkersAvailable

	// no validation rules for OutputBranch

	if all {
		switch v := interface{}(m.GetResourceRequests()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "ResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "ResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceRequests()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "ResourceRequests",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResourceLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "ResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "ResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResourceLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "ResourceLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSidecarResourceLimits()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "SidecarResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "SidecarResourceLimits",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSidecarResourceLimits()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "SidecarResourceLimits",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInput()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Input",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInput()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Input",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Salt

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetService()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Service",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetService()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Spout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Spout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Spout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatumSetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "DatumSetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "DatumSetSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumSetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "DatumSetSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDatumTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "DatumTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "DatumTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDatumTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "DatumTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJobTimeout()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "JobTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "JobTimeout",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJobTimeout()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "JobTimeout",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DatumTries

	if all {
		switch v := interface{}(m.GetSchedulingSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "SchedulingSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "SchedulingSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSchedulingSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "SchedulingSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for PodSpec

	// no validation rules for PodPatch

	// no validation rules for S3Out

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ReprocessSpec

	// no validation rules for UnclaimedTasks

	// no validation rules for WorkerRc

	// no validation rules for Autoscaling

	for idx, item := range m.GetTolerations() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PipelineInfo_DetailsValidationError{
						field:  fmt.Sprintf("Tolerations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PipelineInfo_DetailsValidationError{
						field:  fmt.Sprintf("Tolerations[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PipelineInfo_DetailsValidationError{
					field:  fmt.Sprintf("Tolerations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetSidecarResourceRequests()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "SidecarResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "SidecarResourceRequests",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSidecarResourceRequests()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "SidecarResourceRequests",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetermined()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Determined",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PipelineInfo_DetailsValidationError{
					field:  "Determined",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetermined()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PipelineInfo_DetailsValidationError{
				field:  "Determined",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PipelineInfo_DetailsMultiError(errors)
	}

	return nil
}

// PipelineInfo_DetailsMultiError is an error wrapping multiple validation
// errors returned by PipelineInfo_Details.ValidateAll() if the designated
// constraints aren't met.
type PipelineInfo_DetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PipelineInfo_DetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PipelineInfo_DetailsMultiError) AllErrors() []error { return m }

// PipelineInfo_DetailsValidationError is the validation error returned by
// PipelineInfo_Details.Validate if the designated constraints aren't met.
type PipelineInfo_DetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PipelineInfo_DetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PipelineInfo_DetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PipelineInfo_DetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PipelineInfo_DetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PipelineInfo_DetailsValidationError) ErrorName() string {
	return "PipelineInfo_DetailsValidationError"
}

// Error satisfies the builtin error interface
func (e PipelineInfo_DetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPipelineInfo_Details.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PipelineInfo_DetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PipelineInfo_DetailsValidationError{}

// Validate checks the field values on ListDatumRequest_Filter with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListDatumRequest_Filter) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListDatumRequest_Filter with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListDatumRequest_FilterMultiError, or nil if none found.
func (m *ListDatumRequest_Filter) ValidateAll() error {
	return m.validate(true)
}

func (m *ListDatumRequest_Filter) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListDatumRequest_FilterMultiError(errors)
	}

	return nil
}

// ListDatumRequest_FilterMultiError is an error wrapping multiple validation
// errors returned by ListDatumRequest_Filter.ValidateAll() if the designated
// constraints aren't met.
type ListDatumRequest_FilterMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDatumRequest_FilterMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDatumRequest_FilterMultiError) AllErrors() []error { return m }

// ListDatumRequest_FilterValidationError is the validation error returned by
// ListDatumRequest_Filter.Validate if the designated constraints aren't met.
type ListDatumRequest_FilterValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDatumRequest_FilterValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDatumRequest_FilterValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDatumRequest_FilterValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDatumRequest_FilterValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDatumRequest_FilterValidationError) ErrorName() string {
	return "ListDatumRequest_FilterValidationError"
}

// Error satisfies the builtin error interface
func (e ListDatumRequest_FilterValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDatumRequest_Filter.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDatumRequest_FilterValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDatumRequest_FilterValidationError{}
