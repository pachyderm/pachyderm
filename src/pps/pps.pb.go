// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pps/pps.proto

package pps

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	pfs "github.com/pachyderm/pachyderm/v2/src/pfs"
	task "github.com/pachyderm/pachyderm/v2/src/task"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type JobState int32

const (
	JobState_JOB_STATE_UNKNOWN JobState = 0
	JobState_JOB_CREATED       JobState = 1
	JobState_JOB_STARTING      JobState = 2
	JobState_JOB_RUNNING       JobState = 3
	JobState_JOB_FAILURE       JobState = 4
	JobState_JOB_SUCCESS       JobState = 5
	JobState_JOB_KILLED        JobState = 6
	JobState_JOB_EGRESSING     JobState = 7
	JobState_JOB_FINISHING     JobState = 8
	JobState_JOB_UNRUNNABLE    JobState = 9
)

var JobState_name = map[int32]string{
	0: "JOB_STATE_UNKNOWN",
	1: "JOB_CREATED",
	2: "JOB_STARTING",
	3: "JOB_RUNNING",
	4: "JOB_FAILURE",
	5: "JOB_SUCCESS",
	6: "JOB_KILLED",
	7: "JOB_EGRESSING",
	8: "JOB_FINISHING",
	9: "JOB_UNRUNNABLE",
}

var JobState_value = map[string]int32{
	"JOB_STATE_UNKNOWN": 0,
	"JOB_CREATED":       1,
	"JOB_STARTING":      2,
	"JOB_RUNNING":       3,
	"JOB_FAILURE":       4,
	"JOB_SUCCESS":       5,
	"JOB_KILLED":        6,
	"JOB_EGRESSING":     7,
	"JOB_FINISHING":     8,
	"JOB_UNRUNNABLE":    9,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{0}
}

type DatumState int32

const (
	DatumState_UNKNOWN   DatumState = 0
	DatumState_FAILED    DatumState = 1
	DatumState_SUCCESS   DatumState = 2
	DatumState_SKIPPED   DatumState = 3
	DatumState_STARTING  DatumState = 4
	DatumState_RECOVERED DatumState = 5
)

var DatumState_name = map[int32]string{
	0: "UNKNOWN",
	1: "FAILED",
	2: "SUCCESS",
	3: "SKIPPED",
	4: "STARTING",
	5: "RECOVERED",
}

var DatumState_value = map[string]int32{
	"UNKNOWN":   0,
	"FAILED":    1,
	"SUCCESS":   2,
	"SKIPPED":   3,
	"STARTING":  4,
	"RECOVERED": 5,
}

func (x DatumState) String() string {
	return proto.EnumName(DatumState_name, int32(x))
}

func (DatumState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{1}
}

type WorkerState int32

const (
	WorkerState_WORKER_STATE_UNKNOWN WorkerState = 0
	WorkerState_POD_RUNNING          WorkerState = 1
	WorkerState_POD_SUCCESS          WorkerState = 2
	WorkerState_POD_FAILED           WorkerState = 3
)

var WorkerState_name = map[int32]string{
	0: "WORKER_STATE_UNKNOWN",
	1: "POD_RUNNING",
	2: "POD_SUCCESS",
	3: "POD_FAILED",
}

var WorkerState_value = map[string]int32{
	"WORKER_STATE_UNKNOWN": 0,
	"POD_RUNNING":          1,
	"POD_SUCCESS":          2,
	"POD_FAILED":           3,
}

func (x WorkerState) String() string {
	return proto.EnumName(WorkerState_name, int32(x))
}

func (WorkerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{2}
}

type PipelineState int32

const (
	PipelineState_PIPELINE_STATE_UNKNOWN PipelineState = 0
	// There is a PipelineInfo + spec commit, but no RC
	// This happens when a pipeline has been created but not yet picked up by a
	// PPS server.
	PipelineState_PIPELINE_STARTING PipelineState = 1
	// A pipeline has a spec commit and a service + RC
	// This is the normal state of a pipeline.
	PipelineState_PIPELINE_RUNNING PipelineState = 2
	// Equivalent to STARTING (there is a PipelineInfo + commit, but no RC)
	// After some error caused runPipeline to exit, but before the pipeline is
	// re-run. This is when the exponential backoff is in effect.
	PipelineState_PIPELINE_RESTARTING PipelineState = 3
	// The pipeline has encountered unrecoverable errors and is no longer being
	// retried. It won't leave this state until the pipeline is updated.
	PipelineState_PIPELINE_FAILURE PipelineState = 4
	// The pipeline has been explicitly paused by the user (the pipeline spec's
	// Stopped field should be true if the pipeline is in this state)
	PipelineState_PIPELINE_PAUSED PipelineState = 5
	// The pipeline is fully functional, but there are no commits to process.
	PipelineState_PIPELINE_STANDBY PipelineState = 6
	// The pipeline's workers are crashing, or failing to come up, this may
	// resolve itself, the pipeline may make progress while in this state if the
	// problem is only being experienced by some workers.
	PipelineState_PIPELINE_CRASHING PipelineState = 7
)

var PipelineState_name = map[int32]string{
	0: "PIPELINE_STATE_UNKNOWN",
	1: "PIPELINE_STARTING",
	2: "PIPELINE_RUNNING",
	3: "PIPELINE_RESTARTING",
	4: "PIPELINE_FAILURE",
	5: "PIPELINE_PAUSED",
	6: "PIPELINE_STANDBY",
	7: "PIPELINE_CRASHING",
}

var PipelineState_value = map[string]int32{
	"PIPELINE_STATE_UNKNOWN": 0,
	"PIPELINE_STARTING":      1,
	"PIPELINE_RUNNING":       2,
	"PIPELINE_RESTARTING":    3,
	"PIPELINE_FAILURE":       4,
	"PIPELINE_PAUSED":        5,
	"PIPELINE_STANDBY":       6,
	"PIPELINE_CRASHING":      7,
}

func (x PipelineState) String() string {
	return proto.EnumName(PipelineState_name, int32(x))
}

func (PipelineState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{3}
}

// The pipeline type is stored here so that we can internally know the type of
// the pipeline without loading the spec from PFS.
type PipelineInfo_PipelineType int32

const (
	PipelineInfo_PIPELINT_TYPE_UNKNOWN   PipelineInfo_PipelineType = 0
	PipelineInfo_PIPELINE_TYPE_TRANSFORM PipelineInfo_PipelineType = 1
	PipelineInfo_PIPELINE_TYPE_SPOUT     PipelineInfo_PipelineType = 2
	PipelineInfo_PIPELINE_TYPE_SERVICE   PipelineInfo_PipelineType = 3
)

var PipelineInfo_PipelineType_name = map[int32]string{
	0: "PIPELINT_TYPE_UNKNOWN",
	1: "PIPELINE_TYPE_TRANSFORM",
	2: "PIPELINE_TYPE_SPOUT",
	3: "PIPELINE_TYPE_SERVICE",
}

var PipelineInfo_PipelineType_value = map[string]int32{
	"PIPELINT_TYPE_UNKNOWN":   0,
	"PIPELINE_TYPE_TRANSFORM": 1,
	"PIPELINE_TYPE_SPOUT":     2,
	"PIPELINE_TYPE_SERVICE":   3,
}

func (x PipelineInfo_PipelineType) String() string {
	return proto.EnumName(PipelineInfo_PipelineType_name, int32(x))
}

func (PipelineInfo_PipelineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{27, 0}
}

type SecretMount struct {
	// Name must be the name of the secret in kubernetes.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Key of the secret to load into env_var, this field only has meaning if EnvVar != "".
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	MountPath            string   `protobuf:"bytes,3,opt,name=mount_path,json=mountPath,proto3" json:"mount_path,omitempty"`
	EnvVar               string   `protobuf:"bytes,4,opt,name=env_var,json=envVar,proto3" json:"env_var,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SecretMount) Reset()         { *m = SecretMount{} }
func (m *SecretMount) String() string { return proto.CompactTextString(m) }
func (*SecretMount) ProtoMessage()    {}
func (*SecretMount) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{0}
}
func (m *SecretMount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretMount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretMount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretMount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretMount.Merge(m, src)
}
func (m *SecretMount) XXX_Size() int {
	return m.Size()
}
func (m *SecretMount) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretMount.DiscardUnknown(m)
}

var xxx_messageInfo_SecretMount proto.InternalMessageInfo

func (m *SecretMount) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SecretMount) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *SecretMount) GetMountPath() string {
	if m != nil {
		return m.MountPath
	}
	return ""
}

func (m *SecretMount) GetEnvVar() string {
	if m != nil {
		return m.EnvVar
	}
	return ""
}

type Transform struct {
	Image                string            `protobuf:"bytes,1,opt,name=image,proto3" json:"image,omitempty"`
	Cmd                  []string          `protobuf:"bytes,2,rep,name=cmd,proto3" json:"cmd,omitempty"`
	ErrCmd               []string          `protobuf:"bytes,3,rep,name=err_cmd,json=errCmd,proto3" json:"err_cmd,omitempty"`
	Env                  map[string]string `protobuf:"bytes,4,rep,name=env,proto3" json:"env,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Secrets              []*SecretMount    `protobuf:"bytes,5,rep,name=secrets,proto3" json:"secrets,omitempty"`
	ImagePullSecrets     []string          `protobuf:"bytes,6,rep,name=image_pull_secrets,json=imagePullSecrets,proto3" json:"image_pull_secrets,omitempty"`
	Stdin                []string          `protobuf:"bytes,7,rep,name=stdin,proto3" json:"stdin,omitempty"`
	ErrStdin             []string          `protobuf:"bytes,8,rep,name=err_stdin,json=errStdin,proto3" json:"err_stdin,omitempty"`
	AcceptReturnCode     []int64           `protobuf:"varint,9,rep,packed,name=accept_return_code,json=acceptReturnCode,proto3" json:"accept_return_code,omitempty"`
	Debug                bool              `protobuf:"varint,10,opt,name=debug,proto3" json:"debug,omitempty"`
	User                 string            `protobuf:"bytes,11,opt,name=user,proto3" json:"user,omitempty"`
	WorkingDir           string            `protobuf:"bytes,12,opt,name=working_dir,json=workingDir,proto3" json:"working_dir,omitempty"`
	Dockerfile           string            `protobuf:"bytes,13,opt,name=dockerfile,proto3" json:"dockerfile,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Transform) Reset()         { *m = Transform{} }
func (m *Transform) String() string { return proto.CompactTextString(m) }
func (*Transform) ProtoMessage()    {}
func (*Transform) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{1}
}
func (m *Transform) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transform) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transform.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transform) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transform.Merge(m, src)
}
func (m *Transform) XXX_Size() int {
	return m.Size()
}
func (m *Transform) XXX_DiscardUnknown() {
	xxx_messageInfo_Transform.DiscardUnknown(m)
}

var xxx_messageInfo_Transform proto.InternalMessageInfo

func (m *Transform) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *Transform) GetCmd() []string {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Transform) GetErrCmd() []string {
	if m != nil {
		return m.ErrCmd
	}
	return nil
}

func (m *Transform) GetEnv() map[string]string {
	if m != nil {
		return m.Env
	}
	return nil
}

func (m *Transform) GetSecrets() []*SecretMount {
	if m != nil {
		return m.Secrets
	}
	return nil
}

func (m *Transform) GetImagePullSecrets() []string {
	if m != nil {
		return m.ImagePullSecrets
	}
	return nil
}

func (m *Transform) GetStdin() []string {
	if m != nil {
		return m.Stdin
	}
	return nil
}

func (m *Transform) GetErrStdin() []string {
	if m != nil {
		return m.ErrStdin
	}
	return nil
}

func (m *Transform) GetAcceptReturnCode() []int64 {
	if m != nil {
		return m.AcceptReturnCode
	}
	return nil
}

func (m *Transform) GetDebug() bool {
	if m != nil {
		return m.Debug
	}
	return false
}

func (m *Transform) GetUser() string {
	if m != nil {
		return m.User
	}
	return ""
}

func (m *Transform) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *Transform) GetDockerfile() string {
	if m != nil {
		return m.Dockerfile
	}
	return ""
}

type TFJob struct {
	// tf_job  is a serialized Kubeflow TFJob spec. Pachyderm sends this directly
	// to a kubernetes cluster on which kubeflow has been installed, instead of
	// creating a pipeline ReplicationController as it normally would.
	TFJob                string   `protobuf:"bytes,1,opt,name=tf_job,json=tfJob,proto3" json:"tf_job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TFJob) Reset()         { *m = TFJob{} }
func (m *TFJob) String() string { return proto.CompactTextString(m) }
func (*TFJob) ProtoMessage()    {}
func (*TFJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{2}
}
func (m *TFJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TFJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TFJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TFJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TFJob.Merge(m, src)
}
func (m *TFJob) XXX_Size() int {
	return m.Size()
}
func (m *TFJob) XXX_DiscardUnknown() {
	xxx_messageInfo_TFJob.DiscardUnknown(m)
}

var xxx_messageInfo_TFJob proto.InternalMessageInfo

func (m *TFJob) GetTFJob() string {
	if m != nil {
		return m.TFJob
	}
	return ""
}

type Egress struct {
	URL string `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	// Types that are valid to be assigned to Target:
	//	*Egress_ObjectStorage
	//	*Egress_SqlDatabase
	Target               isEgress_Target `protobuf_oneof:"target"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Egress) Reset()         { *m = Egress{} }
func (m *Egress) String() string { return proto.CompactTextString(m) }
func (*Egress) ProtoMessage()    {}
func (*Egress) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{3}
}
func (m *Egress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Egress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Egress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Egress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Egress.Merge(m, src)
}
func (m *Egress) XXX_Size() int {
	return m.Size()
}
func (m *Egress) XXX_DiscardUnknown() {
	xxx_messageInfo_Egress.DiscardUnknown(m)
}

var xxx_messageInfo_Egress proto.InternalMessageInfo

type isEgress_Target interface {
	isEgress_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Egress_ObjectStorage struct {
	ObjectStorage *pfs.ObjectStorageEgress `protobuf:"bytes,2,opt,name=object_storage,json=objectStorage,proto3,oneof" json:"object_storage,omitempty"`
}
type Egress_SqlDatabase struct {
	SqlDatabase *pfs.SQLDatabaseEgress `protobuf:"bytes,3,opt,name=sql_database,json=sqlDatabase,proto3,oneof" json:"sql_database,omitempty"`
}

func (*Egress_ObjectStorage) isEgress_Target() {}
func (*Egress_SqlDatabase) isEgress_Target()   {}

func (m *Egress) GetTarget() isEgress_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Egress) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *Egress) GetObjectStorage() *pfs.ObjectStorageEgress {
	if x, ok := m.GetTarget().(*Egress_ObjectStorage); ok {
		return x.ObjectStorage
	}
	return nil
}

func (m *Egress) GetSqlDatabase() *pfs.SQLDatabaseEgress {
	if x, ok := m.GetTarget().(*Egress_SqlDatabase); ok {
		return x.SqlDatabase
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Egress) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Egress_ObjectStorage)(nil),
		(*Egress_SqlDatabase)(nil),
	}
}

type Job struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	ID                   string    `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Job) Reset()      { *m = Job{} }
func (*Job) ProtoMessage() {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{4}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *Job) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type Metadata struct {
	Annotations          map[string]string `protobuf:"bytes,1,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Labels               map[string]string `protobuf:"bytes,2,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{5}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

func (m *Metadata) GetAnnotations() map[string]string {
	if m != nil {
		return m.Annotations
	}
	return nil
}

func (m *Metadata) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

type Service struct {
	InternalPort         int32    `protobuf:"varint,1,opt,name=internal_port,json=internalPort,proto3" json:"internal_port,omitempty"`
	ExternalPort         int32    `protobuf:"varint,2,opt,name=external_port,json=externalPort,proto3" json:"external_port,omitempty"`
	IP                   string   `protobuf:"bytes,3,opt,name=ip,proto3" json:"ip,omitempty"`
	Type                 string   `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Service) Reset()         { *m = Service{} }
func (m *Service) String() string { return proto.CompactTextString(m) }
func (*Service) ProtoMessage()    {}
func (*Service) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{6}
}
func (m *Service) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Service) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Service.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Service) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Service.Merge(m, src)
}
func (m *Service) XXX_Size() int {
	return m.Size()
}
func (m *Service) XXX_DiscardUnknown() {
	xxx_messageInfo_Service.DiscardUnknown(m)
}

var xxx_messageInfo_Service proto.InternalMessageInfo

func (m *Service) GetInternalPort() int32 {
	if m != nil {
		return m.InternalPort
	}
	return 0
}

func (m *Service) GetExternalPort() int32 {
	if m != nil {
		return m.ExternalPort
	}
	return 0
}

func (m *Service) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *Service) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type Spout struct {
	Service              *Service `protobuf:"bytes,1,opt,name=service,proto3" json:"service,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Spout) Reset()         { *m = Spout{} }
func (m *Spout) String() string { return proto.CompactTextString(m) }
func (*Spout) ProtoMessage()    {}
func (*Spout) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{7}
}
func (m *Spout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Spout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Spout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Spout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Spout.Merge(m, src)
}
func (m *Spout) XXX_Size() int {
	return m.Size()
}
func (m *Spout) XXX_DiscardUnknown() {
	xxx_messageInfo_Spout.DiscardUnknown(m)
}

var xxx_messageInfo_Spout proto.InternalMessageInfo

func (m *Spout) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

type PFSInput struct {
	Name      string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo      string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	RepoType  string `protobuf:"bytes,13,opt,name=repo_type,json=repoType,proto3" json:"repo_type,omitempty"`
	Branch    string `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	Commit    string `protobuf:"bytes,4,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob      string `protobuf:"bytes,5,opt,name=glob,proto3" json:"glob,omitempty"`
	JoinOn    string `protobuf:"bytes,6,opt,name=join_on,json=joinOn,proto3" json:"join_on,omitempty"`
	OuterJoin bool   `protobuf:"varint,7,opt,name=outer_join,json=outerJoin,proto3" json:"outer_join,omitempty"`
	GroupBy   string `protobuf:"bytes,8,opt,name=group_by,json=groupBy,proto3" json:"group_by,omitempty"`
	Lazy      bool   `protobuf:"varint,9,opt,name=lazy,proto3" json:"lazy,omitempty"`
	// EmptyFiles, if true, will cause files from this PFS input to be
	// presented as empty files. This is useful in shuffle pipelines where you
	// want to read the names of files and reorganize them using symlinks.
	EmptyFiles bool `protobuf:"varint,10,opt,name=empty_files,json=emptyFiles,proto3" json:"empty_files,omitempty"`
	// S3, if true, will cause the worker to NOT download or link files from this
	// input into the /pfs_v2 directory. Instead, an instance of our S3 gateway
	// service will run on each of the sidecars, and data can be retrieved from
	// this input by querying
	// http://<pipeline>-s3.<namespace>/<job id>.<input>/my/file
	S3 bool `protobuf:"varint,11,opt,name=s3,proto3" json:"s3,omitempty"`
	// Trigger defines when this input is processed by the pipeline, if it's nil
	// the input is processed anytime something is committed to the input branch.
	Trigger              *pfs.Trigger `protobuf:"bytes,12,opt,name=trigger,proto3" json:"trigger,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *PFSInput) Reset()         { *m = PFSInput{} }
func (m *PFSInput) String() string { return proto.CompactTextString(m) }
func (*PFSInput) ProtoMessage()    {}
func (*PFSInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{8}
}
func (m *PFSInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PFSInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PFSInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PFSInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PFSInput.Merge(m, src)
}
func (m *PFSInput) XXX_Size() int {
	return m.Size()
}
func (m *PFSInput) XXX_DiscardUnknown() {
	xxx_messageInfo_PFSInput.DiscardUnknown(m)
}

var xxx_messageInfo_PFSInput proto.InternalMessageInfo

func (m *PFSInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PFSInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *PFSInput) GetRepoType() string {
	if m != nil {
		return m.RepoType
	}
	return ""
}

func (m *PFSInput) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *PFSInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *PFSInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *PFSInput) GetJoinOn() string {
	if m != nil {
		return m.JoinOn
	}
	return ""
}

func (m *PFSInput) GetOuterJoin() bool {
	if m != nil {
		return m.OuterJoin
	}
	return false
}

func (m *PFSInput) GetGroupBy() string {
	if m != nil {
		return m.GroupBy
	}
	return ""
}

func (m *PFSInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

func (m *PFSInput) GetEmptyFiles() bool {
	if m != nil {
		return m.EmptyFiles
	}
	return false
}

func (m *PFSInput) GetS3() bool {
	if m != nil {
		return m.S3
	}
	return false
}

func (m *PFSInput) GetTrigger() *pfs.Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

type CronInput struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Repo   string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	Commit string `protobuf:"bytes,3,opt,name=commit,proto3" json:"commit,omitempty"`
	Spec   string `protobuf:"bytes,4,opt,name=spec,proto3" json:"spec,omitempty"`
	// Overwrite, if true, will expose a single datum that gets overwritten each
	// tick. If false, it will create a new datum for each tick.
	Overwrite            bool             `protobuf:"varint,5,opt,name=overwrite,proto3" json:"overwrite,omitempty"`
	Start                *types.Timestamp `protobuf:"bytes,6,opt,name=start,proto3" json:"start,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CronInput) Reset()         { *m = CronInput{} }
func (m *CronInput) String() string { return proto.CompactTextString(m) }
func (*CronInput) ProtoMessage()    {}
func (*CronInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{9}
}
func (m *CronInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CronInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CronInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CronInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CronInput.Merge(m, src)
}
func (m *CronInput) XXX_Size() int {
	return m.Size()
}
func (m *CronInput) XXX_DiscardUnknown() {
	xxx_messageInfo_CronInput.DiscardUnknown(m)
}

var xxx_messageInfo_CronInput proto.InternalMessageInfo

func (m *CronInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CronInput) GetRepo() string {
	if m != nil {
		return m.Repo
	}
	return ""
}

func (m *CronInput) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *CronInput) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *CronInput) GetOverwrite() bool {
	if m != nil {
		return m.Overwrite
	}
	return false
}

func (m *CronInput) GetStart() *types.Timestamp {
	if m != nil {
		return m.Start
	}
	return nil
}

type Input struct {
	Pfs                  *PFSInput  `protobuf:"bytes,1,opt,name=pfs,proto3" json:"pfs,omitempty"`
	Join                 []*Input   `protobuf:"bytes,2,rep,name=join,proto3" json:"join,omitempty"`
	Group                []*Input   `protobuf:"bytes,3,rep,name=group,proto3" json:"group,omitempty"`
	Cross                []*Input   `protobuf:"bytes,4,rep,name=cross,proto3" json:"cross,omitempty"`
	Union                []*Input   `protobuf:"bytes,5,rep,name=union,proto3" json:"union,omitempty"`
	Cron                 *CronInput `protobuf:"bytes,6,opt,name=cron,proto3" json:"cron,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Input) Reset()         { *m = Input{} }
func (m *Input) String() string { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()    {}
func (*Input) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{10}
}
func (m *Input) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Input) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Input.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Input) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Input.Merge(m, src)
}
func (m *Input) XXX_Size() int {
	return m.Size()
}
func (m *Input) XXX_DiscardUnknown() {
	xxx_messageInfo_Input.DiscardUnknown(m)
}

var xxx_messageInfo_Input proto.InternalMessageInfo

func (m *Input) GetPfs() *PFSInput {
	if m != nil {
		return m.Pfs
	}
	return nil
}

func (m *Input) GetJoin() []*Input {
	if m != nil {
		return m.Join
	}
	return nil
}

func (m *Input) GetGroup() []*Input {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *Input) GetCross() []*Input {
	if m != nil {
		return m.Cross
	}
	return nil
}

func (m *Input) GetUnion() []*Input {
	if m != nil {
		return m.Union
	}
	return nil
}

func (m *Input) GetCron() *CronInput {
	if m != nil {
		return m.Cron
	}
	return nil
}

type JobInput struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Commit               *pfs.Commit `protobuf:"bytes,2,opt,name=commit,proto3" json:"commit,omitempty"`
	Glob                 string      `protobuf:"bytes,3,opt,name=glob,proto3" json:"glob,omitempty"`
	Lazy                 bool        `protobuf:"varint,4,opt,name=lazy,proto3" json:"lazy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *JobInput) Reset()         { *m = JobInput{} }
func (m *JobInput) String() string { return proto.CompactTextString(m) }
func (*JobInput) ProtoMessage()    {}
func (*JobInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{11}
}
func (m *JobInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInput.Merge(m, src)
}
func (m *JobInput) XXX_Size() int {
	return m.Size()
}
func (m *JobInput) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInput.DiscardUnknown(m)
}

var xxx_messageInfo_JobInput proto.InternalMessageInfo

func (m *JobInput) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *JobInput) GetCommit() *pfs.Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *JobInput) GetGlob() string {
	if m != nil {
		return m.Glob
	}
	return ""
}

func (m *JobInput) GetLazy() bool {
	if m != nil {
		return m.Lazy
	}
	return false
}

type ParallelismSpec struct {
	// Starts the pipeline/job with a 'constant' workers, unless 'constant' is
	// zero. If 'constant' is zero (which is the zero value of ParallelismSpec),
	// then Pachyderm will choose the number of workers that is started,
	// (currently it chooses the number of workers in the cluster)
	Constant             uint64   `protobuf:"varint,1,opt,name=constant,proto3" json:"constant,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ParallelismSpec) Reset()         { *m = ParallelismSpec{} }
func (m *ParallelismSpec) String() string { return proto.CompactTextString(m) }
func (*ParallelismSpec) ProtoMessage()    {}
func (*ParallelismSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{12}
}
func (m *ParallelismSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParallelismSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParallelismSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParallelismSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParallelismSpec.Merge(m, src)
}
func (m *ParallelismSpec) XXX_Size() int {
	return m.Size()
}
func (m *ParallelismSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ParallelismSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ParallelismSpec proto.InternalMessageInfo

func (m *ParallelismSpec) GetConstant() uint64 {
	if m != nil {
		return m.Constant
	}
	return 0
}

type InputFile struct {
	// This file's absolute path within its pfs repo.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// This file's hash
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InputFile) Reset()         { *m = InputFile{} }
func (m *InputFile) String() string { return proto.CompactTextString(m) }
func (*InputFile) ProtoMessage()    {}
func (*InputFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{13}
}
func (m *InputFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InputFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InputFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InputFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InputFile.Merge(m, src)
}
func (m *InputFile) XXX_Size() int {
	return m.Size()
}
func (m *InputFile) XXX_DiscardUnknown() {
	xxx_messageInfo_InputFile.DiscardUnknown(m)
}

var xxx_messageInfo_InputFile proto.InternalMessageInfo

func (m *InputFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *InputFile) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Datum struct {
	// ID is the hash computed from all the files
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	ID                   string   `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Datum) Reset()         { *m = Datum{} }
func (m *Datum) String() string { return proto.CompactTextString(m) }
func (*Datum) ProtoMessage()    {}
func (*Datum) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{14}
}
func (m *Datum) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Datum) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Datum.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Datum) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Datum.Merge(m, src)
}
func (m *Datum) XXX_Size() int {
	return m.Size()
}
func (m *Datum) XXX_DiscardUnknown() {
	xxx_messageInfo_Datum.DiscardUnknown(m)
}

var xxx_messageInfo_Datum proto.InternalMessageInfo

func (m *Datum) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *Datum) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type DatumInfo struct {
	Datum                *Datum          `protobuf:"bytes,1,opt,name=datum,proto3" json:"datum,omitempty"`
	State                DatumState      `protobuf:"varint,2,opt,name=state,proto3,enum=pps_v2.DatumState" json:"state,omitempty"`
	Stats                *ProcessStats   `protobuf:"bytes,3,opt,name=stats,proto3" json:"stats,omitempty"`
	PfsState             *pfs.File       `protobuf:"bytes,4,opt,name=pfs_state,json=pfsState,proto3" json:"pfs_state,omitempty"`
	Data                 []*pfs.FileInfo `protobuf:"bytes,5,rep,name=data,proto3" json:"data,omitempty"`
	ImageId              string          `protobuf:"bytes,6,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DatumInfo) Reset()         { *m = DatumInfo{} }
func (m *DatumInfo) String() string { return proto.CompactTextString(m) }
func (*DatumInfo) ProtoMessage()    {}
func (*DatumInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{15}
}
func (m *DatumInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatumInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatumInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatumInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatumInfo.Merge(m, src)
}
func (m *DatumInfo) XXX_Size() int {
	return m.Size()
}
func (m *DatumInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DatumInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DatumInfo proto.InternalMessageInfo

func (m *DatumInfo) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *DatumInfo) GetState() DatumState {
	if m != nil {
		return m.State
	}
	return DatumState_UNKNOWN
}

func (m *DatumInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *DatumInfo) GetPfsState() *pfs.File {
	if m != nil {
		return m.PfsState
	}
	return nil
}

func (m *DatumInfo) GetData() []*pfs.FileInfo {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *DatumInfo) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

type Aggregate struct {
	Count                 int64    `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Mean                  float64  `protobuf:"fixed64,2,opt,name=mean,proto3" json:"mean,omitempty"`
	Stddev                float64  `protobuf:"fixed64,3,opt,name=stddev,proto3" json:"stddev,omitempty"`
	FifthPercentile       float64  `protobuf:"fixed64,4,opt,name=fifth_percentile,json=fifthPercentile,proto3" json:"fifth_percentile,omitempty"`
	NinetyFifthPercentile float64  `protobuf:"fixed64,5,opt,name=ninety_fifth_percentile,json=ninetyFifthPercentile,proto3" json:"ninety_fifth_percentile,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *Aggregate) Reset()         { *m = Aggregate{} }
func (m *Aggregate) String() string { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()    {}
func (*Aggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{16}
}
func (m *Aggregate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Aggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregate.Merge(m, src)
}
func (m *Aggregate) XXX_Size() int {
	return m.Size()
}
func (m *Aggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregate.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Aggregate) GetMean() float64 {
	if m != nil {
		return m.Mean
	}
	return 0
}

func (m *Aggregate) GetStddev() float64 {
	if m != nil {
		return m.Stddev
	}
	return 0
}

func (m *Aggregate) GetFifthPercentile() float64 {
	if m != nil {
		return m.FifthPercentile
	}
	return 0
}

func (m *Aggregate) GetNinetyFifthPercentile() float64 {
	if m != nil {
		return m.NinetyFifthPercentile
	}
	return 0
}

type ProcessStats struct {
	DownloadTime         *types.Duration `protobuf:"bytes,1,opt,name=download_time,json=downloadTime,proto3" json:"download_time,omitempty"`
	ProcessTime          *types.Duration `protobuf:"bytes,2,opt,name=process_time,json=processTime,proto3" json:"process_time,omitempty"`
	UploadTime           *types.Duration `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	DownloadBytes        int64           `protobuf:"varint,4,opt,name=download_bytes,json=downloadBytes,proto3" json:"download_bytes,omitempty"`
	UploadBytes          int64           `protobuf:"varint,5,opt,name=upload_bytes,json=uploadBytes,proto3" json:"upload_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ProcessStats) Reset()         { *m = ProcessStats{} }
func (m *ProcessStats) String() string { return proto.CompactTextString(m) }
func (*ProcessStats) ProtoMessage()    {}
func (*ProcessStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{17}
}
func (m *ProcessStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProcessStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProcessStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProcessStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProcessStats.Merge(m, src)
}
func (m *ProcessStats) XXX_Size() int {
	return m.Size()
}
func (m *ProcessStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ProcessStats.DiscardUnknown(m)
}

var xxx_messageInfo_ProcessStats proto.InternalMessageInfo

func (m *ProcessStats) GetDownloadTime() *types.Duration {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *ProcessStats) GetProcessTime() *types.Duration {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *ProcessStats) GetUploadTime() *types.Duration {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *ProcessStats) GetDownloadBytes() int64 {
	if m != nil {
		return m.DownloadBytes
	}
	return 0
}

func (m *ProcessStats) GetUploadBytes() int64 {
	if m != nil {
		return m.UploadBytes
	}
	return 0
}

type AggregateProcessStats struct {
	DownloadTime         *Aggregate `protobuf:"bytes,1,opt,name=download_time,json=downloadTime,proto3" json:"download_time,omitempty"`
	ProcessTime          *Aggregate `protobuf:"bytes,2,opt,name=process_time,json=processTime,proto3" json:"process_time,omitempty"`
	UploadTime           *Aggregate `protobuf:"bytes,3,opt,name=upload_time,json=uploadTime,proto3" json:"upload_time,omitempty"`
	DownloadBytes        *Aggregate `protobuf:"bytes,4,opt,name=download_bytes,json=downloadBytes,proto3" json:"download_bytes,omitempty"`
	UploadBytes          *Aggregate `protobuf:"bytes,5,opt,name=upload_bytes,json=uploadBytes,proto3" json:"upload_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *AggregateProcessStats) Reset()         { *m = AggregateProcessStats{} }
func (m *AggregateProcessStats) String() string { return proto.CompactTextString(m) }
func (*AggregateProcessStats) ProtoMessage()    {}
func (*AggregateProcessStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{18}
}
func (m *AggregateProcessStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AggregateProcessStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AggregateProcessStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AggregateProcessStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AggregateProcessStats.Merge(m, src)
}
func (m *AggregateProcessStats) XXX_Size() int {
	return m.Size()
}
func (m *AggregateProcessStats) XXX_DiscardUnknown() {
	xxx_messageInfo_AggregateProcessStats.DiscardUnknown(m)
}

var xxx_messageInfo_AggregateProcessStats proto.InternalMessageInfo

func (m *AggregateProcessStats) GetDownloadTime() *Aggregate {
	if m != nil {
		return m.DownloadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetProcessTime() *Aggregate {
	if m != nil {
		return m.ProcessTime
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadTime() *Aggregate {
	if m != nil {
		return m.UploadTime
	}
	return nil
}

func (m *AggregateProcessStats) GetDownloadBytes() *Aggregate {
	if m != nil {
		return m.DownloadBytes
	}
	return nil
}

func (m *AggregateProcessStats) GetUploadBytes() *Aggregate {
	if m != nil {
		return m.UploadBytes
	}
	return nil
}

type WorkerStatus struct {
	WorkerID             string       `protobuf:"bytes,1,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	JobID                string       `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	DatumStatus          *DatumStatus `protobuf:"bytes,3,opt,name=datum_status,json=datumStatus,proto3" json:"datum_status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *WorkerStatus) Reset()         { *m = WorkerStatus{} }
func (m *WorkerStatus) String() string { return proto.CompactTextString(m) }
func (*WorkerStatus) ProtoMessage()    {}
func (*WorkerStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{19}
}
func (m *WorkerStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WorkerStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WorkerStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WorkerStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WorkerStatus.Merge(m, src)
}
func (m *WorkerStatus) XXX_Size() int {
	return m.Size()
}
func (m *WorkerStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_WorkerStatus.DiscardUnknown(m)
}

var xxx_messageInfo_WorkerStatus proto.InternalMessageInfo

func (m *WorkerStatus) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *WorkerStatus) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *WorkerStatus) GetDatumStatus() *DatumStatus {
	if m != nil {
		return m.DatumStatus
	}
	return nil
}

type DatumStatus struct {
	// Started is the time processing on the current datum began.
	Started              *types.Timestamp `protobuf:"bytes,1,opt,name=started,proto3" json:"started,omitempty"`
	Data                 []*InputFile     `protobuf:"bytes,2,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *DatumStatus) Reset()         { *m = DatumStatus{} }
func (m *DatumStatus) String() string { return proto.CompactTextString(m) }
func (*DatumStatus) ProtoMessage()    {}
func (*DatumStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{20}
}
func (m *DatumStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatumStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatumStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatumStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatumStatus.Merge(m, src)
}
func (m *DatumStatus) XXX_Size() int {
	return m.Size()
}
func (m *DatumStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DatumStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DatumStatus proto.InternalMessageInfo

func (m *DatumStatus) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *DatumStatus) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

// ResourceSpec describes the amount of resources that pipeline pods should
// request from kubernetes, for scheduling.
type ResourceSpec struct {
	// The number of CPUs each worker needs (partial values are allowed, and
	// encouraged)
	Cpu float32 `protobuf:"fixed32,1,opt,name=cpu,proto3" json:"cpu,omitempty"`
	// The amount of memory each worker needs (in bytes, with allowed
	// SI suffixes (M, K, G, Mi, Ki, Gi, etc).
	Memory string `protobuf:"bytes,2,opt,name=memory,proto3" json:"memory,omitempty"`
	// The spec for GPU resources.
	Gpu *GPUSpec `protobuf:"bytes,3,opt,name=gpu,proto3" json:"gpu,omitempty"`
	// The amount of ephemeral storage each worker needs (in bytes, with allowed
	// SI suffixes (M, K, G, Mi, Ki, Gi, etc).
	Disk                 string   `protobuf:"bytes,4,opt,name=disk,proto3" json:"disk,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceSpec) Reset()         { *m = ResourceSpec{} }
func (m *ResourceSpec) String() string { return proto.CompactTextString(m) }
func (*ResourceSpec) ProtoMessage()    {}
func (*ResourceSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{21}
}
func (m *ResourceSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceSpec.Merge(m, src)
}
func (m *ResourceSpec) XXX_Size() int {
	return m.Size()
}
func (m *ResourceSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceSpec.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceSpec proto.InternalMessageInfo

func (m *ResourceSpec) GetCpu() float32 {
	if m != nil {
		return m.Cpu
	}
	return 0
}

func (m *ResourceSpec) GetMemory() string {
	if m != nil {
		return m.Memory
	}
	return ""
}

func (m *ResourceSpec) GetGpu() *GPUSpec {
	if m != nil {
		return m.Gpu
	}
	return nil
}

func (m *ResourceSpec) GetDisk() string {
	if m != nil {
		return m.Disk
	}
	return ""
}

type GPUSpec struct {
	// The type of GPU (nvidia.com/gpu or amd.com/gpu for example).
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// The number of GPUs to request.
	Number               int64    `protobuf:"varint,2,opt,name=number,proto3" json:"number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GPUSpec) Reset()         { *m = GPUSpec{} }
func (m *GPUSpec) String() string { return proto.CompactTextString(m) }
func (*GPUSpec) ProtoMessage()    {}
func (*GPUSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{22}
}
func (m *GPUSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GPUSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GPUSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GPUSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GPUSpec.Merge(m, src)
}
func (m *GPUSpec) XXX_Size() int {
	return m.Size()
}
func (m *GPUSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_GPUSpec.DiscardUnknown(m)
}

var xxx_messageInfo_GPUSpec proto.InternalMessageInfo

func (m *GPUSpec) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *GPUSpec) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

type JobSetInfo struct {
	JobSet               *JobSet    `protobuf:"bytes,1,opt,name=job_set,json=jobSet,proto3" json:"job_set,omitempty"`
	Jobs                 []*JobInfo `protobuf:"bytes,2,rep,name=jobs,proto3" json:"jobs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *JobSetInfo) Reset()         { *m = JobSetInfo{} }
func (m *JobSetInfo) String() string { return proto.CompactTextString(m) }
func (*JobSetInfo) ProtoMessage()    {}
func (*JobSetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{23}
}
func (m *JobSetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSetInfo.Merge(m, src)
}
func (m *JobSetInfo) XXX_Size() int {
	return m.Size()
}
func (m *JobSetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobSetInfo proto.InternalMessageInfo

func (m *JobSetInfo) GetJobSet() *JobSet {
	if m != nil {
		return m.JobSet
	}
	return nil
}

func (m *JobSetInfo) GetJobs() []*JobInfo {
	if m != nil {
		return m.Jobs
	}
	return nil
}

// JobInfo is the data stored in the database regarding a given job.  The
// 'details' field contains more information about the job which is expensive to
// fetch, requiring querying workers or loading the pipeline spec from object
// storage.
type JobInfo struct {
	Job             *Job        `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	PipelineVersion uint64      `protobuf:"varint,2,opt,name=pipeline_version,json=pipelineVersion,proto3" json:"pipeline_version,omitempty"`
	OutputCommit    *pfs.Commit `protobuf:"bytes,3,opt,name=output_commit,json=outputCommit,proto3" json:"output_commit,omitempty"`
	// Job restart count (e.g. due to datum failure)
	Restart uint64 `protobuf:"varint,4,opt,name=restart,proto3" json:"restart,omitempty"`
	// Counts of how many times we processed or skipped a datum
	DataProcessed int64 `protobuf:"varint,5,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped   int64 `protobuf:"varint,6,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataTotal     int64 `protobuf:"varint,7,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	DataFailed    int64 `protobuf:"varint,8,opt,name=data_failed,json=dataFailed,proto3" json:"data_failed,omitempty"`
	DataRecovered int64 `protobuf:"varint,9,opt,name=data_recovered,json=dataRecovered,proto3" json:"data_recovered,omitempty"`
	// Download/process/upload time and download/upload bytes
	Stats                *ProcessStats    `protobuf:"bytes,10,opt,name=stats,proto3" json:"stats,omitempty"`
	State                JobState         `protobuf:"varint,11,opt,name=state,proto3,enum=pps_v2.JobState" json:"state,omitempty"`
	Reason               string           `protobuf:"bytes,12,opt,name=reason,proto3" json:"reason,omitempty"`
	Created              *types.Timestamp `protobuf:"bytes,13,opt,name=created,proto3" json:"created,omitempty"`
	Started              *types.Timestamp `protobuf:"bytes,14,opt,name=started,proto3" json:"started,omitempty"`
	Finished             *types.Timestamp `protobuf:"bytes,15,opt,name=finished,proto3" json:"finished,omitempty"`
	Details              *JobInfo_Details `protobuf:"bytes,16,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *JobInfo) Reset()         { *m = JobInfo{} }
func (m *JobInfo) String() string { return proto.CompactTextString(m) }
func (*JobInfo) ProtoMessage()    {}
func (*JobInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{24}
}
func (m *JobInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInfo.Merge(m, src)
}
func (m *JobInfo) XXX_Size() int {
	return m.Size()
}
func (m *JobInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInfo.DiscardUnknown(m)
}

var xxx_messageInfo_JobInfo proto.InternalMessageInfo

func (m *JobInfo) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *JobInfo) GetPipelineVersion() uint64 {
	if m != nil {
		return m.PipelineVersion
	}
	return 0
}

func (m *JobInfo) GetOutputCommit() *pfs.Commit {
	if m != nil {
		return m.OutputCommit
	}
	return nil
}

func (m *JobInfo) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *JobInfo) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *JobInfo) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *JobInfo) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *JobInfo) GetDataFailed() int64 {
	if m != nil {
		return m.DataFailed
	}
	return 0
}

func (m *JobInfo) GetDataRecovered() int64 {
	if m != nil {
		return m.DataRecovered
	}
	return 0
}

func (m *JobInfo) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

func (m *JobInfo) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STATE_UNKNOWN
}

func (m *JobInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *JobInfo) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *JobInfo) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *JobInfo) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *JobInfo) GetDetails() *JobInfo_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

type JobInfo_Details struct {
	Transform             *Transform       `protobuf:"bytes,1,opt,name=transform,proto3" json:"transform,omitempty"`
	ParallelismSpec       *ParallelismSpec `protobuf:"bytes,2,opt,name=parallelism_spec,json=parallelismSpec,proto3" json:"parallelism_spec,omitempty"`
	Egress                *Egress          `protobuf:"bytes,3,opt,name=egress,proto3" json:"egress,omitempty"`
	Service               *Service         `protobuf:"bytes,4,opt,name=service,proto3" json:"service,omitempty"`
	Spout                 *Spout           `protobuf:"bytes,5,opt,name=spout,proto3" json:"spout,omitempty"`
	WorkerStatus          []*WorkerStatus  `protobuf:"bytes,6,rep,name=worker_status,json=workerStatus,proto3" json:"worker_status,omitempty"`
	ResourceRequests      *ResourceSpec    `protobuf:"bytes,7,opt,name=resource_requests,json=resourceRequests,proto3" json:"resource_requests,omitempty"`
	ResourceLimits        *ResourceSpec    `protobuf:"bytes,8,opt,name=resource_limits,json=resourceLimits,proto3" json:"resource_limits,omitempty"`
	SidecarResourceLimits *ResourceSpec    `protobuf:"bytes,9,opt,name=sidecar_resource_limits,json=sidecarResourceLimits,proto3" json:"sidecar_resource_limits,omitempty"`
	Input                 *Input           `protobuf:"bytes,10,opt,name=input,proto3" json:"input,omitempty"`
	Salt                  string           `protobuf:"bytes,11,opt,name=salt,proto3" json:"salt,omitempty"`
	DatumSetSpec          *DatumSetSpec    `protobuf:"bytes,12,opt,name=datum_set_spec,json=datumSetSpec,proto3" json:"datum_set_spec,omitempty"`
	DatumTimeout          *types.Duration  `protobuf:"bytes,13,opt,name=datum_timeout,json=datumTimeout,proto3" json:"datum_timeout,omitempty"`
	JobTimeout            *types.Duration  `protobuf:"bytes,14,opt,name=job_timeout,json=jobTimeout,proto3" json:"job_timeout,omitempty"`
	DatumTries            int64            `protobuf:"varint,15,opt,name=datum_tries,json=datumTries,proto3" json:"datum_tries,omitempty"`
	SchedulingSpec        *SchedulingSpec  `protobuf:"bytes,16,opt,name=scheduling_spec,json=schedulingSpec,proto3" json:"scheduling_spec,omitempty"`
	PodSpec               string           `protobuf:"bytes,17,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	PodPatch              string           `protobuf:"bytes,18,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}         `json:"-"`
	XXX_unrecognized      []byte           `json:"-"`
	XXX_sizecache         int32            `json:"-"`
}

func (m *JobInfo_Details) Reset()         { *m = JobInfo_Details{} }
func (m *JobInfo_Details) String() string { return proto.CompactTextString(m) }
func (*JobInfo_Details) ProtoMessage()    {}
func (*JobInfo_Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{24, 0}
}
func (m *JobInfo_Details) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobInfo_Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobInfo_Details.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobInfo_Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobInfo_Details.Merge(m, src)
}
func (m *JobInfo_Details) XXX_Size() int {
	return m.Size()
}
func (m *JobInfo_Details) XXX_DiscardUnknown() {
	xxx_messageInfo_JobInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_JobInfo_Details proto.InternalMessageInfo

func (m *JobInfo_Details) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *JobInfo_Details) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *JobInfo_Details) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *JobInfo_Details) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *JobInfo_Details) GetSpout() *Spout {
	if m != nil {
		return m.Spout
	}
	return nil
}

func (m *JobInfo_Details) GetWorkerStatus() []*WorkerStatus {
	if m != nil {
		return m.WorkerStatus
	}
	return nil
}

func (m *JobInfo_Details) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *JobInfo_Details) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *JobInfo_Details) GetSidecarResourceLimits() *ResourceSpec {
	if m != nil {
		return m.SidecarResourceLimits
	}
	return nil
}

func (m *JobInfo_Details) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *JobInfo_Details) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *JobInfo_Details) GetDatumSetSpec() *DatumSetSpec {
	if m != nil {
		return m.DatumSetSpec
	}
	return nil
}

func (m *JobInfo_Details) GetDatumTimeout() *types.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *JobInfo_Details) GetJobTimeout() *types.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *JobInfo_Details) GetDatumTries() int64 {
	if m != nil {
		return m.DatumTries
	}
	return 0
}

func (m *JobInfo_Details) GetSchedulingSpec() *SchedulingSpec {
	if m != nil {
		return m.SchedulingSpec
	}
	return nil
}

func (m *JobInfo_Details) GetPodSpec() string {
	if m != nil {
		return m.PodSpec
	}
	return ""
}

func (m *JobInfo_Details) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

type Worker struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State                WorkerState `protobuf:"varint,2,opt,name=state,proto3,enum=pps_v2.WorkerState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Worker) Reset()         { *m = Worker{} }
func (m *Worker) String() string { return proto.CompactTextString(m) }
func (*Worker) ProtoMessage()    {}
func (*Worker) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{25}
}
func (m *Worker) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Worker) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Worker.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Worker) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Worker.Merge(m, src)
}
func (m *Worker) XXX_Size() int {
	return m.Size()
}
func (m *Worker) XXX_DiscardUnknown() {
	xxx_messageInfo_Worker.DiscardUnknown(m)
}

var xxx_messageInfo_Worker proto.InternalMessageInfo

func (m *Worker) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Worker) GetState() WorkerState {
	if m != nil {
		return m.State
	}
	return WorkerState_WORKER_STATE_UNKNOWN
}

type Pipeline struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pipeline) Reset()         { *m = Pipeline{} }
func (m *Pipeline) String() string { return proto.CompactTextString(m) }
func (*Pipeline) ProtoMessage()    {}
func (*Pipeline) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{26}
}
func (m *Pipeline) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pipeline) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pipeline.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pipeline) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pipeline.Merge(m, src)
}
func (m *Pipeline) XXX_Size() int {
	return m.Size()
}
func (m *Pipeline) XXX_DiscardUnknown() {
	xxx_messageInfo_Pipeline.DiscardUnknown(m)
}

var xxx_messageInfo_Pipeline proto.InternalMessageInfo

func (m *Pipeline) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// PipelineInfo is proto for each pipeline that Pachd stores in the
// database. It tracks the state of the pipeline, and points to its metadata in
// PFS (and, by pointing to a PFS commit, de facto tracks the pipeline's
// version).  Any information about the pipeline _not_ stored in the database is
// in the Details object, which requires fetching the spec from PFS or other
// potentially expensive operations.
type PipelineInfo struct {
	Pipeline   *Pipeline   `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	Version    uint64      `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	SpecCommit *pfs.Commit `protobuf:"bytes,3,opt,name=spec_commit,json=specCommit,proto3" json:"spec_commit,omitempty"`
	Stopped    bool        `protobuf:"varint,4,opt,name=stopped,proto3" json:"stopped,omitempty"`
	// state indicates the current state of the pipeline
	State PipelineState `protobuf:"varint,5,opt,name=state,proto3,enum=pps_v2.PipelineState" json:"state,omitempty"`
	// reason includes any error messages associated with a failed pipeline
	Reason string `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason,omitempty"`
	// last_job_state indicates the state of the most recently created job
	LastJobState JobState `protobuf:"varint,8,opt,name=last_job_state,json=lastJobState,proto3,enum=pps_v2.JobState" json:"last_job_state,omitempty"`
	// parallelism tracks the literal number of workers that this pipeline should
	// run.
	Parallelism          uint64                    `protobuf:"varint,9,opt,name=parallelism,proto3" json:"parallelism,omitempty"`
	Type                 PipelineInfo_PipelineType `protobuf:"varint,10,opt,name=type,proto3,enum=pps_v2.PipelineInfo_PipelineType" json:"type,omitempty"`
	AuthToken            string                    `protobuf:"bytes,11,opt,name=auth_token,json=authToken,proto3" json:"auth_token,omitempty"`
	Details              *PipelineInfo_Details     `protobuf:"bytes,12,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *PipelineInfo) Reset()         { *m = PipelineInfo{} }
func (m *PipelineInfo) String() string { return proto.CompactTextString(m) }
func (*PipelineInfo) ProtoMessage()    {}
func (*PipelineInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{27}
}
func (m *PipelineInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineInfo.Merge(m, src)
}
func (m *PipelineInfo) XXX_Size() int {
	return m.Size()
}
func (m *PipelineInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineInfo proto.InternalMessageInfo

func (m *PipelineInfo) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *PipelineInfo) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *PipelineInfo) GetSpecCommit() *pfs.Commit {
	if m != nil {
		return m.SpecCommit
	}
	return nil
}

func (m *PipelineInfo) GetStopped() bool {
	if m != nil {
		return m.Stopped
	}
	return false
}

func (m *PipelineInfo) GetState() PipelineState {
	if m != nil {
		return m.State
	}
	return PipelineState_PIPELINE_STATE_UNKNOWN
}

func (m *PipelineInfo) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PipelineInfo) GetLastJobState() JobState {
	if m != nil {
		return m.LastJobState
	}
	return JobState_JOB_STATE_UNKNOWN
}

func (m *PipelineInfo) GetParallelism() uint64 {
	if m != nil {
		return m.Parallelism
	}
	return 0
}

func (m *PipelineInfo) GetType() PipelineInfo_PipelineType {
	if m != nil {
		return m.Type
	}
	return PipelineInfo_PIPELINT_TYPE_UNKNOWN
}

func (m *PipelineInfo) GetAuthToken() string {
	if m != nil {
		return m.AuthToken
	}
	return ""
}

func (m *PipelineInfo) GetDetails() *PipelineInfo_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

type PipelineInfo_Details struct {
	Transform *Transform `protobuf:"bytes,1,opt,name=transform,proto3" json:"transform,omitempty"`
	// tf_job encodes a Kubeflow TFJob spec. Pachyderm uses this to create TFJobs
	// when running in a kubernetes cluster on which kubeflow has been installed.
	// Exactly one of 'tf_job' and 'transform' should be set
	TFJob                 *TFJob           `protobuf:"bytes,2,opt,name=tf_job,json=tfJob,proto3" json:"tf_job,omitempty"`
	ParallelismSpec       *ParallelismSpec `protobuf:"bytes,3,opt,name=parallelism_spec,json=parallelismSpec,proto3" json:"parallelism_spec,omitempty"`
	Egress                *Egress          `protobuf:"bytes,4,opt,name=egress,proto3" json:"egress,omitempty"`
	CreatedAt             *types.Timestamp `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	RecentError           string           `protobuf:"bytes,6,opt,name=recent_error,json=recentError,proto3" json:"recent_error,omitempty"`
	WorkersRequested      int64            `protobuf:"varint,7,opt,name=workers_requested,json=workersRequested,proto3" json:"workers_requested,omitempty"`
	WorkersAvailable      int64            `protobuf:"varint,8,opt,name=workers_available,json=workersAvailable,proto3" json:"workers_available,omitempty"`
	OutputBranch          string           `protobuf:"bytes,9,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	ResourceRequests      *ResourceSpec    `protobuf:"bytes,10,opt,name=resource_requests,json=resourceRequests,proto3" json:"resource_requests,omitempty"`
	ResourceLimits        *ResourceSpec    `protobuf:"bytes,11,opt,name=resource_limits,json=resourceLimits,proto3" json:"resource_limits,omitempty"`
	SidecarResourceLimits *ResourceSpec    `protobuf:"bytes,12,opt,name=sidecar_resource_limits,json=sidecarResourceLimits,proto3" json:"sidecar_resource_limits,omitempty"`
	Input                 *Input           `protobuf:"bytes,13,opt,name=input,proto3" json:"input,omitempty"`
	Description           string           `protobuf:"bytes,14,opt,name=description,proto3" json:"description,omitempty"`
	Salt                  string           `protobuf:"bytes,16,opt,name=salt,proto3" json:"salt,omitempty"`
	Reason                string           `protobuf:"bytes,17,opt,name=reason,proto3" json:"reason,omitempty"`
	Service               *Service         `protobuf:"bytes,19,opt,name=service,proto3" json:"service,omitempty"`
	Spout                 *Spout           `protobuf:"bytes,20,opt,name=spout,proto3" json:"spout,omitempty"`
	DatumSetSpec          *DatumSetSpec    `protobuf:"bytes,21,opt,name=datum_set_spec,json=datumSetSpec,proto3" json:"datum_set_spec,omitempty"`
	DatumTimeout          *types.Duration  `protobuf:"bytes,22,opt,name=datum_timeout,json=datumTimeout,proto3" json:"datum_timeout,omitempty"`
	JobTimeout            *types.Duration  `protobuf:"bytes,23,opt,name=job_timeout,json=jobTimeout,proto3" json:"job_timeout,omitempty"`
	DatumTries            int64            `protobuf:"varint,24,opt,name=datum_tries,json=datumTries,proto3" json:"datum_tries,omitempty"`
	SchedulingSpec        *SchedulingSpec  `protobuf:"bytes,25,opt,name=scheduling_spec,json=schedulingSpec,proto3" json:"scheduling_spec,omitempty"`
	PodSpec               string           `protobuf:"bytes,26,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	PodPatch              string           `protobuf:"bytes,27,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	S3Out                 bool             `protobuf:"varint,28,opt,name=s3_out,json=s3Out,proto3" json:"s3_out,omitempty"`
	Metadata              *Metadata        `protobuf:"bytes,29,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ReprocessSpec         string           `protobuf:"bytes,30,opt,name=reprocess_spec,json=reprocessSpec,proto3" json:"reprocess_spec,omitempty"`
	UnclaimedTasks        int64            `protobuf:"varint,31,opt,name=unclaimed_tasks,json=unclaimedTasks,proto3" json:"unclaimed_tasks,omitempty"`
	WorkerRc              string           `protobuf:"bytes,32,opt,name=worker_rc,json=workerRc,proto3" json:"worker_rc,omitempty"`
	Autoscaling           bool             `protobuf:"varint,33,opt,name=autoscaling,proto3" json:"autoscaling,omitempty"`
	XXX_NoUnkeyedLiteral  struct{}         `json:"-"`
	XXX_unrecognized      []byte           `json:"-"`
	XXX_sizecache         int32            `json:"-"`
}

func (m *PipelineInfo_Details) Reset()         { *m = PipelineInfo_Details{} }
func (m *PipelineInfo_Details) String() string { return proto.CompactTextString(m) }
func (*PipelineInfo_Details) ProtoMessage()    {}
func (*PipelineInfo_Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{27, 0}
}
func (m *PipelineInfo_Details) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineInfo_Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineInfo_Details.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineInfo_Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineInfo_Details.Merge(m, src)
}
func (m *PipelineInfo_Details) XXX_Size() int {
	return m.Size()
}
func (m *PipelineInfo_Details) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineInfo_Details proto.InternalMessageInfo

func (m *PipelineInfo_Details) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *PipelineInfo_Details) GetTFJob() *TFJob {
	if m != nil {
		return m.TFJob
	}
	return nil
}

func (m *PipelineInfo_Details) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *PipelineInfo_Details) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *PipelineInfo_Details) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *PipelineInfo_Details) GetRecentError() string {
	if m != nil {
		return m.RecentError
	}
	return ""
}

func (m *PipelineInfo_Details) GetWorkersRequested() int64 {
	if m != nil {
		return m.WorkersRequested
	}
	return 0
}

func (m *PipelineInfo_Details) GetWorkersAvailable() int64 {
	if m != nil {
		return m.WorkersAvailable
	}
	return 0
}

func (m *PipelineInfo_Details) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *PipelineInfo_Details) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *PipelineInfo_Details) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *PipelineInfo_Details) GetSidecarResourceLimits() *ResourceSpec {
	if m != nil {
		return m.SidecarResourceLimits
	}
	return nil
}

func (m *PipelineInfo_Details) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *PipelineInfo_Details) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PipelineInfo_Details) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *PipelineInfo_Details) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *PipelineInfo_Details) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *PipelineInfo_Details) GetSpout() *Spout {
	if m != nil {
		return m.Spout
	}
	return nil
}

func (m *PipelineInfo_Details) GetDatumSetSpec() *DatumSetSpec {
	if m != nil {
		return m.DatumSetSpec
	}
	return nil
}

func (m *PipelineInfo_Details) GetDatumTimeout() *types.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *PipelineInfo_Details) GetJobTimeout() *types.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *PipelineInfo_Details) GetDatumTries() int64 {
	if m != nil {
		return m.DatumTries
	}
	return 0
}

func (m *PipelineInfo_Details) GetSchedulingSpec() *SchedulingSpec {
	if m != nil {
		return m.SchedulingSpec
	}
	return nil
}

func (m *PipelineInfo_Details) GetPodSpec() string {
	if m != nil {
		return m.PodSpec
	}
	return ""
}

func (m *PipelineInfo_Details) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

func (m *PipelineInfo_Details) GetS3Out() bool {
	if m != nil {
		return m.S3Out
	}
	return false
}

func (m *PipelineInfo_Details) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *PipelineInfo_Details) GetReprocessSpec() string {
	if m != nil {
		return m.ReprocessSpec
	}
	return ""
}

func (m *PipelineInfo_Details) GetUnclaimedTasks() int64 {
	if m != nil {
		return m.UnclaimedTasks
	}
	return 0
}

func (m *PipelineInfo_Details) GetWorkerRc() string {
	if m != nil {
		return m.WorkerRc
	}
	return ""
}

func (m *PipelineInfo_Details) GetAutoscaling() bool {
	if m != nil {
		return m.Autoscaling
	}
	return false
}

type PipelineInfos struct {
	PipelineInfo         []*PipelineInfo `protobuf:"bytes,1,rep,name=pipeline_info,json=pipelineInfo,proto3" json:"pipeline_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PipelineInfos) Reset()         { *m = PipelineInfos{} }
func (m *PipelineInfos) String() string { return proto.CompactTextString(m) }
func (*PipelineInfos) ProtoMessage()    {}
func (*PipelineInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{28}
}
func (m *PipelineInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PipelineInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PipelineInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PipelineInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PipelineInfos.Merge(m, src)
}
func (m *PipelineInfos) XXX_Size() int {
	return m.Size()
}
func (m *PipelineInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_PipelineInfos.DiscardUnknown(m)
}

var xxx_messageInfo_PipelineInfos proto.InternalMessageInfo

func (m *PipelineInfos) GetPipelineInfo() []*PipelineInfo {
	if m != nil {
		return m.PipelineInfo
	}
	return nil
}

type JobSet struct {
	ID                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JobSet) Reset()         { *m = JobSet{} }
func (m *JobSet) String() string { return proto.CompactTextString(m) }
func (*JobSet) ProtoMessage()    {}
func (*JobSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{29}
}
func (m *JobSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobSet.Merge(m, src)
}
func (m *JobSet) XXX_Size() int {
	return m.Size()
}
func (m *JobSet) XXX_DiscardUnknown() {
	xxx_messageInfo_JobSet.DiscardUnknown(m)
}

var xxx_messageInfo_JobSet proto.InternalMessageInfo

func (m *JobSet) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type InspectJobSetRequest struct {
	JobSet               *JobSet  `protobuf:"bytes,1,opt,name=job_set,json=jobSet,proto3" json:"job_set,omitempty"`
	Wait                 bool     `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Details              bool     `protobuf:"varint,3,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectJobSetRequest) Reset()         { *m = InspectJobSetRequest{} }
func (m *InspectJobSetRequest) String() string { return proto.CompactTextString(m) }
func (*InspectJobSetRequest) ProtoMessage()    {}
func (*InspectJobSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{30}
}
func (m *InspectJobSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectJobSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectJobSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectJobSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectJobSetRequest.Merge(m, src)
}
func (m *InspectJobSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectJobSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectJobSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectJobSetRequest proto.InternalMessageInfo

func (m *InspectJobSetRequest) GetJobSet() *JobSet {
	if m != nil {
		return m.JobSet
	}
	return nil
}

func (m *InspectJobSetRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *InspectJobSetRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

type ListJobSetRequest struct {
	Details              bool     `protobuf:"varint,1,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListJobSetRequest) Reset()         { *m = ListJobSetRequest{} }
func (m *ListJobSetRequest) String() string { return proto.CompactTextString(m) }
func (*ListJobSetRequest) ProtoMessage()    {}
func (*ListJobSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{31}
}
func (m *ListJobSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJobSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJobSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListJobSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJobSetRequest.Merge(m, src)
}
func (m *ListJobSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListJobSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJobSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListJobSetRequest proto.InternalMessageInfo

func (m *ListJobSetRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

type InspectJobRequest struct {
	// Callers should set either Job or OutputCommit, not both.
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	Wait                 bool     `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	Details              bool     `protobuf:"varint,3,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectJobRequest) Reset()         { *m = InspectJobRequest{} }
func (m *InspectJobRequest) String() string { return proto.CompactTextString(m) }
func (*InspectJobRequest) ProtoMessage()    {}
func (*InspectJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{32}
}
func (m *InspectJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectJobRequest.Merge(m, src)
}
func (m *InspectJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectJobRequest proto.InternalMessageInfo

func (m *InspectJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *InspectJobRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

func (m *InspectJobRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

type ListJobRequest struct {
	Pipeline    *Pipeline     `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	InputCommit []*pfs.Commit `protobuf:"bytes,2,rep,name=input_commit,json=inputCommit,proto3" json:"input_commit,omitempty"`
	// History indicates return jobs from historical versions of pipelines
	// semantics are:
	// 0: Return jobs from the current version of the pipeline or pipelines.
	// 1: Return the above and jobs from the next most recent version
	// 2: etc.
	//-1: Return jobs from all historical versions.
	History int64 `protobuf:"varint,4,opt,name=history,proto3" json:"history,omitempty"`
	// Details indicates whether the result should include all pipeline details in
	// each JobInfo, or limited information including name and status, but
	// excluding information in the pipeline spec. Leaving this "false" can make
	// the call significantly faster in clusters with a large number of pipelines
	// and jobs.
	// Note that if 'input_commit' is set, this field is coerced to "true"
	Details bool `protobuf:"varint,5,opt,name=details,proto3" json:"details,omitempty"`
	// A jq program string for additional result filtering
	JqFilter             string   `protobuf:"bytes,6,opt,name=jqFilter,proto3" json:"jqFilter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListJobRequest) Reset()         { *m = ListJobRequest{} }
func (m *ListJobRequest) String() string { return proto.CompactTextString(m) }
func (*ListJobRequest) ProtoMessage()    {}
func (*ListJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{33}
}
func (m *ListJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListJobRequest.Merge(m, src)
}
func (m *ListJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListJobRequest proto.InternalMessageInfo

func (m *ListJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *ListJobRequest) GetInputCommit() []*pfs.Commit {
	if m != nil {
		return m.InputCommit
	}
	return nil
}

func (m *ListJobRequest) GetHistory() int64 {
	if m != nil {
		return m.History
	}
	return 0
}

func (m *ListJobRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

func (m *ListJobRequest) GetJqFilter() string {
	if m != nil {
		return m.JqFilter
	}
	return ""
}

// Streams open jobs until canceled
type SubscribeJobRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	Details              bool      `protobuf:"varint,2,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *SubscribeJobRequest) Reset()         { *m = SubscribeJobRequest{} }
func (m *SubscribeJobRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeJobRequest) ProtoMessage()    {}
func (*SubscribeJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{34}
}
func (m *SubscribeJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeJobRequest.Merge(m, src)
}
func (m *SubscribeJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeJobRequest proto.InternalMessageInfo

func (m *SubscribeJobRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *SubscribeJobRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

type DeleteJobRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteJobRequest) Reset()         { *m = DeleteJobRequest{} }
func (m *DeleteJobRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteJobRequest) ProtoMessage()    {}
func (*DeleteJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{35}
}
func (m *DeleteJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteJobRequest.Merge(m, src)
}
func (m *DeleteJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteJobRequest proto.InternalMessageInfo

func (m *DeleteJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

type StopJobRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	Reason               string   `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StopJobRequest) Reset()         { *m = StopJobRequest{} }
func (m *StopJobRequest) String() string { return proto.CompactTextString(m) }
func (*StopJobRequest) ProtoMessage()    {}
func (*StopJobRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{36}
}
func (m *StopJobRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopJobRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopJobRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopJobRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopJobRequest.Merge(m, src)
}
func (m *StopJobRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopJobRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopJobRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopJobRequest proto.InternalMessageInfo

func (m *StopJobRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *StopJobRequest) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

type UpdateJobStateRequest struct {
	Job                  *Job          `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	State                JobState      `protobuf:"varint,2,opt,name=state,proto3,enum=pps_v2.JobState" json:"state,omitempty"`
	Reason               string        `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Restart              uint64        `protobuf:"varint,5,opt,name=restart,proto3" json:"restart,omitempty"`
	DataProcessed        int64         `protobuf:"varint,6,opt,name=data_processed,json=dataProcessed,proto3" json:"data_processed,omitempty"`
	DataSkipped          int64         `protobuf:"varint,7,opt,name=data_skipped,json=dataSkipped,proto3" json:"data_skipped,omitempty"`
	DataFailed           int64         `protobuf:"varint,8,opt,name=data_failed,json=dataFailed,proto3" json:"data_failed,omitempty"`
	DataRecovered        int64         `protobuf:"varint,9,opt,name=data_recovered,json=dataRecovered,proto3" json:"data_recovered,omitempty"`
	DataTotal            int64         `protobuf:"varint,10,opt,name=data_total,json=dataTotal,proto3" json:"data_total,omitempty"`
	Stats                *ProcessStats `protobuf:"bytes,11,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *UpdateJobStateRequest) Reset()         { *m = UpdateJobStateRequest{} }
func (m *UpdateJobStateRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateJobStateRequest) ProtoMessage()    {}
func (*UpdateJobStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{37}
}
func (m *UpdateJobStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateJobStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateJobStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateJobStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateJobStateRequest.Merge(m, src)
}
func (m *UpdateJobStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateJobStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateJobStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateJobStateRequest proto.InternalMessageInfo

func (m *UpdateJobStateRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *UpdateJobStateRequest) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_JOB_STATE_UNKNOWN
}

func (m *UpdateJobStateRequest) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *UpdateJobStateRequest) GetRestart() uint64 {
	if m != nil {
		return m.Restart
	}
	return 0
}

func (m *UpdateJobStateRequest) GetDataProcessed() int64 {
	if m != nil {
		return m.DataProcessed
	}
	return 0
}

func (m *UpdateJobStateRequest) GetDataSkipped() int64 {
	if m != nil {
		return m.DataSkipped
	}
	return 0
}

func (m *UpdateJobStateRequest) GetDataFailed() int64 {
	if m != nil {
		return m.DataFailed
	}
	return 0
}

func (m *UpdateJobStateRequest) GetDataRecovered() int64 {
	if m != nil {
		return m.DataRecovered
	}
	return 0
}

func (m *UpdateJobStateRequest) GetDataTotal() int64 {
	if m != nil {
		return m.DataTotal
	}
	return 0
}

func (m *UpdateJobStateRequest) GetStats() *ProcessStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

type GetLogsRequest struct {
	// The pipeline from which we want to get logs (required if the job in 'job'
	// was created as part of a pipeline. To get logs from a non-orphan job
	// without the pipeline that created it, you need to use ElasticSearch).
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	// The job from which we want to get logs.
	Job *Job `protobuf:"bytes,2,opt,name=job,proto3" json:"job,omitempty"`
	// Names of input files from which we want processing logs. This may contain
	// multiple files, to query pipelines that contain multiple inputs. Each
	// filter may be an absolute path of a file within a pps repo, or it may be
	// a hash for that file (to search for files at specific versions)
	DataFilters []string `protobuf:"bytes,3,rep,name=data_filters,json=dataFilters,proto3" json:"data_filters,omitempty"`
	Datum       *Datum   `protobuf:"bytes,4,opt,name=datum,proto3" json:"datum,omitempty"`
	// If true get logs from the master process
	Master bool `protobuf:"varint,5,opt,name=master,proto3" json:"master,omitempty"`
	// Continue to follow new logs as they become available.
	Follow bool `protobuf:"varint,6,opt,name=follow,proto3" json:"follow,omitempty"`
	// If nonzero, the number of lines from the end of the logs to return.  Note:
	// tail applies per container, so you will get tail * <number of pods> total
	// lines back.
	Tail int64 `protobuf:"varint,7,opt,name=tail,proto3" json:"tail,omitempty"`
	// UseLokiBackend causes the logs request to go through the loki backend
	// rather than through kubernetes. This behavior can also be achieved by
	// setting the LOKI_LOGGING feature flag.
	UseLokiBackend bool `protobuf:"varint,8,opt,name=use_loki_backend,json=useLokiBackend,proto3" json:"use_loki_backend,omitempty"`
	// Since specifies how far in the past to return logs from. It defaults to 24 hours.
	Since                *types.Duration `protobuf:"bytes,9,opt,name=since,proto3" json:"since,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetLogsRequest) Reset()         { *m = GetLogsRequest{} }
func (m *GetLogsRequest) String() string { return proto.CompactTextString(m) }
func (*GetLogsRequest) ProtoMessage()    {}
func (*GetLogsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{38}
}
func (m *GetLogsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetLogsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetLogsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetLogsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetLogsRequest.Merge(m, src)
}
func (m *GetLogsRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetLogsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetLogsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetLogsRequest proto.InternalMessageInfo

func (m *GetLogsRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *GetLogsRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *GetLogsRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

func (m *GetLogsRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

func (m *GetLogsRequest) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *GetLogsRequest) GetFollow() bool {
	if m != nil {
		return m.Follow
	}
	return false
}

func (m *GetLogsRequest) GetTail() int64 {
	if m != nil {
		return m.Tail
	}
	return 0
}

func (m *GetLogsRequest) GetUseLokiBackend() bool {
	if m != nil {
		return m.UseLokiBackend
	}
	return false
}

func (m *GetLogsRequest) GetSince() *types.Duration {
	if m != nil {
		return m.Since
	}
	return nil
}

// LogMessage is a log line from a PPS worker, annotated with metadata
// indicating when and why the line was logged.
type LogMessage struct {
	// The job and pipeline for which a PFS file is being processed (if the job
	// is an orphan job, pipeline name and ID will be unset)
	PipelineName string `protobuf:"bytes,1,opt,name=pipeline_name,json=pipelineName,proto3" json:"pipeline_name,omitempty"`
	JobID        string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	WorkerID     string `protobuf:"bytes,3,opt,name=worker_id,json=workerId,proto3" json:"worker_id,omitempty"`
	DatumID      string `protobuf:"bytes,4,opt,name=datum_id,json=datumId,proto3" json:"datum_id,omitempty"`
	Master       bool   `protobuf:"varint,5,opt,name=master,proto3" json:"master,omitempty"`
	// The PFS files being processed (one per pipeline/job input)
	Data []*InputFile `protobuf:"bytes,6,rep,name=data,proto3" json:"data,omitempty"`
	// User is true if log message comes from the users code.
	User bool `protobuf:"varint,7,opt,name=user,proto3" json:"user,omitempty"`
	// The message logged, and the time at which it was logged
	Ts                   *types.Timestamp `protobuf:"bytes,8,opt,name=ts,proto3" json:"ts,omitempty"`
	Message              string           `protobuf:"bytes,9,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *LogMessage) Reset()         { *m = LogMessage{} }
func (m *LogMessage) String() string { return proto.CompactTextString(m) }
func (*LogMessage) ProtoMessage()    {}
func (*LogMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{39}
}
func (m *LogMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogMessage.Merge(m, src)
}
func (m *LogMessage) XXX_Size() int {
	return m.Size()
}
func (m *LogMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LogMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LogMessage proto.InternalMessageInfo

func (m *LogMessage) GetPipelineName() string {
	if m != nil {
		return m.PipelineName
	}
	return ""
}

func (m *LogMessage) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

func (m *LogMessage) GetWorkerID() string {
	if m != nil {
		return m.WorkerID
	}
	return ""
}

func (m *LogMessage) GetDatumID() string {
	if m != nil {
		return m.DatumID
	}
	return ""
}

func (m *LogMessage) GetMaster() bool {
	if m != nil {
		return m.Master
	}
	return false
}

func (m *LogMessage) GetData() []*InputFile {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *LogMessage) GetUser() bool {
	if m != nil {
		return m.User
	}
	return false
}

func (m *LogMessage) GetTs() *types.Timestamp {
	if m != nil {
		return m.Ts
	}
	return nil
}

func (m *LogMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type RestartDatumRequest struct {
	Job                  *Job     `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	DataFilters          []string `protobuf:"bytes,2,rep,name=data_filters,json=dataFilters,proto3" json:"data_filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RestartDatumRequest) Reset()         { *m = RestartDatumRequest{} }
func (m *RestartDatumRequest) String() string { return proto.CompactTextString(m) }
func (*RestartDatumRequest) ProtoMessage()    {}
func (*RestartDatumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{40}
}
func (m *RestartDatumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RestartDatumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RestartDatumRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RestartDatumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RestartDatumRequest.Merge(m, src)
}
func (m *RestartDatumRequest) XXX_Size() int {
	return m.Size()
}
func (m *RestartDatumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RestartDatumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RestartDatumRequest proto.InternalMessageInfo

func (m *RestartDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *RestartDatumRequest) GetDataFilters() []string {
	if m != nil {
		return m.DataFilters
	}
	return nil
}

type InspectDatumRequest struct {
	Datum                *Datum   `protobuf:"bytes,1,opt,name=datum,proto3" json:"datum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectDatumRequest) Reset()         { *m = InspectDatumRequest{} }
func (m *InspectDatumRequest) String() string { return proto.CompactTextString(m) }
func (*InspectDatumRequest) ProtoMessage()    {}
func (*InspectDatumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{41}
}
func (m *InspectDatumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectDatumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectDatumRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectDatumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectDatumRequest.Merge(m, src)
}
func (m *InspectDatumRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectDatumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectDatumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectDatumRequest proto.InternalMessageInfo

func (m *InspectDatumRequest) GetDatum() *Datum {
	if m != nil {
		return m.Datum
	}
	return nil
}

type ListDatumRequest struct {
	// Job and Input are two different ways to specify the datums you want.
	// Only one can be set.
	// Job is the job to list datums from.
	Job *Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job,omitempty"`
	// Input is the input to list datums from.
	// The datums listed are the ones that would be run if a pipeline was created
	// with the provided input.
	Input                *Input   `protobuf:"bytes,2,opt,name=input,proto3" json:"input,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListDatumRequest) Reset()         { *m = ListDatumRequest{} }
func (m *ListDatumRequest) String() string { return proto.CompactTextString(m) }
func (*ListDatumRequest) ProtoMessage()    {}
func (*ListDatumRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{42}
}
func (m *ListDatumRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListDatumRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListDatumRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListDatumRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListDatumRequest.Merge(m, src)
}
func (m *ListDatumRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListDatumRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListDatumRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListDatumRequest proto.InternalMessageInfo

func (m *ListDatumRequest) GetJob() *Job {
	if m != nil {
		return m.Job
	}
	return nil
}

func (m *ListDatumRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

// DatumSetSpec specifies how a pipeline should split its datums into datum sets.
type DatumSetSpec struct {
	// number, if nonzero, specifies that each datum set should contain `number`
	// datums. Datum sets may contain fewer if the total number of datums don't
	// divide evenly.
	Number int64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	// size_bytes, if nonzero, specifies a target size for each datum set.
	// Datum sets may be larger or smaller than size_bytes, but will usually be
	// pretty close to size_bytes in size.
	SizeBytes int64 `protobuf:"varint,2,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	// per_worker, if nonzero, specifies how many datum sets should be created
	// for each worker. It can't be set with number or size_bytes.
	PerWorker            int64    `protobuf:"varint,3,opt,name=per_worker,json=perWorker,proto3" json:"per_worker,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DatumSetSpec) Reset()         { *m = DatumSetSpec{} }
func (m *DatumSetSpec) String() string { return proto.CompactTextString(m) }
func (*DatumSetSpec) ProtoMessage()    {}
func (*DatumSetSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{43}
}
func (m *DatumSetSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DatumSetSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DatumSetSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DatumSetSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DatumSetSpec.Merge(m, src)
}
func (m *DatumSetSpec) XXX_Size() int {
	return m.Size()
}
func (m *DatumSetSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_DatumSetSpec.DiscardUnknown(m)
}

var xxx_messageInfo_DatumSetSpec proto.InternalMessageInfo

func (m *DatumSetSpec) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *DatumSetSpec) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *DatumSetSpec) GetPerWorker() int64 {
	if m != nil {
		return m.PerWorker
	}
	return 0
}

type SchedulingSpec struct {
	NodeSelector         map[string]string `protobuf:"bytes,1,rep,name=node_selector,json=nodeSelector,proto3" json:"node_selector,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	PriorityClassName    string            `protobuf:"bytes,2,opt,name=priority_class_name,json=priorityClassName,proto3" json:"priority_class_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SchedulingSpec) Reset()         { *m = SchedulingSpec{} }
func (m *SchedulingSpec) String() string { return proto.CompactTextString(m) }
func (*SchedulingSpec) ProtoMessage()    {}
func (*SchedulingSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{44}
}
func (m *SchedulingSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulingSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulingSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulingSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulingSpec.Merge(m, src)
}
func (m *SchedulingSpec) XXX_Size() int {
	return m.Size()
}
func (m *SchedulingSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulingSpec.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulingSpec proto.InternalMessageInfo

func (m *SchedulingSpec) GetNodeSelector() map[string]string {
	if m != nil {
		return m.NodeSelector
	}
	return nil
}

func (m *SchedulingSpec) GetPriorityClassName() string {
	if m != nil {
		return m.PriorityClassName
	}
	return ""
}

type CreatePipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	// tf_job encodes a Kubeflow TFJob spec. Pachyderm uses this to create TFJobs
	// when running in a kubernetes cluster on which kubeflow has been installed.
	// Exactly one of 'tf_job' and 'transform' should be set
	TFJob           *TFJob           `protobuf:"bytes,2,opt,name=tf_job,json=tfJob,proto3" json:"tf_job,omitempty"`
	Transform       *Transform       `protobuf:"bytes,3,opt,name=transform,proto3" json:"transform,omitempty"`
	ParallelismSpec *ParallelismSpec `protobuf:"bytes,4,opt,name=parallelism_spec,json=parallelismSpec,proto3" json:"parallelism_spec,omitempty"`
	Egress          *Egress          `protobuf:"bytes,5,opt,name=egress,proto3" json:"egress,omitempty"`
	Update          bool             `protobuf:"varint,6,opt,name=update,proto3" json:"update,omitempty"`
	OutputBranch    string           `protobuf:"bytes,7,opt,name=output_branch,json=outputBranch,proto3" json:"output_branch,omitempty"`
	// s3_out, if set, requires a pipeline's user to write to its output repo
	// via Pachyderm's s3 gateway (if set, workers will serve Pachyderm's s3
	// gateway API at http://<pipeline>-s3.<namespace>/<job id>.out/my/file).
	// In this mode /pfs_v2/out won't be walked or uploaded, and the s3 gateway
	// service in the workers will allow writes to the job's output commit
	S3Out                 bool          `protobuf:"varint,8,opt,name=s3_out,json=s3Out,proto3" json:"s3_out,omitempty"`
	ResourceRequests      *ResourceSpec `protobuf:"bytes,9,opt,name=resource_requests,json=resourceRequests,proto3" json:"resource_requests,omitempty"`
	ResourceLimits        *ResourceSpec `protobuf:"bytes,10,opt,name=resource_limits,json=resourceLimits,proto3" json:"resource_limits,omitempty"`
	SidecarResourceLimits *ResourceSpec `protobuf:"bytes,11,opt,name=sidecar_resource_limits,json=sidecarResourceLimits,proto3" json:"sidecar_resource_limits,omitempty"`
	Input                 *Input        `protobuf:"bytes,12,opt,name=input,proto3" json:"input,omitempty"`
	Description           string        `protobuf:"bytes,13,opt,name=description,proto3" json:"description,omitempty"`
	// Reprocess forces the pipeline to reprocess all datums.
	// It only has meaning if Update is true
	Reprocess            bool            `protobuf:"varint,15,opt,name=reprocess,proto3" json:"reprocess,omitempty"`
	Service              *Service        `protobuf:"bytes,17,opt,name=service,proto3" json:"service,omitempty"`
	Spout                *Spout          `protobuf:"bytes,18,opt,name=spout,proto3" json:"spout,omitempty"`
	DatumSetSpec         *DatumSetSpec   `protobuf:"bytes,19,opt,name=datum_set_spec,json=datumSetSpec,proto3" json:"datum_set_spec,omitempty"`
	DatumTimeout         *types.Duration `protobuf:"bytes,20,opt,name=datum_timeout,json=datumTimeout,proto3" json:"datum_timeout,omitempty"`
	JobTimeout           *types.Duration `protobuf:"bytes,21,opt,name=job_timeout,json=jobTimeout,proto3" json:"job_timeout,omitempty"`
	Salt                 string          `protobuf:"bytes,22,opt,name=salt,proto3" json:"salt,omitempty"`
	DatumTries           int64           `protobuf:"varint,23,opt,name=datum_tries,json=datumTries,proto3" json:"datum_tries,omitempty"`
	SchedulingSpec       *SchedulingSpec `protobuf:"bytes,24,opt,name=scheduling_spec,json=schedulingSpec,proto3" json:"scheduling_spec,omitempty"`
	PodSpec              string          `protobuf:"bytes,25,opt,name=pod_spec,json=podSpec,proto3" json:"pod_spec,omitempty"`
	PodPatch             string          `protobuf:"bytes,26,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	SpecCommit           *pfs.Commit     `protobuf:"bytes,27,opt,name=spec_commit,json=specCommit,proto3" json:"spec_commit,omitempty"`
	Metadata             *Metadata       `protobuf:"bytes,28,opt,name=metadata,proto3" json:"metadata,omitempty"`
	ReprocessSpec        string          `protobuf:"bytes,29,opt,name=reprocess_spec,json=reprocessSpec,proto3" json:"reprocess_spec,omitempty"`
	Autoscaling          bool            `protobuf:"varint,30,opt,name=autoscaling,proto3" json:"autoscaling,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CreatePipelineRequest) Reset()         { *m = CreatePipelineRequest{} }
func (m *CreatePipelineRequest) String() string { return proto.CompactTextString(m) }
func (*CreatePipelineRequest) ProtoMessage()    {}
func (*CreatePipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{45}
}
func (m *CreatePipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreatePipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreatePipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreatePipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreatePipelineRequest.Merge(m, src)
}
func (m *CreatePipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreatePipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreatePipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreatePipelineRequest proto.InternalMessageInfo

func (m *CreatePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *CreatePipelineRequest) GetTFJob() *TFJob {
	if m != nil {
		return m.TFJob
	}
	return nil
}

func (m *CreatePipelineRequest) GetTransform() *Transform {
	if m != nil {
		return m.Transform
	}
	return nil
}

func (m *CreatePipelineRequest) GetParallelismSpec() *ParallelismSpec {
	if m != nil {
		return m.ParallelismSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetEgress() *Egress {
	if m != nil {
		return m.Egress
	}
	return nil
}

func (m *CreatePipelineRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

func (m *CreatePipelineRequest) GetOutputBranch() string {
	if m != nil {
		return m.OutputBranch
	}
	return ""
}

func (m *CreatePipelineRequest) GetS3Out() bool {
	if m != nil {
		return m.S3Out
	}
	return false
}

func (m *CreatePipelineRequest) GetResourceRequests() *ResourceSpec {
	if m != nil {
		return m.ResourceRequests
	}
	return nil
}

func (m *CreatePipelineRequest) GetResourceLimits() *ResourceSpec {
	if m != nil {
		return m.ResourceLimits
	}
	return nil
}

func (m *CreatePipelineRequest) GetSidecarResourceLimits() *ResourceSpec {
	if m != nil {
		return m.SidecarResourceLimits
	}
	return nil
}

func (m *CreatePipelineRequest) GetInput() *Input {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *CreatePipelineRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreatePipelineRequest) GetReprocess() bool {
	if m != nil {
		return m.Reprocess
	}
	return false
}

func (m *CreatePipelineRequest) GetService() *Service {
	if m != nil {
		return m.Service
	}
	return nil
}

func (m *CreatePipelineRequest) GetSpout() *Spout {
	if m != nil {
		return m.Spout
	}
	return nil
}

func (m *CreatePipelineRequest) GetDatumSetSpec() *DatumSetSpec {
	if m != nil {
		return m.DatumSetSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetDatumTimeout() *types.Duration {
	if m != nil {
		return m.DatumTimeout
	}
	return nil
}

func (m *CreatePipelineRequest) GetJobTimeout() *types.Duration {
	if m != nil {
		return m.JobTimeout
	}
	return nil
}

func (m *CreatePipelineRequest) GetSalt() string {
	if m != nil {
		return m.Salt
	}
	return ""
}

func (m *CreatePipelineRequest) GetDatumTries() int64 {
	if m != nil {
		return m.DatumTries
	}
	return 0
}

func (m *CreatePipelineRequest) GetSchedulingSpec() *SchedulingSpec {
	if m != nil {
		return m.SchedulingSpec
	}
	return nil
}

func (m *CreatePipelineRequest) GetPodSpec() string {
	if m != nil {
		return m.PodSpec
	}
	return ""
}

func (m *CreatePipelineRequest) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

func (m *CreatePipelineRequest) GetSpecCommit() *pfs.Commit {
	if m != nil {
		return m.SpecCommit
	}
	return nil
}

func (m *CreatePipelineRequest) GetMetadata() *Metadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *CreatePipelineRequest) GetReprocessSpec() string {
	if m != nil {
		return m.ReprocessSpec
	}
	return ""
}

func (m *CreatePipelineRequest) GetAutoscaling() bool {
	if m != nil {
		return m.Autoscaling
	}
	return false
}

type InspectPipelineRequest struct {
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	// When true, return PipelineInfos with the details field, which requires
	// loading the pipeline spec from PFS.
	Details              bool     `protobuf:"varint,2,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectPipelineRequest) Reset()         { *m = InspectPipelineRequest{} }
func (m *InspectPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*InspectPipelineRequest) ProtoMessage()    {}
func (*InspectPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{46}
}
func (m *InspectPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectPipelineRequest.Merge(m, src)
}
func (m *InspectPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectPipelineRequest proto.InternalMessageInfo

func (m *InspectPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *InspectPipelineRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

type ListPipelineRequest struct {
	// If non-nil, only return info about a single pipeline, this is redundant
	// with InspectPipeline unless history is non-zero.
	Pipeline *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	// History indicates how many historical versions you want returned. Its
	// semantics are:
	// 0: Return the current version of the pipeline or pipelines.
	// 1: Return the above and the next most recent version
	// 2: etc.
	//-1: Return all historical versions.
	History int64 `protobuf:"varint,2,opt,name=history,proto3" json:"history,omitempty"`
	// When true, return PipelineInfos with the details field, which requires
	// loading the pipeline spec from PFS.
	Details bool `protobuf:"varint,3,opt,name=details,proto3" json:"details,omitempty"`
	// A jq program string for additional result filtering
	JqFilter             string   `protobuf:"bytes,4,opt,name=jqFilter,proto3" json:"jqFilter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListPipelineRequest) Reset()         { *m = ListPipelineRequest{} }
func (m *ListPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*ListPipelineRequest) ProtoMessage()    {}
func (*ListPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{47}
}
func (m *ListPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListPipelineRequest.Merge(m, src)
}
func (m *ListPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListPipelineRequest proto.InternalMessageInfo

func (m *ListPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *ListPipelineRequest) GetHistory() int64 {
	if m != nil {
		return m.History
	}
	return 0
}

func (m *ListPipelineRequest) GetDetails() bool {
	if m != nil {
		return m.Details
	}
	return false
}

func (m *ListPipelineRequest) GetJqFilter() string {
	if m != nil {
		return m.JqFilter
	}
	return ""
}

type DeletePipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	All                  bool      `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
	Force                bool      `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	KeepRepo             bool      `protobuf:"varint,4,opt,name=keep_repo,json=keepRepo,proto3" json:"keep_repo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DeletePipelineRequest) Reset()         { *m = DeletePipelineRequest{} }
func (m *DeletePipelineRequest) String() string { return proto.CompactTextString(m) }
func (*DeletePipelineRequest) ProtoMessage()    {}
func (*DeletePipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{48}
}
func (m *DeletePipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeletePipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeletePipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeletePipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeletePipelineRequest.Merge(m, src)
}
func (m *DeletePipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeletePipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeletePipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeletePipelineRequest proto.InternalMessageInfo

func (m *DeletePipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *DeletePipelineRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *DeletePipelineRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *DeletePipelineRequest) GetKeepRepo() bool {
	if m != nil {
		return m.KeepRepo
	}
	return false
}

type StartPipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StartPipelineRequest) Reset()         { *m = StartPipelineRequest{} }
func (m *StartPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*StartPipelineRequest) ProtoMessage()    {}
func (*StartPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{49}
}
func (m *StartPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartPipelineRequest.Merge(m, src)
}
func (m *StartPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartPipelineRequest proto.InternalMessageInfo

func (m *StartPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type StopPipelineRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *StopPipelineRequest) Reset()         { *m = StopPipelineRequest{} }
func (m *StopPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*StopPipelineRequest) ProtoMessage()    {}
func (*StopPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{50}
}
func (m *StopPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StopPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StopPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StopPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StopPipelineRequest.Merge(m, src)
}
func (m *StopPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *StopPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StopPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StopPipelineRequest proto.InternalMessageInfo

func (m *StopPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type RunPipelineRequest struct {
	Pipeline             *Pipeline     `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	Provenance           []*pfs.Commit `protobuf:"bytes,2,rep,name=provenance,proto3" json:"provenance,omitempty"`
	JobID                string        `protobuf:"bytes,3,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RunPipelineRequest) Reset()         { *m = RunPipelineRequest{} }
func (m *RunPipelineRequest) String() string { return proto.CompactTextString(m) }
func (*RunPipelineRequest) ProtoMessage()    {}
func (*RunPipelineRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{51}
}
func (m *RunPipelineRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunPipelineRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunPipelineRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunPipelineRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunPipelineRequest.Merge(m, src)
}
func (m *RunPipelineRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunPipelineRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunPipelineRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunPipelineRequest proto.InternalMessageInfo

func (m *RunPipelineRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

func (m *RunPipelineRequest) GetProvenance() []*pfs.Commit {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *RunPipelineRequest) GetJobID() string {
	if m != nil {
		return m.JobID
	}
	return ""
}

type RunCronRequest struct {
	Pipeline             *Pipeline `protobuf:"bytes,1,opt,name=pipeline,proto3" json:"pipeline,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RunCronRequest) Reset()         { *m = RunCronRequest{} }
func (m *RunCronRequest) String() string { return proto.CompactTextString(m) }
func (*RunCronRequest) ProtoMessage()    {}
func (*RunCronRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{52}
}
func (m *RunCronRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunCronRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunCronRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunCronRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunCronRequest.Merge(m, src)
}
func (m *RunCronRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunCronRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunCronRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunCronRequest proto.InternalMessageInfo

func (m *RunCronRequest) GetPipeline() *Pipeline {
	if m != nil {
		return m.Pipeline
	}
	return nil
}

type CreateSecretRequest struct {
	File                 []byte   `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateSecretRequest) Reset()         { *m = CreateSecretRequest{} }
func (m *CreateSecretRequest) String() string { return proto.CompactTextString(m) }
func (*CreateSecretRequest) ProtoMessage()    {}
func (*CreateSecretRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{53}
}
func (m *CreateSecretRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateSecretRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateSecretRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateSecretRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateSecretRequest.Merge(m, src)
}
func (m *CreateSecretRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateSecretRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateSecretRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateSecretRequest proto.InternalMessageInfo

func (m *CreateSecretRequest) GetFile() []byte {
	if m != nil {
		return m.File
	}
	return nil
}

type DeleteSecretRequest struct {
	Secret               *Secret  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteSecretRequest) Reset()         { *m = DeleteSecretRequest{} }
func (m *DeleteSecretRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteSecretRequest) ProtoMessage()    {}
func (*DeleteSecretRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{54}
}
func (m *DeleteSecretRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteSecretRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteSecretRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteSecretRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteSecretRequest.Merge(m, src)
}
func (m *DeleteSecretRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteSecretRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteSecretRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteSecretRequest proto.InternalMessageInfo

func (m *DeleteSecretRequest) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

type InspectSecretRequest struct {
	Secret               *Secret  `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectSecretRequest) Reset()         { *m = InspectSecretRequest{} }
func (m *InspectSecretRequest) String() string { return proto.CompactTextString(m) }
func (*InspectSecretRequest) ProtoMessage()    {}
func (*InspectSecretRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{55}
}
func (m *InspectSecretRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectSecretRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectSecretRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectSecretRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectSecretRequest.Merge(m, src)
}
func (m *InspectSecretRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectSecretRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectSecretRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectSecretRequest proto.InternalMessageInfo

func (m *InspectSecretRequest) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

type Secret struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Secret) Reset()         { *m = Secret{} }
func (m *Secret) String() string { return proto.CompactTextString(m) }
func (*Secret) ProtoMessage()    {}
func (*Secret) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{56}
}
func (m *Secret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Secret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Secret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Secret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Secret.Merge(m, src)
}
func (m *Secret) XXX_Size() int {
	return m.Size()
}
func (m *Secret) XXX_DiscardUnknown() {
	xxx_messageInfo_Secret.DiscardUnknown(m)
}

var xxx_messageInfo_Secret proto.InternalMessageInfo

func (m *Secret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type SecretInfo struct {
	Secret               *Secret          `protobuf:"bytes,1,opt,name=secret,proto3" json:"secret,omitempty"`
	Type                 string           `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	CreationTimestamp    *types.Timestamp `protobuf:"bytes,3,opt,name=creation_timestamp,json=creationTimestamp,proto3" json:"creation_timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SecretInfo) Reset()         { *m = SecretInfo{} }
func (m *SecretInfo) String() string { return proto.CompactTextString(m) }
func (*SecretInfo) ProtoMessage()    {}
func (*SecretInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{57}
}
func (m *SecretInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretInfo.Merge(m, src)
}
func (m *SecretInfo) XXX_Size() int {
	return m.Size()
}
func (m *SecretInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SecretInfo proto.InternalMessageInfo

func (m *SecretInfo) GetSecret() *Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

func (m *SecretInfo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *SecretInfo) GetCreationTimestamp() *types.Timestamp {
	if m != nil {
		return m.CreationTimestamp
	}
	return nil
}

type SecretInfos struct {
	SecretInfo           []*SecretInfo `protobuf:"bytes,1,rep,name=secret_info,json=secretInfo,proto3" json:"secret_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *SecretInfos) Reset()         { *m = SecretInfos{} }
func (m *SecretInfos) String() string { return proto.CompactTextString(m) }
func (*SecretInfos) ProtoMessage()    {}
func (*SecretInfos) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{58}
}
func (m *SecretInfos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SecretInfos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SecretInfos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SecretInfos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SecretInfos.Merge(m, src)
}
func (m *SecretInfos) XXX_Size() int {
	return m.Size()
}
func (m *SecretInfos) XXX_DiscardUnknown() {
	xxx_messageInfo_SecretInfos.DiscardUnknown(m)
}

var xxx_messageInfo_SecretInfos proto.InternalMessageInfo

func (m *SecretInfos) GetSecretInfo() []*SecretInfo {
	if m != nil {
		return m.SecretInfo
	}
	return nil
}

type ActivateAuthRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthRequest) Reset()         { *m = ActivateAuthRequest{} }
func (m *ActivateAuthRequest) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthRequest) ProtoMessage()    {}
func (*ActivateAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{59}
}
func (m *ActivateAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthRequest.Merge(m, src)
}
func (m *ActivateAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthRequest proto.InternalMessageInfo

type ActivateAuthResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthResponse) Reset()         { *m = ActivateAuthResponse{} }
func (m *ActivateAuthResponse) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthResponse) ProtoMessage()    {}
func (*ActivateAuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{60}
}
func (m *ActivateAuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthResponse.Merge(m, src)
}
func (m *ActivateAuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthResponse proto.InternalMessageInfo

type RunLoadTestRequest struct {
	DagSpec              string   `protobuf:"bytes,1,opt,name=dag_spec,json=dagSpec,proto3" json:"dag_spec,omitempty"`
	LoadSpec             string   `protobuf:"bytes,2,opt,name=load_spec,json=loadSpec,proto3" json:"load_spec,omitempty"`
	Seed                 int64    `protobuf:"varint,3,opt,name=seed,proto3" json:"seed,omitempty"`
	Parallelism          int64    `protobuf:"varint,4,opt,name=parallelism,proto3" json:"parallelism,omitempty"`
	PodPatch             string   `protobuf:"bytes,5,opt,name=pod_patch,json=podPatch,proto3" json:"pod_patch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunLoadTestRequest) Reset()         { *m = RunLoadTestRequest{} }
func (m *RunLoadTestRequest) String() string { return proto.CompactTextString(m) }
func (*RunLoadTestRequest) ProtoMessage()    {}
func (*RunLoadTestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{61}
}
func (m *RunLoadTestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunLoadTestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunLoadTestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunLoadTestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLoadTestRequest.Merge(m, src)
}
func (m *RunLoadTestRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunLoadTestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLoadTestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunLoadTestRequest proto.InternalMessageInfo

func (m *RunLoadTestRequest) GetDagSpec() string {
	if m != nil {
		return m.DagSpec
	}
	return ""
}

func (m *RunLoadTestRequest) GetLoadSpec() string {
	if m != nil {
		return m.LoadSpec
	}
	return ""
}

func (m *RunLoadTestRequest) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *RunLoadTestRequest) GetParallelism() int64 {
	if m != nil {
		return m.Parallelism
	}
	return 0
}

func (m *RunLoadTestRequest) GetPodPatch() string {
	if m != nil {
		return m.PodPatch
	}
	return ""
}

type RunLoadTestResponse struct {
	Error                string   `protobuf:"bytes,1,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunLoadTestResponse) Reset()         { *m = RunLoadTestResponse{} }
func (m *RunLoadTestResponse) String() string { return proto.CompactTextString(m) }
func (*RunLoadTestResponse) ProtoMessage()    {}
func (*RunLoadTestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{62}
}
func (m *RunLoadTestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunLoadTestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunLoadTestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunLoadTestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLoadTestResponse.Merge(m, src)
}
func (m *RunLoadTestResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunLoadTestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLoadTestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunLoadTestResponse proto.InternalMessageInfo

func (m *RunLoadTestResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RenderTemplateRequest struct {
	Template             string            `protobuf:"bytes,1,opt,name=template,proto3" json:"template,omitempty"`
	Args                 map[string]string `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RenderTemplateRequest) Reset()         { *m = RenderTemplateRequest{} }
func (m *RenderTemplateRequest) String() string { return proto.CompactTextString(m) }
func (*RenderTemplateRequest) ProtoMessage()    {}
func (*RenderTemplateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{63}
}
func (m *RenderTemplateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenderTemplateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenderTemplateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenderTemplateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenderTemplateRequest.Merge(m, src)
}
func (m *RenderTemplateRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenderTemplateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenderTemplateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenderTemplateRequest proto.InternalMessageInfo

func (m *RenderTemplateRequest) GetTemplate() string {
	if m != nil {
		return m.Template
	}
	return ""
}

func (m *RenderTemplateRequest) GetArgs() map[string]string {
	if m != nil {
		return m.Args
	}
	return nil
}

type RenderTemplateResponse struct {
	Json                 string                   `protobuf:"bytes,1,opt,name=json,proto3" json:"json,omitempty"`
	Specs                []*CreatePipelineRequest `protobuf:"bytes,2,rep,name=specs,proto3" json:"specs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *RenderTemplateResponse) Reset()         { *m = RenderTemplateResponse{} }
func (m *RenderTemplateResponse) String() string { return proto.CompactTextString(m) }
func (*RenderTemplateResponse) ProtoMessage()    {}
func (*RenderTemplateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_beade573c128ccc7, []int{64}
}
func (m *RenderTemplateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenderTemplateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenderTemplateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenderTemplateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenderTemplateResponse.Merge(m, src)
}
func (m *RenderTemplateResponse) XXX_Size() int {
	return m.Size()
}
func (m *RenderTemplateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RenderTemplateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RenderTemplateResponse proto.InternalMessageInfo

func (m *RenderTemplateResponse) GetJson() string {
	if m != nil {
		return m.Json
	}
	return ""
}

func (m *RenderTemplateResponse) GetSpecs() []*CreatePipelineRequest {
	if m != nil {
		return m.Specs
	}
	return nil
}

func init() {
	proto.RegisterEnum("pps_v2.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("pps_v2.DatumState", DatumState_name, DatumState_value)
	proto.RegisterEnum("pps_v2.WorkerState", WorkerState_name, WorkerState_value)
	proto.RegisterEnum("pps_v2.PipelineState", PipelineState_name, PipelineState_value)
	proto.RegisterEnum("pps_v2.PipelineInfo_PipelineType", PipelineInfo_PipelineType_name, PipelineInfo_PipelineType_value)
	proto.RegisterType((*SecretMount)(nil), "pps_v2.SecretMount")
	proto.RegisterType((*Transform)(nil), "pps_v2.Transform")
	proto.RegisterMapType((map[string]string)(nil), "pps_v2.Transform.EnvEntry")
	proto.RegisterType((*TFJob)(nil), "pps_v2.TFJob")
	proto.RegisterType((*Egress)(nil), "pps_v2.Egress")
	proto.RegisterType((*Job)(nil), "pps_v2.Job")
	proto.RegisterType((*Metadata)(nil), "pps_v2.Metadata")
	proto.RegisterMapType((map[string]string)(nil), "pps_v2.Metadata.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "pps_v2.Metadata.LabelsEntry")
	proto.RegisterType((*Service)(nil), "pps_v2.Service")
	proto.RegisterType((*Spout)(nil), "pps_v2.Spout")
	proto.RegisterType((*PFSInput)(nil), "pps_v2.PFSInput")
	proto.RegisterType((*CronInput)(nil), "pps_v2.CronInput")
	proto.RegisterType((*Input)(nil), "pps_v2.Input")
	proto.RegisterType((*JobInput)(nil), "pps_v2.JobInput")
	proto.RegisterType((*ParallelismSpec)(nil), "pps_v2.ParallelismSpec")
	proto.RegisterType((*InputFile)(nil), "pps_v2.InputFile")
	proto.RegisterType((*Datum)(nil), "pps_v2.Datum")
	proto.RegisterType((*DatumInfo)(nil), "pps_v2.DatumInfo")
	proto.RegisterType((*Aggregate)(nil), "pps_v2.Aggregate")
	proto.RegisterType((*ProcessStats)(nil), "pps_v2.ProcessStats")
	proto.RegisterType((*AggregateProcessStats)(nil), "pps_v2.AggregateProcessStats")
	proto.RegisterType((*WorkerStatus)(nil), "pps_v2.WorkerStatus")
	proto.RegisterType((*DatumStatus)(nil), "pps_v2.DatumStatus")
	proto.RegisterType((*ResourceSpec)(nil), "pps_v2.ResourceSpec")
	proto.RegisterType((*GPUSpec)(nil), "pps_v2.GPUSpec")
	proto.RegisterType((*JobSetInfo)(nil), "pps_v2.JobSetInfo")
	proto.RegisterType((*JobInfo)(nil), "pps_v2.JobInfo")
	proto.RegisterType((*JobInfo_Details)(nil), "pps_v2.JobInfo.Details")
	proto.RegisterType((*Worker)(nil), "pps_v2.Worker")
	proto.RegisterType((*Pipeline)(nil), "pps_v2.Pipeline")
	proto.RegisterType((*PipelineInfo)(nil), "pps_v2.PipelineInfo")
	proto.RegisterType((*PipelineInfo_Details)(nil), "pps_v2.PipelineInfo.Details")
	proto.RegisterType((*PipelineInfos)(nil), "pps_v2.PipelineInfos")
	proto.RegisterType((*JobSet)(nil), "pps_v2.JobSet")
	proto.RegisterType((*InspectJobSetRequest)(nil), "pps_v2.InspectJobSetRequest")
	proto.RegisterType((*ListJobSetRequest)(nil), "pps_v2.ListJobSetRequest")
	proto.RegisterType((*InspectJobRequest)(nil), "pps_v2.InspectJobRequest")
	proto.RegisterType((*ListJobRequest)(nil), "pps_v2.ListJobRequest")
	proto.RegisterType((*SubscribeJobRequest)(nil), "pps_v2.SubscribeJobRequest")
	proto.RegisterType((*DeleteJobRequest)(nil), "pps_v2.DeleteJobRequest")
	proto.RegisterType((*StopJobRequest)(nil), "pps_v2.StopJobRequest")
	proto.RegisterType((*UpdateJobStateRequest)(nil), "pps_v2.UpdateJobStateRequest")
	proto.RegisterType((*GetLogsRequest)(nil), "pps_v2.GetLogsRequest")
	proto.RegisterType((*LogMessage)(nil), "pps_v2.LogMessage")
	proto.RegisterType((*RestartDatumRequest)(nil), "pps_v2.RestartDatumRequest")
	proto.RegisterType((*InspectDatumRequest)(nil), "pps_v2.InspectDatumRequest")
	proto.RegisterType((*ListDatumRequest)(nil), "pps_v2.ListDatumRequest")
	proto.RegisterType((*DatumSetSpec)(nil), "pps_v2.DatumSetSpec")
	proto.RegisterType((*SchedulingSpec)(nil), "pps_v2.SchedulingSpec")
	proto.RegisterMapType((map[string]string)(nil), "pps_v2.SchedulingSpec.NodeSelectorEntry")
	proto.RegisterType((*CreatePipelineRequest)(nil), "pps_v2.CreatePipelineRequest")
	proto.RegisterType((*InspectPipelineRequest)(nil), "pps_v2.InspectPipelineRequest")
	proto.RegisterType((*ListPipelineRequest)(nil), "pps_v2.ListPipelineRequest")
	proto.RegisterType((*DeletePipelineRequest)(nil), "pps_v2.DeletePipelineRequest")
	proto.RegisterType((*StartPipelineRequest)(nil), "pps_v2.StartPipelineRequest")
	proto.RegisterType((*StopPipelineRequest)(nil), "pps_v2.StopPipelineRequest")
	proto.RegisterType((*RunPipelineRequest)(nil), "pps_v2.RunPipelineRequest")
	proto.RegisterType((*RunCronRequest)(nil), "pps_v2.RunCronRequest")
	proto.RegisterType((*CreateSecretRequest)(nil), "pps_v2.CreateSecretRequest")
	proto.RegisterType((*DeleteSecretRequest)(nil), "pps_v2.DeleteSecretRequest")
	proto.RegisterType((*InspectSecretRequest)(nil), "pps_v2.InspectSecretRequest")
	proto.RegisterType((*Secret)(nil), "pps_v2.Secret")
	proto.RegisterType((*SecretInfo)(nil), "pps_v2.SecretInfo")
	proto.RegisterType((*SecretInfos)(nil), "pps_v2.SecretInfos")
	proto.RegisterType((*ActivateAuthRequest)(nil), "pps_v2.ActivateAuthRequest")
	proto.RegisterType((*ActivateAuthResponse)(nil), "pps_v2.ActivateAuthResponse")
	proto.RegisterType((*RunLoadTestRequest)(nil), "pps_v2.RunLoadTestRequest")
	proto.RegisterType((*RunLoadTestResponse)(nil), "pps_v2.RunLoadTestResponse")
	proto.RegisterType((*RenderTemplateRequest)(nil), "pps_v2.RenderTemplateRequest")
	proto.RegisterMapType((map[string]string)(nil), "pps_v2.RenderTemplateRequest.ArgsEntry")
	proto.RegisterType((*RenderTemplateResponse)(nil), "pps_v2.RenderTemplateResponse")
}

func init() { proto.RegisterFile("pps/pps.proto", fileDescriptor_beade573c128ccc7) }

var fileDescriptor_beade573c128ccc7 = []byte{
	// 4885 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x5b, 0xcd, 0x73, 0x1b, 0x47,
	0x76, 0x17, 0xbe, 0x81, 0x07, 0x80, 0x04, 0x9b, 0x1f, 0x82, 0xa0, 0xef, 0x71, 0x56, 0x2b, 0xc9,
	0x36, 0x69, 0x53, 0x5e, 0xed, 0x5a, 0x5e, 0xcb, 0xcb, 0x0f, 0x48, 0xa6, 0x44, 0x53, 0xf4, 0x00,
	0xb4, 0xcb, 0x5b, 0x49, 0xcd, 0x0e, 0x30, 0x4d, 0x70, 0x44, 0x60, 0x66, 0x3c, 0x3d, 0xa0, 0x42,
	0x5f, 0x92, 0x63, 0x2a, 0x95, 0x53, 0x9c, 0x43, 0x6e, 0xc9, 0x25, 0x87, 0xcd, 0x25, 0xf9, 0x0f,
	0x92, 0xad, 0xca, 0x21, 0xb9, 0xed, 0x29, 0x97, 0x54, 0xb9, 0x52, 0xaa, 0x5c, 0xf7, 0x92, 0x63,
	0x4e, 0xa9, 0x7e, 0xdd, 0x3d, 0x1f, 0x00, 0x08, 0x7e, 0xf9, 0x42, 0x4e, 0xbf, 0xf7, 0xfa, 0x75,
	0xf7, 0xeb, 0xee, 0xf7, 0x7e, 0xef, 0xcd, 0x00, 0xaa, 0x9e, 0xc7, 0x56, 0x3c, 0x8f, 0x2d, 0x7b,
	0xbe, 0x1b, 0xb8, 0x24, 0xef, 0x79, 0xcc, 0x38, 0x5a, 0x6d, 0x5c, 0xef, 0xb9, 0x6e, 0xaf, 0x4f,
	0x57, 0x90, 0xda, 0x19, 0xee, 0xaf, 0xd0, 0x81, 0x17, 0x1c, 0x0b, 0xa1, 0xc6, 0xed, 0x51, 0x66,
	0x60, 0x0f, 0x28, 0x0b, 0xcc, 0x81, 0x27, 0x05, 0x6e, 0x8d, 0x0a, 0x58, 0x43, 0xdf, 0x0c, 0x6c,
	0xd7, 0x91, 0xfc, 0x85, 0x9e, 0xdb, 0x73, 0xf1, 0x71, 0x85, 0x3f, 0x49, 0x6a, 0xd5, 0xdb, 0x67,
	0x2b, 0xde, 0xbe, 0x9c, 0x4a, 0x63, 0x36, 0x30, 0xd9, 0xe1, 0x0a, 0xff, 0x23, 0x08, 0xda, 0x21,
	0x94, 0x5b, 0xb4, 0xeb, 0xd3, 0xe0, 0x0b, 0x77, 0xe8, 0x04, 0x84, 0x40, 0xd6, 0x31, 0x07, 0xb4,
	0x9e, 0xba, 0x93, 0xba, 0x5f, 0xd2, 0xf1, 0x99, 0xd4, 0x20, 0x73, 0x48, 0x8f, 0xeb, 0x69, 0x24,
	0xf1, 0x47, 0x72, 0x13, 0x60, 0xc0, 0xc5, 0x0d, 0xcf, 0x0c, 0x0e, 0xea, 0x19, 0x64, 0x94, 0x90,
	0xb2, 0x6b, 0x06, 0x07, 0xe4, 0x2a, 0x14, 0xa8, 0x73, 0x64, 0x1c, 0x99, 0x7e, 0x3d, 0x8b, 0xbc,
	0x3c, 0x75, 0x8e, 0xbe, 0x32, 0x7d, 0xed, 0xbf, 0x32, 0x50, 0x6a, 0xfb, 0xa6, 0xc3, 0xf6, 0x5d,
	0x7f, 0x40, 0x16, 0x20, 0x67, 0x0f, 0xcc, 0x9e, 0x1a, 0x4c, 0x34, 0xf8, 0x68, 0xdd, 0x81, 0x55,
	0x4f, 0xdf, 0xc9, 0xf0, 0xd1, 0xba, 0x03, 0x0b, 0xd5, 0xf9, 0xbe, 0xc1, 0xa9, 0x19, 0xa4, 0xe6,
	0xa9, 0xef, 0x6f, 0x0c, 0x2c, 0xf2, 0x1e, 0x64, 0xa8, 0x73, 0x54, 0xcf, 0xde, 0xc9, 0xdc, 0x2f,
	0xaf, 0x36, 0x96, 0x85, 0x95, 0x97, 0xc3, 0x01, 0x96, 0x9b, 0xce, 0x51, 0xd3, 0x09, 0xfc, 0x63,
	0x9d, 0x8b, 0x91, 0xf7, 0xa1, 0xc0, 0x70, 0xa5, 0xac, 0x9e, 0xc3, 0x1e, 0xf3, 0xaa, 0x47, 0xcc,
	0x00, 0xba, 0x92, 0x21, 0xef, 0x01, 0xc1, 0x09, 0x19, 0xde, 0xb0, 0xdf, 0x37, 0x54, 0xcf, 0x3c,
	0x4e, 0xa0, 0x86, 0x9c, 0xdd, 0x61, 0xbf, 0xdf, 0x92, 0xd2, 0x0b, 0x90, 0x63, 0x81, 0x65, 0x3b,
	0xf5, 0x02, 0x0a, 0x88, 0x06, 0xb9, 0x0e, 0x25, 0x3e, 0x73, 0xc1, 0x29, 0x22, 0xa7, 0x48, 0x7d,
	0xbf, 0x85, 0xcc, 0xf7, 0x80, 0x98, 0xdd, 0x2e, 0xf5, 0x02, 0xc3, 0xa7, 0xc1, 0xd0, 0x77, 0x8c,
	0xae, 0x6b, 0xd1, 0x7a, 0xe9, 0x4e, 0xe6, 0x7e, 0x46, 0xaf, 0x09, 0x8e, 0x8e, 0x8c, 0x0d, 0xd7,
	0xa2, 0x7c, 0x00, 0x8b, 0x76, 0x86, 0xbd, 0x3a, 0xdc, 0x49, 0xdd, 0x2f, 0xea, 0xa2, 0xc1, 0xb7,
	0x6b, 0xc8, 0xa8, 0x5f, 0x2f, 0x8b, 0xed, 0xe2, 0xcf, 0xe4, 0x36, 0x94, 0xdf, 0xb8, 0xfe, 0xa1,
	0xed, 0xf4, 0x0c, 0xcb, 0xf6, 0xeb, 0x15, 0x64, 0x81, 0x24, 0x6d, 0xda, 0x3e, 0xb9, 0x05, 0x60,
	0xb9, 0xdd, 0x43, 0xea, 0xef, 0xdb, 0x7d, 0x5a, 0xaf, 0x0a, 0x7e, 0x44, 0x69, 0x3c, 0x86, 0xa2,
	0xb2, 0x9c, 0xda, 0xfb, 0x54, 0xb4, 0xf7, 0x0b, 0x90, 0x3b, 0x32, 0xfb, 0x43, 0x2a, 0xcf, 0x83,
	0x68, 0x3c, 0x49, 0xff, 0x22, 0xa5, 0x3d, 0x80, 0x5c, 0xfb, 0xd9, 0x0b, 0xb7, 0x43, 0xee, 0x40,
	0x3e, 0xd8, 0x37, 0x5e, 0xbb, 0x1d, 0xd1, 0x6f, 0xbd, 0xf4, 0xf6, 0x87, 0xdb, 0x82, 0xa5, 0xe7,
	0x82, 0xfd, 0x17, 0x6e, 0x47, 0xfb, 0xc7, 0x14, 0xe4, 0x9b, 0x3d, 0x9f, 0x32, 0xc6, 0x47, 0xd8,
	0xd3, 0xb7, 0xd5, 0x08, 0x7b, 0xfa, 0x36, 0xd9, 0x84, 0x19, 0xb7, 0xf3, 0x9a, 0x76, 0x03, 0x83,
	0x05, 0xae, 0xcf, 0x0f, 0x08, 0x1f, 0xaa, 0xbc, 0x7a, 0x7d, 0xd9, 0xdb, 0xc7, 0xfd, 0x7a, 0x85,
	0xdc, 0x96, 0x60, 0x0a, 0x35, 0x9f, 0x5f, 0xd1, 0xab, 0x6e, 0x9c, 0x4c, 0x9e, 0x42, 0x85, 0x7d,
	0xdb, 0x37, 0x2c, 0x33, 0x30, 0x3b, 0x26, 0xa3, 0x78, 0x4a, 0xcb, 0xab, 0xd7, 0x94, 0x8e, 0xd6,
	0x97, 0xdb, 0x9b, 0x92, 0x15, 0x6a, 0x28, 0xb3, 0x6f, 0xfb, 0x8a, 0xb8, 0x5e, 0x84, 0x7c, 0x60,
	0xfa, 0x3d, 0x1a, 0x68, 0x5f, 0x42, 0x86, 0xaf, 0xea, 0x3d, 0x28, 0x7a, 0xb6, 0x47, 0xfb, 0xb6,
	0x23, 0x4e, 0x6c, 0x79, 0xb5, 0xa6, 0x0e, 0xd0, 0xae, 0xa4, 0xeb, 0xa1, 0x04, 0x59, 0x82, 0xb4,
	0x6d, 0x09, 0x1b, 0xad, 0xe7, 0xdf, 0xfe, 0x70, 0x3b, 0xbd, 0xb5, 0xa9, 0xa7, 0x6d, 0xeb, 0x49,
	0xf6, 0x6f, 0xff, 0xfe, 0xf6, 0x15, 0xed, 0xcf, 0xd3, 0x50, 0xfc, 0x82, 0x06, 0x26, 0x9f, 0x1d,
	0xd9, 0x80, 0xb2, 0xe9, 0x38, 0x6e, 0x80, 0x97, 0x99, 0xd5, 0x53, 0x78, 0x38, 0xef, 0x2a, 0xdd,
	0x4a, 0x6c, 0x79, 0x2d, 0x92, 0x11, 0xa7, 0x3a, 0xde, 0x8b, 0x7c, 0x04, 0xf9, 0xbe, 0xd9, 0xa1,
	0x7d, 0x86, 0x37, 0xa7, 0xbc, 0x7a, 0x63, 0xac, 0xff, 0x36, 0xb2, 0x45, 0x57, 0x29, 0xdb, 0x78,
	0x0a, 0xb5, 0x51, 0xb5, 0xe7, 0xd9, 0xf2, 0xc6, 0xc7, 0x50, 0x8e, 0xa9, 0x3d, 0xd7, 0x69, 0xf9,
	0x33, 0x28, 0xb4, 0xa8, 0x7f, 0x64, 0x77, 0x29, 0x79, 0x07, 0xaa, 0xb6, 0x13, 0x50, 0xdf, 0x31,
	0xfb, 0x86, 0xe7, 0xfa, 0x01, 0x2a, 0xc8, 0xe9, 0x15, 0x45, 0xdc, 0x75, 0xfd, 0x80, 0x0b, 0xd1,
	0x3f, 0x8d, 0x0b, 0xa5, 0x85, 0x90, 0x22, 0xa2, 0x10, 0xb7, 0xba, 0x27, 0x1c, 0x92, 0xb4, 0xfa,
	0xae, 0x9e, 0xb6, 0x3d, 0x7e, 0x4f, 0x82, 0x63, 0x8f, 0x4a, 0x77, 0x84, 0xcf, 0xda, 0x2a, 0xe4,
	0x5a, 0x9e, 0x3b, 0x0c, 0xc8, 0x03, 0xee, 0x18, 0x70, 0x26, 0x72, 0x5f, 0x67, 0x23, 0xc7, 0x80,
	0x64, 0x5d, 0xf1, 0xb5, 0xff, 0x4c, 0x43, 0x71, 0xf7, 0x59, 0x6b, 0xcb, 0xf1, 0x86, 0x93, 0x7d,
	0x25, 0x81, 0xac, 0x4f, 0x3d, 0x57, 0x2e, 0x17, 0x9f, 0xb9, 0x17, 0xe0, 0xff, 0x0d, 0x9c, 0x81,
	0xb8, 0x6e, 0x45, 0x4e, 0x68, 0x1f, 0x7b, 0xfc, 0x9c, 0xe4, 0x3b, 0xbe, 0xe9, 0x74, 0x95, 0x1b,
	0x95, 0x2d, 0x4e, 0xef, 0xba, 0x83, 0x81, 0x1d, 0x28, 0x17, 0x2a, 0x5a, 0x7c, 0x80, 0x5e, 0xdf,
	0xed, 0xd4, 0x73, 0x62, 0x00, 0xfe, 0xcc, 0x1d, 0xe4, 0x6b, 0xd7, 0x76, 0x0c, 0xd7, 0xa9, 0xe7,
	0x85, 0x30, 0x6f, 0xbe, 0x72, 0xb8, 0x9f, 0x76, 0x87, 0x01, 0xf5, 0x0d, 0xde, 0xae, 0x17, 0xd0,
	0x73, 0x94, 0x90, 0xf2, 0xc2, 0xb5, 0x1d, 0x72, 0x0d, 0x8a, 0x3d, 0xdf, 0x1d, 0x7a, 0x46, 0xe7,
	0xb8, 0x5e, 0xc4, 0x8e, 0x05, 0x6c, 0xaf, 0x1f, 0xf3, 0x61, 0xfa, 0xe6, 0x77, 0xc7, 0xf5, 0x12,
	0xf6, 0xc1, 0x67, 0xee, 0x58, 0x30, 0x60, 0x19, 0xdc, 0x4b, 0x30, 0xe9, 0x88, 0x00, 0x49, 0xcf,
	0x38, 0x85, 0xcc, 0x40, 0x9a, 0x3d, 0x42, 0x5f, 0x54, 0xd4, 0xd3, 0xec, 0x11, 0x37, 0x6c, 0xe0,
	0xdb, 0xbd, 0x1e, 0x15, 0x5e, 0x08, 0x0d, 0xbb, 0x2f, 0x7d, 0x34, 0x92, 0x75, 0xc5, 0xd7, 0xfe,
	0x29, 0x05, 0xa5, 0x0d, 0xdf, 0x75, 0xce, 0x67, 0xd9, 0xc8, 0x48, 0x99, 0x51, 0x23, 0x31, 0x8f,
	0x76, 0xd5, 0x76, 0xf3, 0x67, 0x72, 0x03, 0x4a, 0xee, 0x11, 0xf5, 0xdf, 0xf8, 0x76, 0x40, 0xd1,
	0x7a, 0xdc, 0x14, 0x8a, 0x40, 0x3e, 0xe0, 0xfe, 0xdb, 0xf4, 0x03, 0x34, 0x20, 0x0f, 0x26, 0x22,
	0xd8, 0x2e, 0xab, 0x60, 0xbb, 0xdc, 0x56, 0xd1, 0x58, 0x17, 0x82, 0xda, 0xff, 0xa4, 0x20, 0x27,
	0x66, 0xab, 0x41, 0xc6, 0xdb, 0x67, 0x63, 0x3e, 0x41, 0x1e, 0x13, 0x9d, 0x33, 0xc9, 0x5d, 0xc8,
	0xe2, 0x1e, 0x88, 0xcb, 0x59, 0x55, 0x42, 0x42, 0x02, 0x59, 0xe4, 0x1d, 0xc8, 0xa1, 0xf5, 0x31,
	0xc8, 0x8d, 0xc9, 0x08, 0x1e, 0x17, 0xea, 0xfa, 0x2e, 0x63, 0x32, 0xe8, 0x8d, 0x0a, 0x21, 0x8f,
	0x0b, 0x0d, 0x1d, 0xdb, 0x75, 0x64, 0x9c, 0x1b, 0x15, 0x42, 0x1e, 0xf9, 0x09, 0x64, 0xbb, 0xbe,
	0x3c, 0x31, 0xe5, 0xd5, 0x39, 0x25, 0x13, 0x6e, 0x82, 0x8e, 0x6c, 0xcd, 0x81, 0xe2, 0x0b, 0xb7,
	0x73, 0xf2, 0xb6, 0xdc, 0x0b, 0xb7, 0x40, 0x38, 0xe9, 0x19, 0xb5, 0xc5, 0x1b, 0x48, 0x1d, 0x3b,
	0xb7, 0x99, 0xd8, 0xb9, 0x55, 0x87, 0x2c, 0x1b, 0x1d, 0x32, 0xed, 0x7d, 0x98, 0xdd, 0x35, 0x7d,
	0xb3, 0xdf, 0xa7, 0x7d, 0x9b, 0x0d, 0x5a, 0x7c, 0xe7, 0x1a, 0x50, 0xec, 0xba, 0x0e, 0x0b, 0x4c,
	0x47, 0x78, 0x86, 0xac, 0x1e, 0xb6, 0xb5, 0x47, 0x50, 0xc2, 0xb9, 0xf1, 0x03, 0xc8, 0xf5, 0x21,
	0x20, 0x91, 0xf3, 0xe3, 0xcf, 0x9c, 0x76, 0x60, 0xb2, 0x03, 0x9c, 0x5d, 0x45, 0xc7, 0x67, 0xed,
	0x29, 0xe4, 0x36, 0xcd, 0x60, 0x38, 0x20, 0x37, 0x21, 0xa3, 0xa2, 0x54, 0x79, 0xb5, 0xac, 0x4c,
	0xc0, 0xe3, 0x14, 0xa7, 0x9f, 0xe4, 0xc3, 0xb5, 0xff, 0x4d, 0x41, 0x09, 0x15, 0x6c, 0x39, 0xfb,
	0x2e, 0xb7, 0xb6, 0xc5, 0x1b, 0x52, 0x4d, 0x68, 0x6d, 0x94, 0xd0, 0x05, 0x8f, 0xdc, 0xc7, 0xf3,
	0x15, 0x08, 0x3f, 0x38, 0xb3, 0x4a, 0x12, 0x42, 0x2d, 0xce, 0xd1, 0x85, 0x00, 0x79, 0x28, 0x24,
	0x99, 0x0c, 0x58, 0x0b, 0xe1, 0x79, 0xf2, 0xdd, 0x2e, 0x65, 0x8c, 0xcb, 0x32, 0x21, 0xcb, 0xc8,
	0x03, 0x28, 0x71, 0x6b, 0x0b, 0xcd, 0x59, 0x94, 0xaf, 0x28, 0xfb, 0x73, 0x8b, 0xe8, 0x45, 0x6f,
	0x1f, 0x7b, 0x50, 0xf2, 0x47, 0x90, 0xe5, 0x51, 0x40, 0x1e, 0x89, 0x5a, 0x5c, 0x8a, 0xaf, 0x42,
	0x47, 0x2e, 0xf7, 0x08, 0x02, 0xf4, 0xd8, 0x96, 0x74, 0x25, 0x05, 0x6c, 0x6f, 0x59, 0xda, 0x3f,
	0xa7, 0xa0, 0xb4, 0xd6, 0xeb, 0xf9, 0xb4, 0xc7, 0xd5, 0x2d, 0x40, 0xae, 0xcb, 0xf1, 0x12, 0x2e,
	0x3a, 0xa3, 0x8b, 0x06, 0x37, 0xf6, 0x80, 0x9a, 0x0e, 0x2e, 0x32, 0xa5, 0xe3, 0x33, 0xbf, 0xa3,
	0x2c, 0xb0, 0x2c, 0x7a, 0x84, 0x0b, 0x4a, 0xe9, 0xb2, 0x45, 0x1e, 0x40, 0x6d, 0xdf, 0xde, 0x0f,
	0x0e, 0x0c, 0x8f, 0xfa, 0x5d, 0xea, 0x04, 0x1c, 0x8b, 0x64, 0x51, 0x62, 0x16, 0xe9, 0xbb, 0x21,
	0x99, 0x3c, 0x86, 0xab, 0x8e, 0xed, 0x50, 0xf4, 0x3c, 0x23, 0x3d, 0x72, 0xd8, 0x63, 0x51, 0xb0,
	0x9f, 0x25, 0xfb, 0x69, 0x7f, 0x9d, 0x86, 0x4a, 0xdc, 0x6c, 0xe4, 0x29, 0x54, 0x2d, 0xf7, 0x8d,
	0xd3, 0x77, 0x4d, 0xcb, 0xe0, 0xf0, 0x5a, 0x6e, 0xd9, 0xb5, 0xb1, 0xdb, 0xbe, 0x29, 0xa1, 0xb5,
	0x5e, 0x51, 0xf2, 0xfc, 0xfe, 0x93, 0x5f, 0x42, 0xc5, 0x13, 0xfa, 0x44, 0xf7, 0xf4, 0x69, 0xdd,
	0xcb, 0x52, 0x1c, 0x7b, 0x3f, 0x81, 0xf2, 0xd0, 0x8b, 0xc6, 0xce, 0x9c, 0xd6, 0x19, 0x84, 0x34,
	0xf6, 0xfd, 0x09, 0xcc, 0x84, 0x33, 0xef, 0x1c, 0x07, 0x94, 0xa1, 0xad, 0x32, 0x7a, 0xb8, 0x9e,
	0x75, 0x4e, 0x24, 0x77, 0xa1, 0x22, 0x87, 0x10, 0x42, 0x39, 0x14, 0x92, 0xc3, 0xa2, 0x88, 0xf6,
	0xdb, 0x34, 0x2c, 0x86, 0xfb, 0x98, 0xb0, 0xce, 0xe3, 0xc9, 0xd6, 0x09, 0x5d, 0x43, 0xd8, 0x6b,
	0xc4, 0x2a, 0x1f, 0x4d, 0xb4, 0xca, 0x84, 0x6e, 0x09, 0x6b, 0xac, 0x4e, 0xb2, 0xc6, 0x84, 0x4e,
	0x71, 0x2b, 0xfc, 0x62, 0xa2, 0x15, 0x26, 0x76, 0x1b, 0x31, 0xcc, 0x47, 0x13, 0x0c, 0x33, 0x79,
	0x8e, 0x71, 0x5b, 0x7d, 0x9f, 0x82, 0xca, 0xd7, 0xae, 0x7f, 0x48, 0x7d, 0x6e, 0xa1, 0x21, 0x5e,
	0xb8, 0x37, 0xd8, 0xe6, 0x17, 0x44, 0x80, 0xdb, 0xca, 0xdb, 0x1f, 0x6e, 0x17, 0x85, 0xd0, 0xd6,
	0xa6, 0x5e, 0x14, 0xec, 0x2d, 0x8b, 0x83, 0xe0, 0xd7, 0x6e, 0xc7, 0x08, 0x1d, 0x08, 0x82, 0x60,
	0xee, 0x4a, 0x37, 0xf5, 0xdc, 0x6b, 0xb7, 0xb3, 0x65, 0x91, 0xc7, 0x50, 0x41, 0xe7, 0x80, 0xf7,
	0x77, 0xa8, 0x2e, 0xfc, 0xfc, 0x98, 0x6b, 0x18, 0x32, 0xbd, 0x6c, 0x45, 0x0d, 0xed, 0x35, 0x94,
	0x63, 0x3c, 0xf2, 0x11, 0x14, 0x30, 0x22, 0x51, 0x4b, 0x6e, 0xd8, 0xb4, 0xe0, 0xa5, 0x44, 0xb9,
	0xfb, 0x47, 0x7f, 0x20, 0x02, 0xd2, 0x5c, 0x22, 0x44, 0xa0, 0xeb, 0x40, 0xb6, 0xe6, 0x42, 0x45,
	0xa7, 0xcc, 0x1d, 0xfa, 0x5d, 0x8a, 0xbe, 0x98, 0x67, 0x67, 0xde, 0x10, 0x07, 0x4a, 0xeb, 0xfc,
	0x91, 0xdf, 0xef, 0x01, 0x1d, 0xb8, 0xbe, 0x4a, 0x10, 0x65, 0x8b, 0xdc, 0x85, 0x4c, 0xcf, 0x1b,
	0xca, 0x45, 0x85, 0x88, 0xea, 0xf9, 0xee, 0x1e, 0xd7, 0xa3, 0x73, 0x1e, 0x77, 0x17, 0x96, 0xcd,
	0x0e, 0x55, 0x98, 0xe6, 0xcf, 0xda, 0xcf, 0xa0, 0x20, 0x65, 0x42, 0xd0, 0x96, 0x8a, 0x40, 0x1b,
	0x1f, 0xcd, 0x19, 0x0e, 0x3a, 0xd4, 0xc7, 0xd1, 0x32, 0xba, 0x6c, 0x69, 0xbf, 0x06, 0x78, 0xe1,
	0x76, 0x5a, 0x34, 0x40, 0x97, 0xfc, 0x53, 0x0e, 0x88, 0x3a, 0x06, 0xa3, 0x81, 0x34, 0xc9, 0x4c,
	0xcc, 0xb7, 0xb7, 0x68, 0xc0, 0x01, 0x12, 0xff, 0x4f, 0xde, 0xe1, 0x61, 0xb9, 0xa3, 0x30, 0xf3,
	0x6c, 0x4c, 0x4a, 0x38, 0x45, 0xce, 0xd4, 0xfe, 0xa1, 0x02, 0x05, 0x49, 0x39, 0x2d, 0x62, 0x3c,
	0x80, 0x9a, 0xca, 0x00, 0x8c, 0x23, 0xea, 0x33, 0x1e, 0x84, 0xd3, 0x18, 0xb2, 0x66, 0x15, 0xfd,
	0x2b, 0x41, 0x26, 0x8f, 0xa0, 0xea, 0x0e, 0x03, 0x6f, 0x18, 0x18, 0x31, 0x08, 0x33, 0x1e, 0x3f,
	0x2b, 0x42, 0x48, 0xb4, 0x48, 0x1d, 0x0a, 0x3e, 0x15, 0x40, 0x25, 0x8b, 0x6a, 0x55, 0x13, 0x1d,
	0x84, 0x19, 0x98, 0x86, 0xbc, 0x62, 0xd4, 0x92, 0x77, 0xbf, 0xca, 0xa9, 0xbb, 0x8a, 0xc8, 0x1d,
	0x04, 0x8a, 0xb1, 0x43, 0xdb, 0xf3, 0xa8, 0x70, 0xf2, 0x19, 0x3c, 0x5e, 0x66, 0x4b, 0x90, 0x38,
	0x68, 0x44, 0x91, 0xc0, 0x0d, 0xcc, 0x3e, 0x82, 0xc6, 0x8c, 0x5e, 0xe2, 0x94, 0x36, 0x27, 0x70,
	0x14, 0x88, 0xec, 0x7d, 0xd3, 0xee, 0x53, 0x0b, 0x71, 0x63, 0x46, 0xc7, 0x1e, 0xcf, 0x90, 0x12,
	0xce, 0xc4, 0xa7, 0x5d, 0x8e, 0xaf, 0xa8, 0x85, 0x20, 0x52, 0xce, 0x44, 0x57, 0xc4, 0x28, 0xce,
	0xc1, 0xe9, 0x71, 0xee, 0x9e, 0x8a, 0x9e, 0x65, 0x8c, 0x9e, 0xb5, 0xf8, 0x6e, 0xc6, 0x63, 0xe7,
	0x12, 0xe4, 0x7d, 0x6a, 0x32, 0xd7, 0x91, 0x59, 0xaf, 0x6c, 0xf1, 0x2b, 0xd2, 0xf5, 0xa9, 0xc9,
	0xaf, 0x48, 0xf5, 0xf4, 0x2b, 0x22, 0x45, 0xe3, 0x17, 0x6b, 0xe6, 0xec, 0x17, 0xeb, 0x31, 0x14,
	0xf7, 0x6d, 0xc7, 0x66, 0x07, 0xd4, 0xaa, 0xcf, 0x9e, 0xda, 0x2d, 0x94, 0x25, 0x1f, 0x42, 0xc1,
	0xa2, 0x81, 0x69, 0xf7, 0x59, 0xbd, 0x86, 0xdd, 0xae, 0x8e, 0x9c, 0xc6, 0xe5, 0x4d, 0xc1, 0xd6,
	0x95, 0x5c, 0xe3, 0xaf, 0x0a, 0x50, 0x90, 0x44, 0xb2, 0x02, 0xa5, 0x40, 0x15, 0x3e, 0x46, 0x1d,
	0x77, 0x58, 0x11, 0xd1, 0x23, 0x19, 0xb2, 0x0e, 0x35, 0x2f, 0x02, 0x5a, 0x06, 0xe2, 0xe5, 0x74,
	0x72, 0xe0, 0x11, 0x20, 0xa6, 0xcf, 0x7a, 0x23, 0xc8, 0xec, 0x1e, 0xe4, 0x29, 0x26, 0xcf, 0xd1,
	0xe1, 0x15, 0x3d, 0x45, 0x4a, 0xad, 0x4b, 0x6e, 0x3c, 0xc3, 0xca, 0x4e, 0xcf, 0xb0, 0x38, 0x9a,
	0x62, 0x3c, 0x2b, 0x93, 0x1e, 0x3a, 0x44, 0x53, 0x98, 0xaa, 0xe9, 0x82, 0x47, 0x3e, 0x86, 0xaa,
	0x74, 0xc3, 0xd2, 0x75, 0xe6, 0xf1, 0xfe, 0x86, 0x67, 0x28, 0xee, 0xb3, 0xf5, 0xca, 0x9b, 0xb8,
	0x07, 0x5f, 0x83, 0x39, 0x5f, 0x3a, 0x34, 0xc3, 0xa7, 0xdf, 0x0e, 0x29, 0x0b, 0x18, 0x1e, 0xf2,
	0x58, 0xf7, 0xb8, 0xc7, 0xd3, 0x6b, 0x4a, 0x5c, 0x97, 0xd2, 0xe4, 0x53, 0x98, 0x0d, 0x55, 0xf4,
	0xed, 0x81, 0x1d, 0x30, 0xbc, 0x05, 0x27, 0x29, 0x98, 0x51, 0xc2, 0xdb, 0x28, 0x4b, 0xb6, 0xe1,
	0x2a, 0xb3, 0x2d, 0xda, 0x35, 0x7d, 0x63, 0x54, 0x4d, 0x69, 0x8a, 0x9a, 0x45, 0xd9, 0x49, 0x4f,
	0x6a, 0x7b, 0x07, 0x72, 0x36, 0xf7, 0xd9, 0xf2, 0x1a, 0x8d, 0x62, 0x7d, 0x5b, 0x01, 0x77, 0x66,
	0xf6, 0x03, 0x55, 0x26, 0xe2, 0xcf, 0xe4, 0x09, 0x5e, 0x53, 0x1e, 0x7d, 0x68, 0x20, 0x76, 0xbf,
	0x92, 0x1c, 0x5d, 0xc4, 0x18, 0x1a, 0xe0, 0xe8, 0x22, 0x52, 0xc9, 0x16, 0xe2, 0x28, 0xec, 0xcb,
	0x43, 0x37, 0xdf, 0xac, 0xea, 0xe9, 0x38, 0x8a, 0xcb, 0xb7, 0x85, 0x38, 0x47, 0x42, 0xdc, 0x3f,
	0xab, 0xde, 0x33, 0xa7, 0x22, 0xa1, 0xd7, 0x6e, 0x47, 0xf5, 0x15, 0xfe, 0x87, 0x8f, 0xed, 0xdb,
	0x94, 0xe1, 0x15, 0x13, 0xfe, 0x67, 0x38, 0x68, 0x73, 0x0a, 0xf9, 0x0c, 0x66, 0x59, 0xf7, 0x80,
	0x5a, 0xc3, 0xbe, 0xed, 0xf4, 0xc4, 0xca, 0xc4, 0x85, 0x5a, 0x0a, 0xcf, 0x52, 0xc8, 0x16, 0x1b,
	0xc4, 0x12, 0x6d, 0x0e, 0x82, 0x3d, 0xd7, 0x12, 0x3d, 0xe7, 0x04, 0x08, 0xf6, 0x5c, 0x0b, 0x59,
	0xd7, 0xa1, 0xc4, 0x59, 0x9e, 0x19, 0x74, 0x0f, 0xea, 0x44, 0xa4, 0xf2, 0x9e, 0x6b, 0xed, 0xf2,
	0xb6, 0xf6, 0x1c, 0xf2, 0xe2, 0xe0, 0x4d, 0x4c, 0x94, 0x1e, 0x24, 0x33, 0x80, 0xf9, 0xf1, 0xb3,
	0xaa, 0xdc, 0x98, 0x76, 0x0b, 0x8a, 0xaa, 0xa2, 0x34, 0x49, 0x95, 0xf6, 0xaf, 0xb3, 0x50, 0x51,
	0x02, 0x18, 0x95, 0xce, 0x57, 0x9a, 0xaa, 0x43, 0x21, 0x19, 0x9b, 0x54, 0x93, 0xac, 0x40, 0x99,
	0xaf, 0x7a, 0x7a, 0x44, 0x02, 0x2e, 0x12, 0xc5, 0x23, 0x16, 0xb8, 0x18, 0x49, 0x44, 0x12, 0xa7,
	0x9a, 0xe4, 0x5d, 0xb5, 0xdc, 0x1c, 0x2e, 0x77, 0x71, 0x74, 0x3e, 0x27, 0xf8, 0xed, 0x7c, 0xc2,
	0x6f, 0x3f, 0x86, 0x99, 0xbe, 0xc9, 0x02, 0x03, 0x83, 0x39, 0x6a, 0x2b, 0x9e, 0x10, 0x00, 0x2a,
	0x5c, 0x4e, 0xb5, 0xc8, 0x1d, 0x28, 0xc7, 0x5c, 0x15, 0x5e, 0xab, 0xac, 0x1e, 0x27, 0x91, 0x9f,
	0x49, 0x6c, 0x01, 0xa8, 0xef, 0xee, 0xe8, 0xec, 0xd0, 0xdf, 0xaa, 0x46, 0xfb, 0xd8, 0xa3, 0x12,
	0x7e, 0xdc, 0x04, 0x30, 0x87, 0xc1, 0x81, 0x11, 0xb8, 0x87, 0xd4, 0x91, 0xd7, 0xa9, 0xc4, 0x29,
	0x6d, 0x4e, 0x20, 0x8f, 0x23, 0x1f, 0x2e, 0x2e, 0xd3, 0x8d, 0x89, 0x8a, 0xc7, 0x1c, 0xf9, 0x1f,
	0xe0, 0x12, 0x8e, 0x7c, 0x25, 0xac, 0xb6, 0xa6, 0x93, 0x2e, 0x00, 0x2b, 0xae, 0xe3, 0xc5, 0xd7,
	0x89, 0x9e, 0x3f, 0x73, 0x61, 0xcf, 0x9f, 0x9d, 0xea, 0xf9, 0x3f, 0x06, 0x90, 0xe1, 0xd4, 0x30,
	0x95, 0x4f, 0x9f, 0x16, 0x0f, 0x4b, 0x52, 0x7a, 0x2d, 0xe0, 0x50, 0xc5, 0xa7, 0x3c, 0x95, 0x33,
	0xa8, 0xef, 0xbb, 0xbe, 0x3c, 0x1a, 0x65, 0x41, 0x6b, 0x72, 0x12, 0x79, 0x17, 0xe6, 0x84, 0x73,
	0x67, 0xca, 0x97, 0x53, 0x4b, 0x22, 0x96, 0x9a, 0x64, 0xe8, 0x8a, 0x1e, 0x17, 0x36, 0x8f, 0x4c,
	0xbb, 0x6f, 0x76, 0xfa, 0x54, 0xc2, 0x17, 0x25, 0xbc, 0xa6, 0xe8, 0xe4, 0x9d, 0x10, 0x9d, 0xc9,
	0xea, 0x5c, 0x09, 0x47, 0x97, 0x68, 0x6c, 0x5d, 0xd4, 0xe8, 0x26, 0xc6, 0x12, 0xb8, 0x6c, 0x2c,
	0x29, 0xff, 0x38, 0xb1, 0xa4, 0x72, 0x89, 0x58, 0x52, 0x9d, 0x12, 0x4b, 0xee, 0x40, 0xd9, 0xa2,
	0xac, 0xeb, 0xdb, 0x1e, 0x77, 0xcd, 0xe8, 0xbb, 0x4b, 0x7a, 0x9c, 0x14, 0x46, 0x9b, 0x5a, 0x2c,
	0xda, 0x44, 0x37, 0x7c, 0x2e, 0x71, 0xc3, 0x63, 0xc8, 0x60, 0xfe, 0xac, 0xc8, 0x60, 0x61, 0x0a,
	0x32, 0x18, 0x8f, 0x6a, 0x8b, 0x17, 0x8f, 0x6a, 0x4b, 0x97, 0x8a, 0x6a, 0x57, 0x2f, 0x11, 0xd5,
	0xea, 0x67, 0x89, 0x6a, 0xd7, 0x2e, 0x1c, 0xd5, 0x1a, 0x53, 0xa2, 0xda, 0xf5, 0x64, 0x54, 0x23,
	0x8b, 0x90, 0x67, 0x8f, 0x0c, 0xbe, 0xa0, 0x1b, 0xe2, 0xcd, 0x13, 0x7b, 0xf4, 0x6a, 0x18, 0xf0,
	0x90, 0x33, 0x90, 0x6f, 0x16, 0xea, 0x37, 0x93, 0x21, 0x47, 0xbd, 0x71, 0xd0, 0x43, 0x09, 0x9e,
	0x13, 0xf8, 0x54, 0x15, 0x09, 0x70, 0x0a, 0xb7, 0x70, 0x98, 0x6a, 0x48, 0xc5, 0x89, 0xfc, 0x14,
	0x66, 0x87, 0x4e, 0xb7, 0x6f, 0xda, 0x03, 0x6a, 0x19, 0x81, 0xc9, 0x0e, 0x59, 0xfd, 0x36, 0x5a,
	0x62, 0x26, 0x24, 0xb7, 0x39, 0x95, 0xcf, 0x58, 0x02, 0x40, 0xbf, 0x5b, 0xbf, 0x23, 0x66, 0x2c,
	0x08, 0x7a, 0x97, 0x9f, 0x50, 0x73, 0x18, 0xb8, 0xac, 0x6b, 0xf2, 0xc5, 0xd7, 0xef, 0xe2, 0xb4,
	0xe3, 0x24, 0xed, 0xbb, 0x28, 0x7e, 0x62, 0x11, 0xfe, 0x1a, 0x2c, 0xee, 0x6e, 0xed, 0x36, 0xb7,
	0xb7, 0x76, 0xda, 0x46, 0xfb, 0x9b, 0xdd, 0xa6, 0xb1, 0xb7, 0xf3, 0x72, 0xe7, 0xd5, 0xd7, 0x3b,
	0xb5, 0x2b, 0xe4, 0x3a, 0x5c, 0x95, 0xac, 0xa6, 0x60, 0xb5, 0xf5, 0xb5, 0x9d, 0xd6, 0xb3, 0x57,
	0xfa, 0x17, 0xb5, 0x14, 0xb9, 0x0a, 0xf3, 0x49, 0x66, 0x6b, 0xf7, 0xd5, 0x5e, 0xbb, 0x96, 0x8e,
	0x29, 0x54, 0x8c, 0xa6, 0xfe, 0xd5, 0xd6, 0x46, 0xb3, 0x96, 0x79, 0x91, 0x2d, 0x16, 0x6a, 0x45,
	0xed, 0x05, 0x54, 0xe3, 0x21, 0x81, 0x3b, 0xca, 0x6a, 0x98, 0x39, 0xda, 0xce, 0xbe, 0x2b, 0x5f,
	0x03, 0x2d, 0x4c, 0x0a, 0x20, 0x7a, 0xc5, 0x8b, 0xb5, 0xb4, 0x3b, 0x90, 0x17, 0x69, 0xad, 0x2c,
	0x58, 0xa6, 0xc6, 0x0a, 0x96, 0x03, 0x58, 0xd8, 0x72, 0xb8, 0xd9, 0x03, 0x99, 0xff, 0x0a, 0xf7,
	0x73, 0xf6, 0x3c, 0x99, 0x40, 0xf6, 0x8d, 0x29, 0x6b, 0xbc, 0x45, 0x1d, 0x9f, 0x79, 0xec, 0x57,
	0xc1, 0x2e, 0x23, 0x62, 0xbf, 0x6c, 0x6a, 0xef, 0xc3, 0xdc, 0xb6, 0xcd, 0x46, 0xc6, 0x8a, 0x89,
	0xa7, 0x92, 0xe2, 0xbf, 0x81, 0xb9, 0x68, 0x76, 0x4a, 0xfc, 0x94, 0x44, 0xfb, 0x7c, 0x13, 0xfa,
	0x5d, 0x0a, 0x66, 0xe4, 0x8c, 0x94, 0xfe, 0xf3, 0x41, 0xa6, 0x0f, 0xa1, 0x82, 0xde, 0xcf, 0x08,
	0x6b, 0xdd, 0x99, 0x09, 0xc8, 0xa8, 0x8c, 0x32, 0x11, 0x34, 0x3a, 0xb0, 0x59, 0xe0, 0xfa, 0xc7,
	0xb2, 0x54, 0xa7, 0x9a, 0xf1, 0x79, 0xe6, 0x12, 0xf3, 0x24, 0x0d, 0x28, 0xbe, 0xfe, 0xf6, 0x99,
	0xdd, 0x0f, 0xa8, 0x0a, 0x77, 0x61, 0x5b, 0xfb, 0x13, 0x98, 0x6f, 0x0d, 0x3b, 0xdc, 0xcb, 0x76,
	0xe8, 0x85, 0xd7, 0x11, 0x1b, 0x3a, 0x9d, 0x34, 0xd1, 0x87, 0x50, 0xdb, 0xa4, 0x7d, 0x1a, 0xd0,
	0x33, 0xef, 0x81, 0xf6, 0x1c, 0x66, 0x5a, 0x81, 0xeb, 0x9d, 0x7d, 0xd3, 0xa2, 0x20, 0x90, 0x89,
	0x07, 0x01, 0xed, 0x0f, 0x69, 0x58, 0xdc, 0xf3, 0x2c, 0x13, 0x07, 0x17, 0x78, 0xee, 0x6c, 0x0a,
	0xef, 0x25, 0x31, 0xf5, 0x19, 0xea, 0x02, 0x89, 0x81, 0xe3, 0xe5, 0x94, 0xdc, 0x69, 0xe5, 0x94,
	0xfc, 0x59, 0xca, 0x29, 0x85, 0xf1, 0x72, 0xca, 0x8f, 0x55, 0x2f, 0x49, 0x96, 0x65, 0x60, 0xb4,
	0x2c, 0x13, 0x96, 0x53, 0xca, 0xa7, 0x96, 0x53, 0xb4, 0x7f, 0x4b, 0xc3, 0xcc, 0x73, 0x1a, 0x6c,
	0xbb, 0x3d, 0x76, 0xb1, 0x63, 0x24, 0xb7, 0x25, 0x7d, 0xc2, 0xb6, 0x28, 0xab, 0xec, 0xe3, 0xc9,
	0x65, 0xf2, 0xab, 0x0d, 0x34, 0x83, 0x38, 0xcc, 0x2c, 0x7a, 0x69, 0x92, 0x9d, 0xf2, 0xd2, 0x64,
	0x09, 0xf2, 0x03, 0x93, 0xf1, 0xcb, 0x20, 0xee, 0x89, 0x6c, 0x71, 0xfa, 0xbe, 0xdb, 0xef, 0xbb,
	0x6f, 0x70, 0x53, 0x8a, 0xba, 0x6c, 0x61, 0xc1, 0xd0, 0xb4, 0x55, 0xcd, 0x0a, 0x9f, 0xc9, 0x7d,
	0xa8, 0x0d, 0x19, 0x35, 0xfa, 0xee, 0xa1, 0x6d, 0x74, 0xcc, 0xee, 0x21, 0x75, 0xc4, 0x1e, 0x14,
	0xf5, 0x99, 0x21, 0xa3, 0xdb, 0xee, 0xa1, 0xbd, 0x2e, 0xa8, 0x64, 0x05, 0x72, 0xcc, 0x76, 0xba,
	0x54, 0x66, 0xe1, 0x53, 0x02, 0xb7, 0x90, 0xd3, 0xfe, 0x25, 0x0d, 0xb0, 0xed, 0xf6, 0xbe, 0xa0,
	0x8c, 0x99, 0x3d, 0x84, 0x8c, 0xa1, 0x07, 0x8f, 0xa5, 0x6c, 0xa1, 0xaf, 0xde, 0xe1, 0x59, 0xe0,
	0xe9, 0x55, 0xe1, 0x44, 0x89, 0x39, 0x33, 0xb5, 0xc4, 0x7c, 0x0f, 0x8a, 0x02, 0x34, 0xd8, 0x22,
	0xfd, 0x2a, 0xad, 0x97, 0xdf, 0xfe, 0x70, 0xbb, 0x20, 0x5e, 0x4d, 0x6d, 0xea, 0x05, 0x64, 0x6e,
	0x59, 0x27, 0xda, 0x51, 0xd5, 0x80, 0xf3, 0x53, 0x6b, 0xc0, 0xe1, 0x47, 0x26, 0xe2, 0xfd, 0xb1,
	0xf8, 0xc8, 0xe4, 0x21, 0xa4, 0xc3, 0xb2, 0xc7, 0x34, 0x3c, 0x9f, 0x0e, 0x18, 0xbf, 0x65, 0x03,
	0x61, 0x23, 0x89, 0xa2, 0x55, 0x53, 0xfb, 0x1a, 0xe6, 0x75, 0x71, 0xe1, 0xc4, 0xbe, 0x9f, 0xed,
	0xd6, 0x8f, 0x1e, 0xaf, 0xf4, 0xd8, 0xf1, 0xd2, 0x9e, 0xc0, 0xbc, 0x0c, 0x29, 0x09, 0xc5, 0x67,
	0x79, 0x55, 0xa7, 0x7d, 0x05, 0x35, 0x1e, 0x2b, 0xce, 0x33, 0xa3, 0x10, 0x38, 0xa7, 0x4f, 0x06,
	0xce, 0x9a, 0x05, 0x95, 0x38, 0xf8, 0x8c, 0x95, 0xb2, 0x53, 0xf1, 0x52, 0x36, 0xbf, 0xe8, 0xcc,
	0xfe, 0x8e, 0xca, 0x17, 0x15, 0xa2, 0xcc, 0x5d, 0xe2, 0x14, 0xf1, 0x26, 0xe3, 0x26, 0x80, 0x47,
	0x7d, 0x43, 0x1c, 0x02, 0x3c, 0x20, 0x19, 0xbd, 0xe4, 0x51, 0x5f, 0x9c, 0x0f, 0xed, 0xf7, 0x29,
	0x98, 0x49, 0x22, 0x41, 0xf2, 0x05, 0x54, 0x1d, 0xd7, 0xa2, 0x06, 0xa3, 0x7d, 0xda, 0x0d, 0x5c,
	0x5f, 0x42, 0x8b, 0xfb, 0x93, 0x81, 0xe3, 0xf2, 0x8e, 0x6b, 0xd1, 0x96, 0x14, 0x15, 0x5f, 0x8b,
	0x54, 0x9c, 0x18, 0x89, 0x2c, 0xc3, 0xbc, 0xe7, 0xdb, 0xae, 0x6f, 0x07, 0xc7, 0x46, 0xb7, 0x6f,
	0x32, 0x26, 0x4e, 0xbb, 0xa8, 0xfe, 0xcf, 0x29, 0xd6, 0x06, 0xe7, 0xf0, 0x23, 0xdf, 0xf8, 0x0c,
	0xe6, 0xc6, 0x54, 0x9e, 0xeb, 0x4b, 0x91, 0xff, 0x2b, 0xc1, 0xe2, 0x06, 0xa6, 0x85, 0xa1, 0x2b,
	0xba, 0x90, 0xd7, 0x3a, 0x77, 0xa2, 0x9c, 0x48, 0xc5, 0x33, 0x17, 0xac, 0xa9, 0x66, 0x2f, 0x9c,
	0x59, 0xe7, 0xa6, 0x66, 0xd6, 0x4b, 0x90, 0x1f, 0x62, 0xcc, 0x54, 0x4e, 0x50, 0xb4, 0xc6, 0x33,
	0xd7, 0xc2, 0x84, 0xcc, 0x35, 0x02, 0xf5, 0xc5, 0x38, 0xa8, 0x9f, 0x98, 0xd0, 0x96, 0x2e, 0x9b,
	0xd0, 0xc2, 0x8f, 0x93, 0xd0, 0x96, 0x2f, 0x91, 0xd0, 0x56, 0xce, 0x9e, 0xd0, 0x56, 0xc7, 0x13,
	0xda, 0x1b, 0xf8, 0x01, 0x8f, 0x08, 0xa4, 0x58, 0x70, 0x2c, 0xea, 0x11, 0x21, 0x9e, 0xc2, 0xce,
	0x9d, 0x35, 0x85, 0x25, 0xe7, 0x4a, 0x61, 0xe7, 0x2f, 0x9e, 0xc2, 0x2e, 0x5c, 0x2a, 0x85, 0x5d,
	0x3c, 0x4f, 0x0a, 0xab, 0xd2, 0xfe, 0xa5, 0x58, 0xda, 0x3f, 0x92, 0xd6, 0x5e, 0x3d, 0x4b, 0x5a,
	0x5b, 0xbf, 0x70, 0x5a, 0x7b, 0x6d, 0x4a, 0x5a, 0xdb, 0x18, 0x49, 0x6b, 0x47, 0x4a, 0x9d, 0xd7,
	0x4f, 0x2d, 0x75, 0xc6, 0x13, 0xde, 0x1b, 0x17, 0x48, 0x78, 0x6f, 0x4e, 0x4a, 0x78, 0x47, 0x52,
	0xd5, 0x5b, 0xe3, 0xa9, 0xea, 0x6f, 0x60, 0x49, 0x46, 0xb2, 0xcb, 0x39, 0xbf, 0x93, 0x91, 0xff,
	0xf7, 0x29, 0x98, 0xe7, 0x01, 0xef, 0xd2, 0xfa, 0x55, 0xba, 0x93, 0x3e, 0x31, 0xdd, 0xc9, 0x9c,
	0x9c, 0xee, 0x64, 0x47, 0xd2, 0x9d, 0xbf, 0x4c, 0xc1, 0xa2, 0x48, 0x48, 0x2e, 0x37, 0xaf, 0x1a,
	0x64, 0xcc, 0x7e, 0x5f, 0xae, 0x99, 0x3f, 0xf2, 0x40, 0xb3, 0xef, 0xfa, 0x5d, 0x2a, 0x67, 0x23,
	0x1a, 0xfc, 0xb0, 0x1c, 0x52, 0xea, 0x19, 0xf8, 0x8d, 0x99, 0xa8, 0x65, 0x17, 0x39, 0x41, 0xa7,
	0x9e, 0xab, 0x6d, 0xc2, 0x42, 0x8b, 0xa3, 0x94, 0x4b, 0x4d, 0x45, 0xdb, 0x80, 0x79, 0x9e, 0x2f,
	0x5d, 0x4e, 0xc9, 0xdf, 0xa4, 0x80, 0xe8, 0x43, 0xe7, 0x72, 0x46, 0x59, 0x06, 0xf0, 0x7c, 0xf7,
	0x88, 0x3a, 0x26, 0xc7, 0xbb, 0x93, 0x93, 0xd9, 0x98, 0x44, 0x0c, 0xb5, 0x66, 0x26, 0xa3, 0x56,
	0xed, 0x29, 0xcc, 0xe8, 0x43, 0x67, 0xc3, 0x77, 0x9d, 0x8b, 0x2d, 0xeb, 0x01, 0xcc, 0x8b, 0x10,
	0x2f, 0x3e, 0xa8, 0x56, 0x4a, 0x08, 0x64, 0xf1, 0x23, 0xe5, 0x94, 0xf8, 0x7a, 0x8b, 0x3f, 0x6b,
	0x9f, 0xc2, 0xbc, 0x38, 0x18, 0x49, 0xd1, 0x7b, 0x90, 0x17, 0x1f, 0x69, 0x8f, 0x96, 0x32, 0xa4,
	0x98, 0xe4, 0x6a, 0x4f, 0xc3, 0x5a, 0xc8, 0xc5, 0xfa, 0xdf, 0x80, 0xbc, 0xa0, 0x4c, 0x7c, 0x35,
	0xf3, 0x7d, 0x0a, 0x40, 0xb0, 0xf1, 0xc5, 0xcc, 0x19, 0x95, 0x86, 0x9f, 0x3a, 0xa4, 0x63, 0x9f,
	0x3a, 0x6c, 0x01, 0xc1, 0x62, 0xb8, 0xed, 0x3a, 0x46, 0xf8, 0x5b, 0x00, 0x09, 0x43, 0xa6, 0x41,
	0xee, 0x39, 0xd5, 0x2b, 0x24, 0x69, 0xeb, 0xea, 0x23, 0x7f, 0x51, 0x6b, 0x7a, 0x04, 0x65, 0x31,
	0x6e, 0xbc, 0xd2, 0x44, 0x92, 0x53, 0xc3, 0x3a, 0x13, 0xb0, 0xf0, 0x59, 0x5b, 0x84, 0xf9, 0xb5,
	0x6e, 0x60, 0x1f, 0x99, 0x01, 0x5d, 0x1b, 0x06, 0x07, 0xd2, 0x6c, 0xda, 0x12, 0x2c, 0x24, 0xc9,
	0xcc, 0x73, 0x1d, 0x46, 0xb5, 0xbf, 0x13, 0xe7, 0x74, 0xdb, 0x35, 0xad, 0x36, 0x65, 0xa1, 0x95,
	0xaf, 0xf1, 0x94, 0x45, 0x3a, 0x7a, 0x61, 0xb7, 0x82, 0x65, 0xf6, 0x94, 0xbb, 0xc6, 0x0f, 0x74,
	0xc2, 0x37, 0xd1, 0x25, 0xbd, 0xc8, 0x09, 0xea, 0x5b, 0x10, 0x46, 0xa9, 0x25, 0xf1, 0x2e, 0x3e,
	0x8f, 0xbe, 0xe5, 0x11, 0x55, 0x96, 0xc4, 0x5b, 0x9e, 0x44, 0x04, 0xc8, 0x8d, 0xbc, 0xae, 0x7b,
	0x17, 0xe6, 0x13, 0x13, 0x14, 0x13, 0xe7, 0xee, 0x41, 0xbc, 0x6f, 0x90, 0xbf, 0x4a, 0xc0, 0x86,
	0xf6, 0xdb, 0x14, 0x2c, 0xea, 0xd4, 0xb1, 0xa8, 0xdf, 0xa6, 0x03, 0xaf, 0x1f, 0x2b, 0x51, 0x34,
	0xa0, 0x18, 0x48, 0x92, 0xec, 0x12, 0xb6, 0xc9, 0x27, 0x90, 0x35, 0xfd, 0x9e, 0xfa, 0xbc, 0xe4,
	0xa7, 0x11, 0x74, 0x99, 0xa0, 0x68, 0x79, 0xcd, 0xef, 0xc9, 0xaf, 0xb3, 0xb1, 0x53, 0xe3, 0xe7,
	0x50, 0x0a, 0x49, 0xe7, 0xc2, 0xcb, 0x26, 0x2c, 0x8d, 0x8e, 0x20, 0xd7, 0x46, 0x20, 0xfb, 0x9a,
	0xb9, 0x8e, 0x3a, 0xb1, 0xfc, 0x99, 0x3c, 0xe2, 0x98, 0x84, 0x76, 0xd5, 0x24, 0x6f, 0x46, 0x1f,
	0x82, 0x4e, 0x40, 0xdc, 0xba, 0x90, 0x7d, 0xf8, 0xbb, 0x14, 0x7e, 0x16, 0x2a, 0xde, 0xb6, 0x2d,
	0xc2, 0xdc, 0x8b, 0x57, 0xeb, 0x46, 0xab, 0xbd, 0xd6, 0x8e, 0x57, 0x4e, 0x67, 0xa1, 0xcc, 0xc9,
	0x1b, 0x7a, 0x73, 0xad, 0xdd, 0xdc, 0xac, 0xa5, 0x48, 0x0d, 0x2a, 0x52, 0x4e, 0x6f, 0x6f, 0xed,
	0x3c, 0xaf, 0xa5, 0x95, 0x88, 0xbe, 0xb7, 0xb3, 0xc3, 0x09, 0x19, 0x45, 0x78, 0xb6, 0xb6, 0xb5,
	0xbd, 0xa7, 0x37, 0x6b, 0x59, 0x45, 0x68, 0xed, 0x6d, 0x6c, 0x34, 0x5b, 0xad, 0x5a, 0x8e, 0xcc,
	0x00, 0x70, 0xc2, 0xcb, 0xad, 0xed, 0xed, 0xe6, 0x66, 0x2d, 0x4f, 0xe6, 0xa0, 0xca, 0xdb, 0xcd,
	0xe7, 0x7a, 0xb3, 0xd5, 0xe2, 0x4a, 0x0a, 0x8a, 0xf4, 0x6c, 0x6b, 0x67, 0xab, 0xf5, 0x39, 0x27,
	0x15, 0x09, 0x81, 0x19, 0x4e, 0xda, 0xdb, 0xe1, 0x43, 0xad, 0xad, 0x6f, 0x37, 0x6b, 0xa5, 0x87,
	0x7f, 0x0c, 0x10, 0x7d, 0x7d, 0x49, 0xca, 0x50, 0x88, 0xa6, 0x0e, 0x90, 0xe7, 0x53, 0xc0, 0x59,
	0x97, 0xa1, 0xa0, 0x46, 0x4f, 0x63, 0xe3, 0xe5, 0xd6, 0xee, 0x6e, 0x73, 0xb3, 0x96, 0x21, 0x15,
	0x28, 0x86, 0x6b, 0xc9, 0x92, 0x2a, 0x94, 0xf4, 0xe6, 0xc6, 0xab, 0xaf, 0x9a, 0x7a, 0x73, 0xb3,
	0x96, 0x7b, 0xf8, 0x0d, 0x94, 0x63, 0x6f, 0x76, 0x49, 0x1d, 0x16, 0xbe, 0x7e, 0xa5, 0xbf, 0x6c,
	0xea, 0x93, 0xcc, 0xb4, 0xfb, 0x6a, 0x33, 0xb4, 0x41, 0x4a, 0x11, 0xa2, 0x41, 0x67, 0x00, 0x38,
	0x41, 0xce, 0x28, 0xf3, 0xf0, 0x3f, 0x52, 0x51, 0xf1, 0x58, 0x68, 0x6f, 0xc0, 0x52, 0x58, 0x6e,
	0x1e, 0xd5, 0xbf, 0x08, 0x73, 0x71, 0x9e, 0x98, 0x6e, 0x8a, 0x2c, 0x40, 0x2d, 0x24, 0xab, 0xb1,
	0xd3, 0x89, 0x82, 0xb6, 0xde, 0x0c, 0xc5, 0x33, 0x09, 0xf1, 0x68, 0x77, 0xe6, 0x61, 0x36, 0xa4,
	0xee, 0xae, 0xed, 0xb5, 0xf8, 0xca, 0x13, 0xa2, 0xad, 0xf6, 0xda, 0xce, 0xe6, 0xfa, 0x37, 0xb5,
	0x7c, 0x62, 0x1a, 0x1b, 0xfa, 0x9a, 0xd8, 0x98, 0xc2, 0xea, 0x5f, 0xd4, 0x20, 0xb3, 0xb6, 0xbb,
	0x45, 0x9e, 0x00, 0x44, 0x35, 0x60, 0x72, 0x2d, 0x02, 0xea, 0x23, 0x75, 0xe1, 0xc6, 0xe8, 0x37,
	0x5a, 0xda, 0x15, 0xb2, 0x0e, 0xd5, 0x44, 0x75, 0x9b, 0xdc, 0x18, 0xef, 0x1e, 0x15, 0xa2, 0x27,
	0x68, 0xf8, 0x20, 0x45, 0x1e, 0x43, 0x41, 0x16, 0x88, 0x49, 0x88, 0x3c, 0x93, 0x15, 0xe3, 0xc9,
	0xfd, 0x3e, 0x03, 0x88, 0x4a, 0xdd, 0xd1, 0xbc, 0xc7, 0xca, 0xdf, 0x0d, 0x92, 0xac, 0xac, 0x87,
	0x0a, 0x7e, 0x05, 0x95, 0x78, 0x59, 0x97, 0x5c, 0x0f, 0xdd, 0xf0, 0x78, 0xb1, 0xf7, 0xa4, 0x29,
	0x94, 0xc2, 0xca, 0x2d, 0xa9, 0x87, 0x49, 0xc2, 0x48, 0x31, 0xb7, 0xb1, 0x34, 0x16, 0x32, 0x9a,
	0x03, 0x2f, 0x38, 0xd6, 0xae, 0x90, 0x4f, 0xa0, 0x20, 0xeb, 0xb8, 0xd1, 0xda, 0x93, 0x85, 0xdd,
	0x29, 0x9d, 0x7f, 0x05, 0x95, 0x78, 0xa5, 0x25, 0x9a, 0xff, 0x84, 0xfa, 0x4b, 0x63, 0x2e, 0x91,
	0xc2, 0xc8, 0xed, 0xfb, 0x25, 0x94, 0xc2, 0x7a, 0x4b, 0x34, 0xff, 0xd1, 0x12, 0xcc, 0xc4, 0xbe,
	0x1f, 0xa4, 0x48, 0x13, 0x3f, 0x50, 0x0c, 0x4b, 0x48, 0xd1, 0xf8, 0x13, 0x0a, 0x4b, 0x53, 0x96,
	0xb1, 0x05, 0x33, 0x49, 0x87, 0x47, 0xa6, 0x3b, 0xc2, 0xa9, 0xaa, 0x66, 0x47, 0x10, 0x3b, 0xb9,
	0x35, 0x62, 0x94, 0x51, 0x65, 0x13, 0xdf, 0xf2, 0x68, 0x57, 0xf8, 0xe2, 0xe2, 0xc8, 0x3c, 0x5a,
	0xdc, 0x04, 0xbc, 0x7e, 0x92, 0x92, 0x0f, 0x52, 0x7c, 0x71, 0x49, 0x28, 0x1d, 0x2d, 0x6e, 0x22,
	0xc4, 0x9e, 0xb2, 0xb8, 0xe7, 0x50, 0x4d, 0x20, 0xe1, 0xe8, 0xae, 0x4d, 0x02, 0xc8, 0x53, 0x14,
	0x35, 0xa1, 0x12, 0x07, 0xc3, 0xb1, 0x73, 0x3f, 0x0e, 0x91, 0xa7, 0xa8, 0xd9, 0x80, 0x72, 0x0c,
	0x0d, 0x93, 0xf0, 0x47, 0x80, 0xe3, 0x10, 0x79, 0xfa, 0x05, 0x90, 0xe0, 0x35, 0xba, 0x00, 0x49,
	0x34, 0x3b, 0x7d, 0x21, 0x71, 0xe4, 0x1a, 0x2d, 0x64, 0x02, 0x9e, 0x9d, 0xae, 0x26, 0x8e, 0x6a,
	0x23, 0x35, 0x13, 0xb0, 0xee, 0xd4, 0xa5, 0xa0, 0x3f, 0x92, 0x4a, 0x4e, 0x90, 0x6b, 0xcc, 0x8f,
	0x63, 0x3d, 0x86, 0xc6, 0xac, 0x26, 0xa0, 0xf1, 0x98, 0x23, 0x4d, 0xce, 0x62, 0x02, 0x62, 0xd4,
	0xae, 0x90, 0x4f, 0x95, 0x3b, 0x5a, 0xeb, 0xf7, 0x4f, 0x9c, 0xc0, 0xc9, 0x0b, 0xf8, 0x18, 0x0a,
	0xf2, 0xd5, 0x44, 0xb4, 0x17, 0xc9, 0x77, 0x15, 0xd1, 0xb8, 0x51, 0xf1, 0x1d, 0x8f, 0xf9, 0x4b,
	0xa8, 0xc4, 0xa1, 0x68, 0x64, 0xc2, 0x09, 0xb8, 0xb5, 0x71, 0x63, 0x32, 0x53, 0xa2, 0x57, 0x74,
	0x08, 0xc9, 0x57, 0x52, 0xd1, 0x9d, 0x99, 0xf8, 0xaa, 0x6a, 0xca, 0x92, 0x3e, 0xc7, 0x33, 0xaa,
	0x80, 0x66, 0xe2, 0x8c, 0x8e, 0xc0, 0xe3, 0xc6, 0xf5, 0x89, 0xbc, 0x70, 0x52, 0x2f, 0x13, 0x98,
	0x7a, 0x93, 0xee, 0x9b, 0xc3, 0xfe, 0xc9, 0xbb, 0x7c, 0x8a, 0xb2, 0x2f, 0x61, 0x26, 0x09, 0x13,
	0xa3, 0x15, 0x4e, 0x04, 0xa8, 0x8d, 0x5b, 0x27, 0xb1, 0x43, 0x95, 0x9f, 0x40, 0x91, 0x9f, 0xbe,
	0xb6, 0xc9, 0x0e, 0x49, 0x7d, 0x39, 0x30, 0xd9, 0xa1, 0xe9, 0xd9, 0xcb, 0x8a, 0x14, 0x79, 0x72,
	0xc5, 0xe1, 0x54, 0xe5, 0xa5, 0xd6, 0x7f, 0xfe, 0xef, 0x6f, 0x6f, 0xa5, 0x7e, 0xff, 0xf6, 0x56,
	0xea, 0xbf, 0xdf, 0xde, 0x4a, 0xfd, 0xfa, 0x41, 0xcf, 0x0e, 0x0e, 0x86, 0x9d, 0xe5, 0xae, 0x3b,
	0x58, 0xf1, 0xcc, 0xee, 0xc1, 0xb1, 0x45, 0xfd, 0xf8, 0xd3, 0xd1, 0xea, 0x0a, 0xf3, 0xbb, 0x2b,
	0x9e, 0xc7, 0x3a, 0x79, 0x5c, 0xf7, 0xa3, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0xb5, 0xaa, 0x1f,
	0x8b, 0x76, 0x3d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type APIClient interface {
	InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error)
	InspectJobSet(ctx context.Context, in *InspectJobSetRequest, opts ...grpc.CallOption) (API_InspectJobSetClient, error)
	// ListJob returns information about current and past Pachyderm jobs.
	ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobClient, error)
	ListJobSet(ctx context.Context, in *ListJobSetRequest, opts ...grpc.CallOption) (API_ListJobSetClient, error)
	SubscribeJob(ctx context.Context, in *SubscribeJobRequest, opts ...grpc.CallOption) (API_SubscribeJobClient, error)
	DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*types.Empty, error)
	StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*types.Empty, error)
	InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error)
	// ListDatum returns information about each datum fed to a Pachyderm job
	ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (API_ListDatumClient, error)
	RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*types.Empty, error)
	CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error)
	ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (API_ListPipelineClient, error)
	DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	RunPipeline(ctx context.Context, in *RunPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error)
	RunCron(ctx context.Context, in *RunCronRequest, opts ...grpc.CallOption) (*types.Empty, error)
	CreateSecret(ctx context.Context, in *CreateSecretRequest, opts ...grpc.CallOption) (*types.Empty, error)
	DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*types.Empty, error)
	ListSecret(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SecretInfos, error)
	InspectSecret(ctx context.Context, in *InspectSecretRequest, opts ...grpc.CallOption) (*SecretInfo, error)
	// DeleteAll deletes everything
	DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error)
	// An internal call that causes PPS to put itself into an auth-enabled state
	// (all pipeline have tokens, correct permissions, etcd)
	ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error)
	// An internal call used to move a job from one state to another
	UpdateJobState(ctx context.Context, in *UpdateJobStateRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// RunLoadTest runs a load test.
	RunLoadTest(ctx context.Context, in *RunLoadTestRequest, opts ...grpc.CallOption) (*RunLoadTestResponse, error)
	// RunLoadTestDefault runs the default load test.
	RunLoadTestDefault(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*RunLoadTestResponse, error)
	// RenderTemplate renders the provided template and arguments into a list of Pipeline specicifications
	RenderTemplate(ctx context.Context, in *RenderTemplateRequest, opts ...grpc.CallOption) (*RenderTemplateResponse, error)
	// ListTask lists PPS tasks
	ListTask(ctx context.Context, in *task.ListTaskRequest, opts ...grpc.CallOption) (API_ListTaskClient, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) InspectJob(ctx context.Context, in *InspectJobRequest, opts ...grpc.CallOption) (*JobInfo, error) {
	out := new(JobInfo)
	err := c.cc.Invoke(ctx, "/pps_v2.API/InspectJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectJobSet(ctx context.Context, in *InspectJobSetRequest, opts ...grpc.CallOption) (API_InspectJobSetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[0], "/pps_v2.API/InspectJobSet", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIInspectJobSetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_InspectJobSetClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPIInspectJobSetClient struct {
	grpc.ClientStream
}

func (x *aPIInspectJobSetClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ListJob(ctx context.Context, in *ListJobRequest, opts ...grpc.CallOption) (API_ListJobClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[1], "/pps_v2.API/ListJob", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListJobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListJobClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPIListJobClient struct {
	grpc.ClientStream
}

func (x *aPIListJobClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ListJobSet(ctx context.Context, in *ListJobSetRequest, opts ...grpc.CallOption) (API_ListJobSetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[2], "/pps_v2.API/ListJobSet", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListJobSetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListJobSetClient interface {
	Recv() (*JobSetInfo, error)
	grpc.ClientStream
}

type aPIListJobSetClient struct {
	grpc.ClientStream
}

func (x *aPIListJobSetClient) Recv() (*JobSetInfo, error) {
	m := new(JobSetInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SubscribeJob(ctx context.Context, in *SubscribeJobRequest, opts ...grpc.CallOption) (API_SubscribeJobClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[3], "/pps_v2.API/SubscribeJob", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPISubscribeJobClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_SubscribeJobClient interface {
	Recv() (*JobInfo, error)
	grpc.ClientStream
}

type aPISubscribeJobClient struct {
	grpc.ClientStream
}

func (x *aPISubscribeJobClient) Recv() (*JobInfo, error) {
	m := new(JobInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteJob(ctx context.Context, in *DeleteJobRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/DeleteJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopJob(ctx context.Context, in *StopJobRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/StopJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectDatum(ctx context.Context, in *InspectDatumRequest, opts ...grpc.CallOption) (*DatumInfo, error) {
	out := new(DatumInfo)
	err := c.cc.Invoke(ctx, "/pps_v2.API/InspectDatum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListDatum(ctx context.Context, in *ListDatumRequest, opts ...grpc.CallOption) (API_ListDatumClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[4], "/pps_v2.API/ListDatum", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListDatumClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListDatumClient interface {
	Recv() (*DatumInfo, error)
	grpc.ClientStream
}

type aPIListDatumClient struct {
	grpc.ClientStream
}

func (x *aPIListDatumClient) Recv() (*DatumInfo, error) {
	m := new(DatumInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) RestartDatum(ctx context.Context, in *RestartDatumRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/RestartDatum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreatePipeline(ctx context.Context, in *CreatePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/CreatePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectPipeline(ctx context.Context, in *InspectPipelineRequest, opts ...grpc.CallOption) (*PipelineInfo, error) {
	out := new(PipelineInfo)
	err := c.cc.Invoke(ctx, "/pps_v2.API/InspectPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListPipeline(ctx context.Context, in *ListPipelineRequest, opts ...grpc.CallOption) (API_ListPipelineClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[5], "/pps_v2.API/ListPipeline", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListPipelineClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListPipelineClient interface {
	Recv() (*PipelineInfo, error)
	grpc.ClientStream
}

type aPIListPipelineClient struct {
	grpc.ClientStream
}

func (x *aPIListPipelineClient) Recv() (*PipelineInfo, error) {
	m := new(PipelineInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeletePipeline(ctx context.Context, in *DeletePipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/DeletePipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartPipeline(ctx context.Context, in *StartPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/StartPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StopPipeline(ctx context.Context, in *StopPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/StopPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunPipeline(ctx context.Context, in *RunPipelineRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/RunPipeline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunCron(ctx context.Context, in *RunCronRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/RunCron", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateSecret(ctx context.Context, in *CreateSecretRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/CreateSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteSecret(ctx context.Context, in *DeleteSecretRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/DeleteSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListSecret(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*SecretInfos, error) {
	out := new(SecretInfos)
	err := c.cc.Invoke(ctx, "/pps_v2.API/ListSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectSecret(ctx context.Context, in *InspectSecretRequest, opts ...grpc.CallOption) (*SecretInfo, error) {
	out := new(SecretInfo)
	err := c.cc.Invoke(ctx, "/pps_v2.API/InspectSecret", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/DeleteAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetLogs(ctx context.Context, in *GetLogsRequest, opts ...grpc.CallOption) (API_GetLogsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[6], "/pps_v2.API/GetLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetLogsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetLogsClient interface {
	Recv() (*LogMessage, error)
	grpc.ClientStream
}

type aPIGetLogsClient struct {
	grpc.ClientStream
}

func (x *aPIGetLogsClient) Recv() (*LogMessage, error) {
	m := new(LogMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error) {
	out := new(ActivateAuthResponse)
	err := c.cc.Invoke(ctx, "/pps_v2.API/ActivateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) UpdateJobState(ctx context.Context, in *UpdateJobStateRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pps_v2.API/UpdateJobState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunLoadTest(ctx context.Context, in *RunLoadTestRequest, opts ...grpc.CallOption) (*RunLoadTestResponse, error) {
	out := new(RunLoadTestResponse)
	err := c.cc.Invoke(ctx, "/pps_v2.API/RunLoadTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunLoadTestDefault(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*RunLoadTestResponse, error) {
	out := new(RunLoadTestResponse)
	err := c.cc.Invoke(ctx, "/pps_v2.API/RunLoadTestDefault", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RenderTemplate(ctx context.Context, in *RenderTemplateRequest, opts ...grpc.CallOption) (*RenderTemplateResponse, error) {
	out := new(RenderTemplateResponse)
	err := c.cc.Invoke(ctx, "/pps_v2.API/RenderTemplate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListTask(ctx context.Context, in *task.ListTaskRequest, opts ...grpc.CallOption) (API_ListTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[7], "/pps_v2.API/ListTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListTaskClient interface {
	Recv() (*task.TaskInfo, error)
	grpc.ClientStream
}

type aPIListTaskClient struct {
	grpc.ClientStream
}

func (x *aPIListTaskClient) Recv() (*task.TaskInfo, error) {
	m := new(task.TaskInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// APIServer is the server API for API service.
type APIServer interface {
	InspectJob(context.Context, *InspectJobRequest) (*JobInfo, error)
	InspectJobSet(*InspectJobSetRequest, API_InspectJobSetServer) error
	// ListJob returns information about current and past Pachyderm jobs.
	ListJob(*ListJobRequest, API_ListJobServer) error
	ListJobSet(*ListJobSetRequest, API_ListJobSetServer) error
	SubscribeJob(*SubscribeJobRequest, API_SubscribeJobServer) error
	DeleteJob(context.Context, *DeleteJobRequest) (*types.Empty, error)
	StopJob(context.Context, *StopJobRequest) (*types.Empty, error)
	InspectDatum(context.Context, *InspectDatumRequest) (*DatumInfo, error)
	// ListDatum returns information about each datum fed to a Pachyderm job
	ListDatum(*ListDatumRequest, API_ListDatumServer) error
	RestartDatum(context.Context, *RestartDatumRequest) (*types.Empty, error)
	CreatePipeline(context.Context, *CreatePipelineRequest) (*types.Empty, error)
	InspectPipeline(context.Context, *InspectPipelineRequest) (*PipelineInfo, error)
	ListPipeline(*ListPipelineRequest, API_ListPipelineServer) error
	DeletePipeline(context.Context, *DeletePipelineRequest) (*types.Empty, error)
	StartPipeline(context.Context, *StartPipelineRequest) (*types.Empty, error)
	StopPipeline(context.Context, *StopPipelineRequest) (*types.Empty, error)
	RunPipeline(context.Context, *RunPipelineRequest) (*types.Empty, error)
	RunCron(context.Context, *RunCronRequest) (*types.Empty, error)
	CreateSecret(context.Context, *CreateSecretRequest) (*types.Empty, error)
	DeleteSecret(context.Context, *DeleteSecretRequest) (*types.Empty, error)
	ListSecret(context.Context, *types.Empty) (*SecretInfos, error)
	InspectSecret(context.Context, *InspectSecretRequest) (*SecretInfo, error)
	// DeleteAll deletes everything
	DeleteAll(context.Context, *types.Empty) (*types.Empty, error)
	GetLogs(*GetLogsRequest, API_GetLogsServer) error
	// An internal call that causes PPS to put itself into an auth-enabled state
	// (all pipeline have tokens, correct permissions, etcd)
	ActivateAuth(context.Context, *ActivateAuthRequest) (*ActivateAuthResponse, error)
	// An internal call used to move a job from one state to another
	UpdateJobState(context.Context, *UpdateJobStateRequest) (*types.Empty, error)
	// RunLoadTest runs a load test.
	RunLoadTest(context.Context, *RunLoadTestRequest) (*RunLoadTestResponse, error)
	// RunLoadTestDefault runs the default load test.
	RunLoadTestDefault(context.Context, *types.Empty) (*RunLoadTestResponse, error)
	// RenderTemplate renders the provided template and arguments into a list of Pipeline specicifications
	RenderTemplate(context.Context, *RenderTemplateRequest) (*RenderTemplateResponse, error)
	// ListTask lists PPS tasks
	ListTask(*task.ListTaskRequest, API_ListTaskServer) error
}

// UnimplementedAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAPIServer struct {
}

func (*UnimplementedAPIServer) InspectJob(ctx context.Context, req *InspectJobRequest) (*JobInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectJob not implemented")
}
func (*UnimplementedAPIServer) InspectJobSet(req *InspectJobSetRequest, srv API_InspectJobSetServer) error {
	return status.Errorf(codes.Unimplemented, "method InspectJobSet not implemented")
}
func (*UnimplementedAPIServer) ListJob(req *ListJobRequest, srv API_ListJobServer) error {
	return status.Errorf(codes.Unimplemented, "method ListJob not implemented")
}
func (*UnimplementedAPIServer) ListJobSet(req *ListJobSetRequest, srv API_ListJobSetServer) error {
	return status.Errorf(codes.Unimplemented, "method ListJobSet not implemented")
}
func (*UnimplementedAPIServer) SubscribeJob(req *SubscribeJobRequest, srv API_SubscribeJobServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeJob not implemented")
}
func (*UnimplementedAPIServer) DeleteJob(ctx context.Context, req *DeleteJobRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteJob not implemented")
}
func (*UnimplementedAPIServer) StopJob(ctx context.Context, req *StopJobRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopJob not implemented")
}
func (*UnimplementedAPIServer) InspectDatum(ctx context.Context, req *InspectDatumRequest) (*DatumInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectDatum not implemented")
}
func (*UnimplementedAPIServer) ListDatum(req *ListDatumRequest, srv API_ListDatumServer) error {
	return status.Errorf(codes.Unimplemented, "method ListDatum not implemented")
}
func (*UnimplementedAPIServer) RestartDatum(ctx context.Context, req *RestartDatumRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RestartDatum not implemented")
}
func (*UnimplementedAPIServer) CreatePipeline(ctx context.Context, req *CreatePipelineRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePipeline not implemented")
}
func (*UnimplementedAPIServer) InspectPipeline(ctx context.Context, req *InspectPipelineRequest) (*PipelineInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectPipeline not implemented")
}
func (*UnimplementedAPIServer) ListPipeline(req *ListPipelineRequest, srv API_ListPipelineServer) error {
	return status.Errorf(codes.Unimplemented, "method ListPipeline not implemented")
}
func (*UnimplementedAPIServer) DeletePipeline(ctx context.Context, req *DeletePipelineRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePipeline not implemented")
}
func (*UnimplementedAPIServer) StartPipeline(ctx context.Context, req *StartPipelineRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartPipeline not implemented")
}
func (*UnimplementedAPIServer) StopPipeline(ctx context.Context, req *StopPipelineRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopPipeline not implemented")
}
func (*UnimplementedAPIServer) RunPipeline(ctx context.Context, req *RunPipelineRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunPipeline not implemented")
}
func (*UnimplementedAPIServer) RunCron(ctx context.Context, req *RunCronRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunCron not implemented")
}
func (*UnimplementedAPIServer) CreateSecret(ctx context.Context, req *CreateSecretRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSecret not implemented")
}
func (*UnimplementedAPIServer) DeleteSecret(ctx context.Context, req *DeleteSecretRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSecret not implemented")
}
func (*UnimplementedAPIServer) ListSecret(ctx context.Context, req *types.Empty) (*SecretInfos, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSecret not implemented")
}
func (*UnimplementedAPIServer) InspectSecret(ctx context.Context, req *InspectSecretRequest) (*SecretInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectSecret not implemented")
}
func (*UnimplementedAPIServer) DeleteAll(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAll not implemented")
}
func (*UnimplementedAPIServer) GetLogs(req *GetLogsRequest, srv API_GetLogsServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLogs not implemented")
}
func (*UnimplementedAPIServer) ActivateAuth(ctx context.Context, req *ActivateAuthRequest) (*ActivateAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateAuth not implemented")
}
func (*UnimplementedAPIServer) UpdateJobState(ctx context.Context, req *UpdateJobStateRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateJobState not implemented")
}
func (*UnimplementedAPIServer) RunLoadTest(ctx context.Context, req *RunLoadTestRequest) (*RunLoadTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLoadTest not implemented")
}
func (*UnimplementedAPIServer) RunLoadTestDefault(ctx context.Context, req *types.Empty) (*RunLoadTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLoadTestDefault not implemented")
}
func (*UnimplementedAPIServer) RenderTemplate(ctx context.Context, req *RenderTemplateRequest) (*RenderTemplateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenderTemplate not implemented")
}
func (*UnimplementedAPIServer) ListTask(req *task.ListTaskRequest, srv API_ListTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTask not implemented")
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_InspectJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/InspectJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectJob(ctx, req.(*InspectJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectJobSet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InspectJobSetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).InspectJobSet(m, &aPIInspectJobSetServer{stream})
}

type API_InspectJobSetServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPIInspectJobSetServer struct {
	grpc.ServerStream
}

func (x *aPIInspectJobSetServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ListJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListJob(m, &aPIListJobServer{stream})
}

type API_ListJobServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPIListJobServer struct {
	grpc.ServerStream
}

func (x *aPIListJobServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ListJobSet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListJobSetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListJobSet(m, &aPIListJobSetServer{stream})
}

type API_ListJobSetServer interface {
	Send(*JobSetInfo) error
	grpc.ServerStream
}

type aPIListJobSetServer struct {
	grpc.ServerStream
}

func (x *aPIListJobSetServer) Send(m *JobSetInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SubscribeJob_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeJobRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).SubscribeJob(m, &aPISubscribeJobServer{stream})
}

type API_SubscribeJobServer interface {
	Send(*JobInfo) error
	grpc.ServerStream
}

type aPISubscribeJobServer struct {
	grpc.ServerStream
}

func (x *aPISubscribeJobServer) Send(m *JobInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/DeleteJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteJob(ctx, req.(*DeleteJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopJobRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/StopJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopJob(ctx, req.(*StopJobRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/InspectDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectDatum(ctx, req.(*InspectDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListDatum_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListDatumRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListDatum(m, &aPIListDatumServer{stream})
}

type API_ListDatumServer interface {
	Send(*DatumInfo) error
	grpc.ServerStream
}

type aPIListDatumServer struct {
	grpc.ServerStream
}

func (x *aPIListDatumServer) Send(m *DatumInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_RestartDatum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RestartDatumRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RestartDatum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/RestartDatum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RestartDatum(ctx, req.(*RestartDatumRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreatePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreatePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/CreatePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreatePipeline(ctx, req.(*CreatePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/InspectPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectPipeline(ctx, req.(*InspectPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListPipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListPipelineRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListPipeline(m, &aPIListPipelineServer{stream})
}

type API_ListPipelineServer interface {
	Send(*PipelineInfo) error
	grpc.ServerStream
}

type aPIListPipelineServer struct {
	grpc.ServerStream
}

func (x *aPIListPipelineServer) Send(m *PipelineInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeletePipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeletePipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/DeletePipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeletePipeline(ctx, req.(*DeletePipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/StartPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartPipeline(ctx, req.(*StartPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StopPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StopPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/StopPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StopPipeline(ctx, req.(*StopPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunPipeline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunPipelineRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunPipeline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/RunPipeline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunPipeline(ctx, req.(*RunPipelineRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunCron_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunCronRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunCron(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/RunCron",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunCron(ctx, req.(*RunCronRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/CreateSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateSecret(ctx, req.(*CreateSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/DeleteSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteSecret(ctx, req.(*DeleteSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/ListSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListSecret(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectSecret_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectSecretRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectSecret(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/InspectSecret",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectSecret(ctx, req.(*InspectSecretRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetLogsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetLogs(m, &aPIGetLogsServer{stream})
}

type API_GetLogsServer interface {
	Send(*LogMessage) error
	grpc.ServerStream
}

type aPIGetLogsServer struct {
	grpc.ServerStream
}

func (x *aPIGetLogsServer) Send(m *LogMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ActivateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ActivateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/ActivateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ActivateAuth(ctx, req.(*ActivateAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_UpdateJobState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateJobStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).UpdateJobState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/UpdateJobState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).UpdateJobState(ctx, req.(*UpdateJobStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunLoadTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunLoadTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunLoadTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/RunLoadTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunLoadTest(ctx, req.(*RunLoadTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunLoadTestDefault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunLoadTestDefault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/RunLoadTestDefault",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunLoadTestDefault(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RenderTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenderTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RenderTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pps_v2.API/RenderTemplate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RenderTemplate(ctx, req.(*RenderTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(task.ListTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListTask(m, &aPIListTaskServer{stream})
}

type API_ListTaskServer interface {
	Send(*task.TaskInfo) error
	grpc.ServerStream
}

type aPIListTaskServer struct {
	grpc.ServerStream
}

func (x *aPIListTaskServer) Send(m *task.TaskInfo) error {
	return x.ServerStream.SendMsg(m)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pps_v2.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InspectJob",
			Handler:    _API_InspectJob_Handler,
		},
		{
			MethodName: "DeleteJob",
			Handler:    _API_DeleteJob_Handler,
		},
		{
			MethodName: "StopJob",
			Handler:    _API_StopJob_Handler,
		},
		{
			MethodName: "InspectDatum",
			Handler:    _API_InspectDatum_Handler,
		},
		{
			MethodName: "RestartDatum",
			Handler:    _API_RestartDatum_Handler,
		},
		{
			MethodName: "CreatePipeline",
			Handler:    _API_CreatePipeline_Handler,
		},
		{
			MethodName: "InspectPipeline",
			Handler:    _API_InspectPipeline_Handler,
		},
		{
			MethodName: "DeletePipeline",
			Handler:    _API_DeletePipeline_Handler,
		},
		{
			MethodName: "StartPipeline",
			Handler:    _API_StartPipeline_Handler,
		},
		{
			MethodName: "StopPipeline",
			Handler:    _API_StopPipeline_Handler,
		},
		{
			MethodName: "RunPipeline",
			Handler:    _API_RunPipeline_Handler,
		},
		{
			MethodName: "RunCron",
			Handler:    _API_RunCron_Handler,
		},
		{
			MethodName: "CreateSecret",
			Handler:    _API_CreateSecret_Handler,
		},
		{
			MethodName: "DeleteSecret",
			Handler:    _API_DeleteSecret_Handler,
		},
		{
			MethodName: "ListSecret",
			Handler:    _API_ListSecret_Handler,
		},
		{
			MethodName: "InspectSecret",
			Handler:    _API_InspectSecret_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
		{
			MethodName: "ActivateAuth",
			Handler:    _API_ActivateAuth_Handler,
		},
		{
			MethodName: "UpdateJobState",
			Handler:    _API_UpdateJobState_Handler,
		},
		{
			MethodName: "RunLoadTest",
			Handler:    _API_RunLoadTest_Handler,
		},
		{
			MethodName: "RunLoadTestDefault",
			Handler:    _API_RunLoadTestDefault_Handler,
		},
		{
			MethodName: "RenderTemplate",
			Handler:    _API_RenderTemplate_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InspectJobSet",
			Handler:       _API_InspectJobSet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListJob",
			Handler:       _API_ListJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListJobSet",
			Handler:       _API_ListJobSet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeJob",
			Handler:       _API_SubscribeJob_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListDatum",
			Handler:       _API_ListDatum_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListPipeline",
			Handler:       _API_ListPipeline_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetLogs",
			Handler:       _API_GetLogs_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListTask",
			Handler:       _API_ListTask_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pps/pps.proto",
}

func (m *SecretMount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretMount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretMount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EnvVar) > 0 {
		i -= len(m.EnvVar)
		copy(dAtA[i:], m.EnvVar)
		i = encodeVarintPps(dAtA, i, uint64(len(m.EnvVar)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MountPath) > 0 {
		i -= len(m.MountPath)
		copy(dAtA[i:], m.MountPath)
		i = encodeVarintPps(dAtA, i, uint64(len(m.MountPath)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Transform) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transform) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transform) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Dockerfile) > 0 {
		i -= len(m.Dockerfile)
		copy(dAtA[i:], m.Dockerfile)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Dockerfile)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.WorkingDir) > 0 {
		i -= len(m.WorkingDir)
		copy(dAtA[i:], m.WorkingDir)
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkingDir)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.User) > 0 {
		i -= len(m.User)
		copy(dAtA[i:], m.User)
		i = encodeVarintPps(dAtA, i, uint64(len(m.User)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Debug {
		i--
		if m.Debug {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.AcceptReturnCode) > 0 {
		dAtA2 := make([]byte, len(m.AcceptReturnCode)*10)
		var j1 int
		for _, num1 := range m.AcceptReturnCode {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintPps(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ErrStdin) > 0 {
		for iNdEx := len(m.ErrStdin) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErrStdin[iNdEx])
			copy(dAtA[i:], m.ErrStdin[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.ErrStdin[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Stdin) > 0 {
		for iNdEx := len(m.Stdin) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Stdin[iNdEx])
			copy(dAtA[i:], m.Stdin[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.Stdin[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ImagePullSecrets) > 0 {
		for iNdEx := len(m.ImagePullSecrets) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ImagePullSecrets[iNdEx])
			copy(dAtA[i:], m.ImagePullSecrets[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.ImagePullSecrets[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Secrets) > 0 {
		for iNdEx := len(m.Secrets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Secrets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Env) > 0 {
		for k := range m.Env {
			v := m.Env[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPps(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ErrCmd) > 0 {
		for iNdEx := len(m.ErrCmd) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErrCmd[iNdEx])
			copy(dAtA[i:], m.ErrCmd[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.ErrCmd[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Cmd) > 0 {
		for iNdEx := len(m.Cmd) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Cmd[iNdEx])
			copy(dAtA[i:], m.Cmd[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.Cmd[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Image) > 0 {
		i -= len(m.Image)
		copy(dAtA[i:], m.Image)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Image)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TFJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TFJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TFJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TFJob) > 0 {
		i -= len(m.TFJob)
		copy(dAtA[i:], m.TFJob)
		i = encodeVarintPps(dAtA, i, uint64(len(m.TFJob)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Egress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Egress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Egress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintPps(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Egress_ObjectStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Egress_ObjectStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectStorage != nil {
		{
			size, err := m.ObjectStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Egress_SqlDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Egress_SqlDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SqlDatabase != nil {
		{
			size, err := m.SqlDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Labels) > 0 {
		for k := range m.Labels {
			v := m.Labels[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPps(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Annotations) > 0 {
		for k := range m.Annotations {
			v := m.Annotations[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPps(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Service) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Service) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Service) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.IP) > 0 {
		i -= len(m.IP)
		copy(dAtA[i:], m.IP)
		i = encodeVarintPps(dAtA, i, uint64(len(m.IP)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ExternalPort != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.ExternalPort))
		i--
		dAtA[i] = 0x10
	}
	if m.InternalPort != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.InternalPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Spout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Spout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Spout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PFSInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PFSInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PFSInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RepoType) > 0 {
		i -= len(m.RepoType)
		copy(dAtA[i:], m.RepoType)
		i = encodeVarintPps(dAtA, i, uint64(len(m.RepoType)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.S3 {
		i--
		if m.S3 {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.EmptyFiles {
		i--
		if m.EmptyFiles {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.Lazy {
		i--
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.GroupBy) > 0 {
		i -= len(m.GroupBy)
		copy(dAtA[i:], m.GroupBy)
		i = encodeVarintPps(dAtA, i, uint64(len(m.GroupBy)))
		i--
		dAtA[i] = 0x42
	}
	if m.OuterJoin {
		i--
		if m.OuterJoin {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.JoinOn) > 0 {
		i -= len(m.JoinOn)
		copy(dAtA[i:], m.JoinOn)
		i = encodeVarintPps(dAtA, i, uint64(len(m.JoinOn)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Glob) > 0 {
		i -= len(m.Glob)
		copy(dAtA[i:], m.Glob)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Repo) > 0 {
		i -= len(m.Repo)
		copy(dAtA[i:], m.Repo)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CronInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CronInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CronInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Overwrite {
		i--
		if m.Overwrite {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Commit) > 0 {
		i -= len(m.Commit)
		copy(dAtA[i:], m.Commit)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Commit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Repo) > 0 {
		i -= len(m.Repo)
		copy(dAtA[i:], m.Repo)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Repo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Input) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Input) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Input) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Cron != nil {
		{
			size, err := m.Cron.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Union) > 0 {
		for iNdEx := len(m.Union) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Union[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Cross) > 0 {
		for iNdEx := len(m.Cross) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Cross[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Group) > 0 {
		for iNdEx := len(m.Group) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Group[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Join) > 0 {
		for iNdEx := len(m.Join) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Join[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pfs != nil {
		{
			size, err := m.Pfs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Lazy {
		i--
		if m.Lazy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Glob) > 0 {
		i -= len(m.Glob)
		copy(dAtA[i:], m.Glob)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Glob)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ParallelismSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParallelismSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParallelismSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Constant != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Constant))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InputFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InputFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InputFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Datum) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Datum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Datum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatumInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatumInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintPps(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.PfsState != nil {
		{
			size, err := m.PfsState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Datum != nil {
		{
			size, err := m.Datum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Aggregate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Aggregate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Aggregate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NinetyFifthPercentile != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.NinetyFifthPercentile))))
		i--
		dAtA[i] = 0x29
	}
	if m.FifthPercentile != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.FifthPercentile))))
		i--
		dAtA[i] = 0x21
	}
	if m.Stddev != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Stddev))))
		i--
		dAtA[i] = 0x19
	}
	if m.Mean != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Mean))))
		i--
		dAtA[i] = 0x11
	}
	if m.Count != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProcessStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProcessStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UploadBytes != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.UploadBytes))
		i--
		dAtA[i] = 0x28
	}
	if m.DownloadBytes != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DownloadBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.UploadTime != nil {
		{
			size, err := m.UploadTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ProcessTime != nil {
		{
			size, err := m.ProcessTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DownloadTime != nil {
		{
			size, err := m.DownloadTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AggregateProcessStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AggregateProcessStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AggregateProcessStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UploadBytes != nil {
		{
			size, err := m.UploadBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.DownloadBytes != nil {
		{
			size, err := m.DownloadBytes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UploadTime != nil {
		{
			size, err := m.UploadTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ProcessTime != nil {
		{
			size, err := m.ProcessTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.DownloadTime != nil {
		{
			size, err := m.DownloadTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WorkerStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WorkerStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WorkerStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DatumStatus != nil {
		{
			size, err := m.DatumStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobID) > 0 {
		i -= len(m.JobID)
		copy(dAtA[i:], m.JobID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkerID) > 0 {
		i -= len(m.WorkerID)
		copy(dAtA[i:], m.WorkerID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatumStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatumStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Disk) > 0 {
		i -= len(m.Disk)
		copy(dAtA[i:], m.Disk)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Disk)))
		i--
		dAtA[i] = 0x22
	}
	if m.Gpu != nil {
		{
			size, err := m.Gpu.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Memory) > 0 {
		i -= len(m.Memory)
		copy(dAtA[i:], m.Memory)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Memory)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cpu != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cpu))))
		i--
		dAtA[i] = 0xd
	}
	return len(dAtA) - i, nil
}

func (m *GPUSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GPUSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GPUSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Number != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobSetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Jobs) > 0 {
		for iNdEx := len(m.Jobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.JobSet != nil {
		{
			size, err := m.JobSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x62
	}
	if m.State != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x58
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.DataRecovered != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataRecovered))
		i--
		dAtA[i] = 0x48
	}
	if m.DataFailed != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataFailed))
		i--
		dAtA[i] = 0x40
	}
	if m.DataTotal != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
		i--
		dAtA[i] = 0x38
	}
	if m.DataSkipped != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
		i--
		dAtA[i] = 0x30
	}
	if m.DataProcessed != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
		i--
		dAtA[i] = 0x28
	}
	if m.Restart != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
		i--
		dAtA[i] = 0x20
	}
	if m.OutputCommit != nil {
		{
			size, err := m.OutputCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.PipelineVersion != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.PipelineVersion))
		i--
		dAtA[i] = 0x10
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobInfo_Details) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobInfo_Details) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobInfo_Details) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PodPatch) > 0 {
		i -= len(m.PodPatch)
		copy(dAtA[i:], m.PodPatch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.PodSpec) > 0 {
		i -= len(m.PodSpec)
		copy(dAtA[i:], m.PodSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodSpec)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.SchedulingSpec != nil {
		{
			size, err := m.SchedulingSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.DatumTries != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTries))
		i--
		dAtA[i] = 0x78
	}
	if m.JobTimeout != nil {
		{
			size, err := m.JobTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.DatumTimeout != nil {
		{
			size, err := m.DatumTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.DatumSetSpec != nil {
		{
			size, err := m.DatumSetSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.SidecarResourceLimits != nil {
		{
			size, err := m.SidecarResourceLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.ResourceLimits != nil {
		{
			size, err := m.ResourceLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.ResourceRequests != nil {
		{
			size, err := m.ResourceRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.WorkerStatus) > 0 {
		for iNdEx := len(m.WorkerStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WorkerStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Spout != nil {
		{
			size, err := m.Spout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Egress != nil {
		{
			size, err := m.Egress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ParallelismSpec != nil {
		{
			size, err := m.ParallelismSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Transform != nil {
		{
			size, err := m.Transform.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Worker) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Worker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Worker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Pipeline) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pipeline) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pipeline) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PipelineInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if len(m.AuthToken) > 0 {
		i -= len(m.AuthToken)
		copy(dAtA[i:], m.AuthToken)
		i = encodeVarintPps(dAtA, i, uint64(len(m.AuthToken)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Type != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x50
	}
	if m.Parallelism != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Parallelism))
		i--
		dAtA[i] = 0x48
	}
	if m.LastJobState != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.LastJobState))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x32
	}
	if m.State != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if m.Stopped {
		i--
		if m.Stopped {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.SpecCommit != nil {
		{
			size, err := m.SpecCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Version != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PipelineInfo_Details) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfo_Details) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineInfo_Details) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Autoscaling {
		i--
		if m.Autoscaling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if len(m.WorkerRc) > 0 {
		i -= len(m.WorkerRc)
		copy(dAtA[i:], m.WorkerRc)
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerRc)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if m.UnclaimedTasks != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.UnclaimedTasks))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if len(m.ReprocessSpec) > 0 {
		i -= len(m.ReprocessSpec)
		copy(dAtA[i:], m.ReprocessSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.ReprocessSpec)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.S3Out {
		i--
		if m.S3Out {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if len(m.PodPatch) > 0 {
		i -= len(m.PodPatch)
		copy(dAtA[i:], m.PodPatch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.PodSpec) > 0 {
		i -= len(m.PodSpec)
		copy(dAtA[i:], m.PodSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodSpec)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if m.SchedulingSpec != nil {
		{
			size, err := m.SchedulingSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.DatumTries != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTries))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.JobTimeout != nil {
		{
			size, err := m.JobTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.DatumTimeout != nil {
		{
			size, err := m.DatumTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.DatumSetSpec != nil {
		{
			size, err := m.DatumSetSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.Spout != nil {
		{
			size, err := m.Spout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x72
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.SidecarResourceLimits != nil {
		{
			size, err := m.SidecarResourceLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.ResourceLimits != nil {
		{
			size, err := m.ResourceLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ResourceRequests != nil {
		{
			size, err := m.ResourceRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.OutputBranch) > 0 {
		i -= len(m.OutputBranch)
		copy(dAtA[i:], m.OutputBranch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i--
		dAtA[i] = 0x4a
	}
	if m.WorkersAvailable != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.WorkersAvailable))
		i--
		dAtA[i] = 0x40
	}
	if m.WorkersRequested != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.WorkersRequested))
		i--
		dAtA[i] = 0x38
	}
	if len(m.RecentError) > 0 {
		i -= len(m.RecentError)
		copy(dAtA[i:], m.RecentError)
		i = encodeVarintPps(dAtA, i, uint64(len(m.RecentError)))
		i--
		dAtA[i] = 0x32
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Egress != nil {
		{
			size, err := m.Egress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ParallelismSpec != nil {
		{
			size, err := m.ParallelismSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TFJob != nil {
		{
			size, err := m.TFJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Transform != nil {
		{
			size, err := m.Transform.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PipelineInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PipelineInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PipelineInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PipelineInfo) > 0 {
		for iNdEx := len(m.PipelineInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PipelineInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JobSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectJobSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectJobSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectJobSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.JobSet != nil {
		{
			size, err := m.JobSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListJobSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListJobSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InspectJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JqFilter) > 0 {
		i -= len(m.JqFilter)
		copy(dAtA[i:], m.JqFilter)
		i = encodeVarintPps(dAtA, i, uint64(len(m.JqFilter)))
		i--
		dAtA[i] = 0x32
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.History != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.History))
		i--
		dAtA[i] = 0x20
	}
	if len(m.InputCommit) > 0 {
		for iNdEx := len(m.InputCommit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InputCommit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StopJobRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopJobRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StopJobRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateJobStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateJobStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateJobStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.DataTotal != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataTotal))
		i--
		dAtA[i] = 0x50
	}
	if m.DataRecovered != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataRecovered))
		i--
		dAtA[i] = 0x48
	}
	if m.DataFailed != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataFailed))
		i--
		dAtA[i] = 0x40
	}
	if m.DataSkipped != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataSkipped))
		i--
		dAtA[i] = 0x38
	}
	if m.DataProcessed != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DataProcessed))
		i--
		dAtA[i] = 0x30
	}
	if m.Restart != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Restart))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetLogsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetLogsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetLogsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Since != nil {
		{
			size, err := m.Since.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.UseLokiBackend {
		i--
		if m.UseLokiBackend {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.Tail != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Tail))
		i--
		dAtA[i] = 0x38
	}
	if m.Follow {
		i--
		if m.Follow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Master {
		i--
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Datum != nil {
		{
			size, err := m.Datum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.DataFilters) > 0 {
		for iNdEx := len(m.DataFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DataFilters[iNdEx])
			copy(dAtA[i:], m.DataFilters[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.DataFilters[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Ts != nil {
		{
			size, err := m.Ts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.User {
		i--
		if m.User {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.Master {
		i--
		if m.Master {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.DatumID) > 0 {
		i -= len(m.DatumID)
		copy(dAtA[i:], m.DatumID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.DatumID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WorkerID) > 0 {
		i -= len(m.WorkerID)
		copy(dAtA[i:], m.WorkerID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.WorkerID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobID) > 0 {
		i -= len(m.JobID)
		copy(dAtA[i:], m.JobID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PipelineName) > 0 {
		i -= len(m.PipelineName)
		copy(dAtA[i:], m.PipelineName)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PipelineName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RestartDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RestartDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RestartDatumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DataFilters) > 0 {
		for iNdEx := len(m.DataFilters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DataFilters[iNdEx])
			copy(dAtA[i:], m.DataFilters[iNdEx])
			i = encodeVarintPps(dAtA, i, uint64(len(m.DataFilters[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectDatumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Datum != nil {
		{
			size, err := m.Datum.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListDatumRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListDatumRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListDatumRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Job != nil {
		{
			size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DatumSetSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DatumSetSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DatumSetSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PerWorker != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.PerWorker))
		i--
		dAtA[i] = 0x18
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x10
	}
	if m.Number != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SchedulingSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulingSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulingSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PriorityClassName) > 0 {
		i -= len(m.PriorityClassName)
		copy(dAtA[i:], m.PriorityClassName)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PriorityClassName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeSelector) > 0 {
		for k := range m.NodeSelector {
			v := m.NodeSelector[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPps(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreatePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreatePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreatePipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Autoscaling {
		i--
		if m.Autoscaling {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.ReprocessSpec) > 0 {
		i -= len(m.ReprocessSpec)
		copy(dAtA[i:], m.ReprocessSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.ReprocessSpec)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if m.SpecCommit != nil {
		{
			size, err := m.SpecCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.PodPatch) > 0 {
		i -= len(m.PodPatch)
		copy(dAtA[i:], m.PodPatch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.PodSpec) > 0 {
		i -= len(m.PodSpec)
		copy(dAtA[i:], m.PodSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodSpec)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SchedulingSpec != nil {
		{
			size, err := m.SchedulingSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.DatumTries != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.DatumTries))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.JobTimeout != nil {
		{
			size, err := m.JobTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.DatumTimeout != nil {
		{
			size, err := m.DatumTimeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if m.DatumSetSpec != nil {
		{
			size, err := m.DatumSetSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if m.Spout != nil {
		{
			size, err := m.Spout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.Service != nil {
		{
			size, err := m.Service.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.Reprocess {
		i--
		if m.Reprocess {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Input != nil {
		{
			size, err := m.Input.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SidecarResourceLimits != nil {
		{
			size, err := m.SidecarResourceLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if m.ResourceLimits != nil {
		{
			size, err := m.ResourceLimits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.ResourceRequests != nil {
		{
			size, err := m.ResourceRequests.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.S3Out {
		i--
		if m.S3Out {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.OutputBranch) > 0 {
		i -= len(m.OutputBranch)
		copy(dAtA[i:], m.OutputBranch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.OutputBranch)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Update {
		i--
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Egress != nil {
		{
			size, err := m.Egress.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ParallelismSpec != nil {
		{
			size, err := m.ParallelismSpec.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Transform != nil {
		{
			size, err := m.Transform.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TFJob != nil {
		{
			size, err := m.TFJob.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectPipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListPipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JqFilter) > 0 {
		i -= len(m.JqFilter)
		copy(dAtA[i:], m.JqFilter)
		i = encodeVarintPps(dAtA, i, uint64(len(m.JqFilter)))
		i--
		dAtA[i] = 0x22
	}
	if m.Details {
		i--
		if m.Details {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.History != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.History))
		i--
		dAtA[i] = 0x10
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeletePipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeletePipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeletePipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KeepRepo {
		i--
		if m.KeepRepo {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StartPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartPipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StopPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StopPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StopPipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunPipelineRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunPipelineRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunPipelineRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.JobID) > 0 {
		i -= len(m.JobID)
		copy(dAtA[i:], m.JobID)
		i = encodeVarintPps(dAtA, i, uint64(len(m.JobID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunCronRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunCronRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunCronRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Pipeline != nil {
		{
			size, err := m.Pipeline.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateSecretRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateSecretRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateSecretRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.File) > 0 {
		i -= len(m.File)
		copy(dAtA[i:], m.File)
		i = encodeVarintPps(dAtA, i, uint64(len(m.File)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteSecretRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteSecretRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteSecretRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Secret != nil {
		{
			size, err := m.Secret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectSecretRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectSecretRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectSecretRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Secret != nil {
		{
			size, err := m.Secret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Secret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Secret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Secret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecretInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreationTimestamp != nil {
		{
			size, err := m.CreationTimestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Secret != nil {
		{
			size, err := m.Secret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPps(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SecretInfos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SecretInfos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SecretInfos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SecretInfo) > 0 {
		for iNdEx := len(m.SecretInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SecretInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActivateAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateAuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ActivateAuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateAuthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RunLoadTestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunLoadTestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunLoadTestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PodPatch) > 0 {
		i -= len(m.PodPatch)
		copy(dAtA[i:], m.PodPatch)
		i = encodeVarintPps(dAtA, i, uint64(len(m.PodPatch)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Parallelism != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Parallelism))
		i--
		dAtA[i] = 0x20
	}
	if m.Seed != 0 {
		i = encodeVarintPps(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x18
	}
	if len(m.LoadSpec) > 0 {
		i -= len(m.LoadSpec)
		copy(dAtA[i:], m.LoadSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.LoadSpec)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DagSpec) > 0 {
		i -= len(m.DagSpec)
		copy(dAtA[i:], m.DagSpec)
		i = encodeVarintPps(dAtA, i, uint64(len(m.DagSpec)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunLoadTestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunLoadTestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunLoadTestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenderTemplateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderTemplateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenderTemplateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Args) > 0 {
		for k := range m.Args {
			v := m.Args[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintPps(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPps(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPps(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Template) > 0 {
		i -= len(m.Template)
		copy(dAtA[i:], m.Template)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Template)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenderTemplateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenderTemplateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenderTemplateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Specs) > 0 {
		for iNdEx := len(m.Specs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Specs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPps(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Json) > 0 {
		i -= len(m.Json)
		copy(dAtA[i:], m.Json)
		i = encodeVarintPps(dAtA, i, uint64(len(m.Json)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPps(dAtA []byte, offset int, v uint64) int {
	offset -= sovPps(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SecretMount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.MountPath)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.EnvVar)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Transform) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Image)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Cmd) > 0 {
		for _, s := range m.Cmd {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.ErrCmd) > 0 {
		for _, s := range m.ErrCmd {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Env) > 0 {
		for k, v := range m.Env {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if len(m.Secrets) > 0 {
		for _, e := range m.Secrets {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.ImagePullSecrets) > 0 {
		for _, s := range m.ImagePullSecrets {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Stdin) > 0 {
		for _, s := range m.Stdin {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.ErrStdin) > 0 {
		for _, s := range m.ErrStdin {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.AcceptReturnCode) > 0 {
		l = 0
		for _, e := range m.AcceptReturnCode {
			l += sovPps(uint64(e))
		}
		n += 1 + sovPps(uint64(l)) + l
	}
	if m.Debug {
		n += 2
	}
	l = len(m.User)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.WorkingDir)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Dockerfile)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TFJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TFJob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Egress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Egress_ObjectStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectStorage != nil {
		l = m.ObjectStorage.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}
func (m *Egress_SqlDatabase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlDatabase != nil {
		l = m.SqlDatabase.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	return n
}
func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Service) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.InternalPort != 0 {
		n += 1 + sovPps(uint64(m.InternalPort))
	}
	if m.ExternalPort != 0 {
		n += 1 + sovPps(uint64(m.ExternalPort))
	}
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Spout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PFSInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JoinOn)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.OuterJoin {
		n += 2
	}
	l = len(m.GroupBy)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	if m.EmptyFiles {
		n += 2
	}
	if m.S3 {
		n += 2
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.RepoType)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CronInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Repo)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Commit)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Overwrite {
		n += 2
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Input) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pfs != nil {
		l = m.Pfs.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Join) > 0 {
		for _, e := range m.Join {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Cross) > 0 {
		for _, e := range m.Cross {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if len(m.Union) > 0 {
		for _, e := range m.Union {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Cron != nil {
		l = m.Cron.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Glob)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Lazy {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ParallelismSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constant != 0 {
		n += 1 + sovPps(uint64(m.Constant))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InputFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Datum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatumInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PfsState != nil {
		l = m.PfsState.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Aggregate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovPps(uint64(m.Count))
	}
	if m.Mean != 0 {
		n += 9
	}
	if m.Stddev != 0 {
		n += 9
	}
	if m.FifthPercentile != 0 {
		n += 9
	}
	if m.NinetyFifthPercentile != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProcessStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != 0 {
		n += 1 + sovPps(uint64(m.DownloadBytes))
	}
	if m.UploadBytes != 0 {
		n += 1 + sovPps(uint64(m.UploadBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AggregateProcessStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DownloadTime != nil {
		l = m.DownloadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ProcessTime != nil {
		l = m.ProcessTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadTime != nil {
		l = m.UploadTime.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DownloadBytes != nil {
		l = m.DownloadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.UploadBytes != nil {
		l = m.UploadBytes.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WorkerStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DatumStatus != nil {
		l = m.DatumStatus.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatumStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cpu != 0 {
		n += 5
	}
	l = len(m.Memory)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Gpu != nil {
		l = m.Gpu.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Disk)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GPUSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPps(uint64(m.Number))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobSetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobSet != nil {
		l = m.JobSet.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.PipelineVersion != 0 {
		n += 1 + sovPps(uint64(m.PipelineVersion))
	}
	if m.OutputCommit != nil {
		l = m.OutputCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 1 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 1 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataSkipped != 0 {
		n += 1 + sovPps(uint64(m.DataSkipped))
	}
	if m.DataTotal != 0 {
		n += 1 + sovPps(uint64(m.DataTotal))
	}
	if m.DataFailed != 0 {
		n += 1 + sovPps(uint64(m.DataFailed))
	}
	if m.DataRecovered != 0 {
		n += 1 + sovPps(uint64(m.DataRecovered))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobInfo_Details) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Spout != nil {
		l = m.Spout.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.WorkerStatus) > 0 {
		for _, e := range m.WorkerStatus {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.SidecarResourceLimits != nil {
		l = m.SidecarResourceLimits.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DatumSetSpec != nil {
		l = m.DatumSetSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.DatumTries != 0 {
		n += 1 + sovPps(uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		l = m.SchedulingSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Worker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pipeline) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Version != 0 {
		n += 1 + sovPps(uint64(m.Version))
	}
	if m.SpecCommit != nil {
		l = m.SpecCommit.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Stopped {
		n += 2
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.LastJobState != 0 {
		n += 1 + sovPps(uint64(m.LastJobState))
	}
	if m.Parallelism != 0 {
		n += 1 + sovPps(uint64(m.Parallelism))
	}
	if m.Type != 0 {
		n += 1 + sovPps(uint64(m.Type))
	}
	l = len(m.AuthToken)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineInfo_Details) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.TFJob != nil {
		l = m.TFJob.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.RecentError)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.WorkersRequested != 0 {
		n += 1 + sovPps(uint64(m.WorkersRequested))
	}
	if m.WorkersAvailable != 0 {
		n += 1 + sovPps(uint64(m.WorkersAvailable))
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.SidecarResourceLimits != nil {
		l = m.SidecarResourceLimits.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Spout != nil {
		l = m.Spout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumSetSpec != nil {
		l = m.DatumSetSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTries != 0 {
		n += 2 + sovPps(uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		l = m.SchedulingSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.S3Out {
		n += 3
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.ReprocessSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.UnclaimedTasks != 0 {
		n += 2 + sovPps(uint64(m.UnclaimedTasks))
	}
	l = len(m.WorkerRc)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Autoscaling {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PipelineInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PipelineInfo) > 0 {
		for _, e := range m.PipelineInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *JobSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectJobSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.JobSet != nil {
		l = m.JobSet.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.Details {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListJobSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Details {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.Details {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.InputCommit) > 0 {
		for _, e := range m.InputCommit {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.History != 0 {
		n += 1 + sovPps(uint64(m.History))
	}
	if m.Details {
		n += 2
	}
	l = len(m.JqFilter)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Details {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopJobRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateJobStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPps(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Restart != 0 {
		n += 1 + sovPps(uint64(m.Restart))
	}
	if m.DataProcessed != 0 {
		n += 1 + sovPps(uint64(m.DataProcessed))
	}
	if m.DataSkipped != 0 {
		n += 1 + sovPps(uint64(m.DataSkipped))
	}
	if m.DataFailed != 0 {
		n += 1 + sovPps(uint64(m.DataFailed))
	}
	if m.DataRecovered != 0 {
		n += 1 + sovPps(uint64(m.DataRecovered))
	}
	if m.DataTotal != 0 {
		n += 1 + sovPps(uint64(m.DataTotal))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetLogsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Master {
		n += 2
	}
	if m.Follow {
		n += 2
	}
	if m.Tail != 0 {
		n += 1 + sovPps(uint64(m.Tail))
	}
	if m.UseLokiBackend {
		n += 2
	}
	if m.Since != nil {
		l = m.Since.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PipelineName)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.WorkerID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.DatumID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Master {
		n += 2
	}
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.User {
		n += 2
	}
	if m.Ts != nil {
		l = m.Ts.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RestartDatumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.DataFilters) > 0 {
		for _, s := range m.DataFilters {
			l = len(s)
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectDatumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Datum != nil {
		l = m.Datum.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListDatumRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Job != nil {
		l = m.Job.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DatumSetSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovPps(uint64(m.Number))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPps(uint64(m.SizeBytes))
	}
	if m.PerWorker != 0 {
		n += 1 + sovPps(uint64(m.PerWorker))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SchedulingSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.NodeSelector) > 0 {
		for k, v := range m.NodeSelector {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	l = len(m.PriorityClassName)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreatePipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.TFJob != nil {
		l = m.TFJob.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Transform != nil {
		l = m.Transform.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ParallelismSpec != nil {
		l = m.ParallelismSpec.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Egress != nil {
		l = m.Egress.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Update {
		n += 2
	}
	l = len(m.OutputBranch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.S3Out {
		n += 2
	}
	if m.ResourceRequests != nil {
		l = m.ResourceRequests.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.ResourceLimits != nil {
		l = m.ResourceLimits.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.SidecarResourceLimits != nil {
		l = m.SidecarResourceLimits.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Input != nil {
		l = m.Input.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Reprocess {
		n += 2
	}
	if m.Service != nil {
		l = m.Service.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Spout != nil {
		l = m.Spout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumSetSpec != nil {
		l = m.DatumSetSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTimeout != nil {
		l = m.DatumTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.JobTimeout != nil {
		l = m.JobTimeout.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.Salt)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.DatumTries != 0 {
		n += 2 + sovPps(uint64(m.DatumTries))
	}
	if m.SchedulingSpec != nil {
		l = m.SchedulingSpec.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.SpecCommit != nil {
		l = m.SpecCommit.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 2 + l + sovPps(uint64(l))
	}
	l = len(m.ReprocessSpec)
	if l > 0 {
		n += 2 + l + sovPps(uint64(l))
	}
	if m.Autoscaling {
		n += 3
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Details {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.History != 0 {
		n += 1 + sovPps(uint64(m.History))
	}
	if m.Details {
		n += 2
	}
	l = len(m.JqFilter)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeletePipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.All {
		n += 2
	}
	if m.Force {
		n += 2
	}
	if m.KeepRepo {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StopPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunPipelineRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	l = len(m.JobID)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunCronRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pipeline != nil {
		l = m.Pipeline.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateSecretRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.File)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteSecretRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectSecretRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Secret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecretInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.CreationTimestamp != nil {
		l = m.CreationTimestamp.Size()
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SecretInfos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SecretInfo) > 0 {
		for _, e := range m.SecretInfo {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunLoadTestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DagSpec)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	l = len(m.LoadSpec)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.Seed != 0 {
		n += 1 + sovPps(uint64(m.Seed))
	}
	if m.Parallelism != 0 {
		n += 1 + sovPps(uint64(m.Parallelism))
	}
	l = len(m.PodPatch)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunLoadTestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderTemplateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Template)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Args) > 0 {
		for k, v := range m.Args {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPps(uint64(len(k))) + 1 + len(v) + sovPps(uint64(len(v)))
			n += mapEntrySize + 1 + sovPps(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenderTemplateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Json)
	if l > 0 {
		n += 1 + l + sovPps(uint64(l))
	}
	if len(m.Specs) > 0 {
		for _, e := range m.Specs {
			l = e.Size()
			n += 1 + l + sovPps(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPps(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPps(x uint64) (n int) {
	return sovPps(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SecretMount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretMount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretMount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MountPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MountPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvVar", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvVar = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transform) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transform: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transform: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Image", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Image = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrCmd", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrCmd = append(m.ErrCmd, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Env", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Env == nil {
				m.Env = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Env[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secrets = append(m.Secrets, &SecretMount{})
			if err := m.Secrets[len(m.Secrets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagePullSecrets", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagePullSecrets = append(m.ImagePullSecrets, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stdin = append(m.Stdin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStdin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStdin = append(m.ErrStdin, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptReturnCode = append(m.AcceptReturnCode, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPps
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPps
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AcceptReturnCode) == 0 {
					m.AcceptReturnCode = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptReturnCode = append(m.AcceptReturnCode, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptReturnCode", wireType)
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Debug", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Debug = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.User = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDir", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDir = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dockerfile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dockerfile = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TFJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TFJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TFJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TFJob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TFJob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Egress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Egress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Egress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &pfs.ObjectStorageEgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &Egress_ObjectStorage{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &pfs.SQLDatabaseEgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &Egress_SqlDatabase{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Service) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Service: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Service: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InternalPort", wireType)
			}
			m.InternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InternalPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalPort", wireType)
			}
			m.ExternalPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExternalPort |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Spout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Spout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Spout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PFSInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PFSInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PFSInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinOn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JoinOn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OuterJoin", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OuterJoin = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EmptyFiles", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EmptyFiles = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.S3 = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &pfs.Trigger{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CronInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CronInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CronInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Overwrite", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Overwrite = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &types.Timestamp{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Input) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Input: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Input: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pfs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pfs == nil {
				m.Pfs = &PFSInput{}
			}
			if err := m.Pfs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Join = append(m.Join, &Input{})
			if err := m.Join[len(m.Join)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &Input{})
			if err := m.Group[len(m.Group)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cross", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cross = append(m.Cross, &Input{})
			if err := m.Cross[len(m.Cross)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Union", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Union = append(m.Union, &Input{})
			if err := m.Union[len(m.Union)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cron", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cron == nil {
				m.Cron = &CronInput{}
			}
			if err := m.Cron.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &pfs.Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Glob", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Glob = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lazy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Lazy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParallelismSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParallelismSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParallelismSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constant", wireType)
			}
			m.Constant = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constant |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InputFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InputFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InputFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Datum) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Datum: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Datum: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= DatumState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PfsState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PfsState == nil {
				m.PfsState = &pfs.File{}
			}
			if err := m.PfsState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &pfs.FileInfo{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Aggregate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Aggregate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Aggregate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mean", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Mean = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stddev", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Stddev = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.FifthPercentile = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field NinetyFifthPercentile", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.NinetyFifthPercentile = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &types.Duration{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &types.Duration{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &types.Duration{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			m.DownloadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			m.UploadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AggregateProcessStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AggregateProcessStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AggregateProcessStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadTime == nil {
				m.DownloadTime = &Aggregate{}
			}
			if err := m.DownloadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProcessTime == nil {
				m.ProcessTime = &Aggregate{}
			}
			if err := m.ProcessTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadTime == nil {
				m.UploadTime = &Aggregate{}
			}
			if err := m.UploadTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DownloadBytes == nil {
				m.DownloadBytes = &Aggregate{}
			}
			if err := m.DownloadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadBytes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadBytes == nil {
				m.UploadBytes = &Aggregate{}
			}
			if err := m.UploadBytes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WorkerStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WorkerStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WorkerStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumStatus == nil {
				m.DatumStatus = &DatumStatus{}
			}
			if err := m.DatumStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cpu", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cpu = float32(math.Float32frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpu", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Gpu == nil {
				m.Gpu = &GPUSpec{}
			}
			if err := m.Gpu.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disk", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Disk = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GPUSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GPUSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GPUSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobSet == nil {
				m.JobSet = &JobSet{}
			}
			if err := m.JobSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &JobInfo{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineVersion", wireType)
			}
			m.PipelineVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PipelineVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OutputCommit == nil {
				m.OutputCommit = &pfs.Commit{}
			}
			if err := m.OutputCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFailed", wireType)
			}
			m.DataFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFailed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRecovered", wireType)
			}
			m.DataRecovered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataRecovered |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &JobInfo_Details{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobInfo_Details) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spout == nil {
				m.Spout = &Spout{}
			}
			if err := m.Spout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerStatus = append(m.WorkerStatus, &WorkerStatus{})
			if err := m.WorkerStatus[len(m.WorkerStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarResourceLimits == nil {
				m.SidecarResourceLimits = &ResourceSpec{}
			}
			if err := m.SidecarResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumSetSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumSetSpec == nil {
				m.DatumSetSpec = &DatumSetSpec{}
			}
			if err := m.DatumSetSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &types.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &types.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTries", wireType)
			}
			m.DatumTries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatumTries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingSpec == nil {
				m.SchedulingSpec = &SchedulingSpec{}
			}
			if err := m.SchedulingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Worker) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Worker: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Worker: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= WorkerState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pipeline) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pipeline: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pipeline: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecCommit == nil {
				m.SpecCommit = &pfs.Commit{}
			}
			if err := m.SpecCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stopped", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stopped = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= PipelineState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastJobState", wireType)
			}
			m.LastJobState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastJobState |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelism", wireType)
			}
			m.Parallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parallelism |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= PipelineInfo_PipelineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &PipelineInfo_Details{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfo_Details) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TFJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TFJob == nil {
				m.TFJob = &TFJob{}
			}
			if err := m.TFJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecentError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecentError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkersRequested", wireType)
			}
			m.WorkersRequested = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkersRequested |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkersAvailable", wireType)
			}
			m.WorkersAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WorkersAvailable |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarResourceLimits == nil {
				m.SidecarResourceLimits = &ResourceSpec{}
			}
			if err := m.SidecarResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spout == nil {
				m.Spout = &Spout{}
			}
			if err := m.Spout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumSetSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumSetSpec == nil {
				m.DatumSetSpec = &DatumSetSpec{}
			}
			if err := m.DatumSetSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &types.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &types.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTries", wireType)
			}
			m.DatumTries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatumTries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingSpec == nil {
				m.SchedulingSpec = &SchedulingSpec{}
			}
			if err := m.SchedulingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Out", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.S3Out = bool(v != 0)
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprocessSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReprocessSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnclaimedTasks", wireType)
			}
			m.UnclaimedTasks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnclaimedTasks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerRc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerRc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoscaling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autoscaling = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PipelineInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PipelineInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PipelineInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineInfo = append(m.PipelineInfo, &PipelineInfo{})
			if err := m.PipelineInfo[len(m.PipelineInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectJobSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectJobSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectJobSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobSet == nil {
				m.JobSet = &JobSet{}
			}
			if err := m.JobSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputCommit = append(m.InputCommit, &pfs.Commit{})
			if err := m.InputCommit[len(m.InputCommit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			m.History = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.History |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JqFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JqFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopJobRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopJobRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopJobRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateJobStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateJobStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateJobStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Restart", wireType)
			}
			m.Restart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Restart |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataProcessed", wireType)
			}
			m.DataProcessed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataProcessed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataSkipped", wireType)
			}
			m.DataSkipped = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataSkipped |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFailed", wireType)
			}
			m.DataFailed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataFailed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataRecovered", wireType)
			}
			m.DataRecovered = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataRecovered |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataTotal", wireType)
			}
			m.DataTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataTotal |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ProcessStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetLogsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetLogsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetLogsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Follow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Follow = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tail", wireType)
			}
			m.Tail = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tail |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseLokiBackend", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UseLokiBackend = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Since", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Since == nil {
				m.Since = &types.Duration{}
			}
			if err := m.Since.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PipelineName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PipelineName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkerID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkerID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DatumID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Master = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &InputFile{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.User = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ts == nil {
				m.Ts = &types.Timestamp{}
			}
			if err := m.Ts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RestartDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RestartDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RestartDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataFilters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataFilters = append(m.DataFilters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Datum == nil {
				m.Datum = &Datum{}
			}
			if err := m.Datum.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListDatumRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListDatumRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListDatumRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Job == nil {
				m.Job = &Job{}
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DatumSetSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DatumSetSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DatumSetSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerWorker", wireType)
			}
			m.PerWorker = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerWorker |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulingSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulingSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulingSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeSelector", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NodeSelector == nil {
				m.NodeSelector = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NodeSelector[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriorityClassName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriorityClassName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TFJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TFJob == nil {
				m.TFJob = &TFJob{}
			}
			if err := m.TFJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transform", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Transform == nil {
				m.Transform = &Transform{}
			}
			if err := m.Transform.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParallelismSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParallelismSpec == nil {
				m.ParallelismSpec = &ParallelismSpec{}
			}
			if err := m.ParallelismSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Egress", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Egress == nil {
				m.Egress = &Egress{}
			}
			if err := m.Egress.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputBranch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputBranch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field S3Out", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.S3Out = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceRequests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceRequests == nil {
				m.ResourceRequests = &ResourceSpec{}
			}
			if err := m.ResourceRequests.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceLimits == nil {
				m.ResourceLimits = &ResourceSpec{}
			}
			if err := m.ResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SidecarResourceLimits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SidecarResourceLimits == nil {
				m.SidecarResourceLimits = &ResourceSpec{}
			}
			if err := m.SidecarResourceLimits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Input", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Input == nil {
				m.Input = &Input{}
			}
			if err := m.Input.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reprocess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reprocess = bool(v != 0)
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Service == nil {
				m.Service = &Service{}
			}
			if err := m.Service.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spout == nil {
				m.Spout = &Spout{}
			}
			if err := m.Spout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumSetSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumSetSpec == nil {
				m.DatumSetSpec = &DatumSetSpec{}
			}
			if err := m.DatumSetSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DatumTimeout == nil {
				m.DatumTimeout = &types.Duration{}
			}
			if err := m.DatumTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobTimeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JobTimeout == nil {
				m.JobTimeout = &types.Duration{}
			}
			if err := m.JobTimeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DatumTries", wireType)
			}
			m.DatumTries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DatumTries |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SchedulingSpec == nil {
				m.SchedulingSpec = &SchedulingSpec{}
			}
			if err := m.SchedulingSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpecCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpecCommit == nil {
				m.SpecCommit = &pfs.Commit{}
			}
			if err := m.SpecCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &Metadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReprocessSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReprocessSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Autoscaling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Autoscaling = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field History", wireType)
			}
			m.History = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.History |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Details = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JqFilter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JqFilter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeepRepo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.KeepRepo = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StopPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StopPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StopPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunPipelineRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunPipelineRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunPipelineRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &pfs.Commit{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunCronRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunCronRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunCronRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipeline", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipeline == nil {
				m.Pipeline = &Pipeline{}
			}
			if err := m.Pipeline.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateSecretRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateSecretRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateSecretRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.File = append(m.File[:0], dAtA[iNdEx:postIndex]...)
			if m.File == nil {
				m.File = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteSecretRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteSecretRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteSecretRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectSecretRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectSecretRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectSecretRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreationTimestamp == nil {
				m.CreationTimestamp = &types.Timestamp{}
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SecretInfos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SecretInfos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SecretInfos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecretInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecretInfo = append(m.SecretInfo, &SecretInfo{})
			if err := m.SecretInfo[len(m.SecretInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunLoadTestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunLoadTestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunLoadTestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DagSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DagSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parallelism", wireType)
			}
			m.Parallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parallelism |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodPatch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodPatch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunLoadTestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunLoadTestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunLoadTestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderTemplateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderTemplateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderTemplateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Template", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Template = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPps
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPps
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthPps
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPps(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPps
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Args[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenderTemplateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPps
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenderTemplateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenderTemplateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Json", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Json = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPps
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPps
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPps
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Specs = append(m.Specs, &CreatePipelineRequest{})
			if err := m.Specs[len(m.Specs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPps(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPps
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPps(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPps
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPps
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPps
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPps
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPps
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPps        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPps          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPps = fmt.Errorf("proto: unexpected end of group")
)
