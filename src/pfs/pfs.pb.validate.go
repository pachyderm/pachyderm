// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: pfs/pfs.proto

package pfs

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	auth "github.com/pachyderm/pachyderm/v2/src/auth"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = auth.Permission(0)
)

// Validate checks the field values on Repo with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Repo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Repo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RepoMultiError, or nil if none found.
func (m *Repo) ValidateAll() error {
	return m.validate(true)
}

func (m *Repo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Type

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepoMultiError(errors)
	}

	return nil
}

// RepoMultiError is an error wrapping multiple validation errors returned by
// Repo.ValidateAll() if the designated constraints aren't met.
type RepoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoMultiError) AllErrors() []error { return m }

// RepoValidationError is the validation error returned by Repo.Validate if the
// designated constraints aren't met.
type RepoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoValidationError) ErrorName() string { return "RepoValidationError" }

// Error satisfies the builtin error interface
func (e RepoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoValidationError{}

// Validate checks the field values on RepoPicker with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoPicker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoPicker with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoPickerMultiError, or
// nil if none found.
func (m *RepoPicker) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoPicker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Picker.(type) {
	case *RepoPicker_Name:
		if v == nil {
			err := RepoPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoPickerValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoPickerValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoPickerValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RepoPickerMultiError(errors)
	}

	return nil
}

// RepoPickerMultiError is an error wrapping multiple validation errors
// returned by RepoPicker.ValidateAll() if the designated constraints aren't met.
type RepoPickerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoPickerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoPickerMultiError) AllErrors() []error { return m }

// RepoPickerValidationError is the validation error returned by
// RepoPicker.Validate if the designated constraints aren't met.
type RepoPickerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoPickerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoPickerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoPickerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoPickerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoPickerValidationError) ErrorName() string { return "RepoPickerValidationError" }

// Error satisfies the builtin error interface
func (e RepoPickerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoPicker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoPickerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoPickerValidationError{}

// Validate checks the field values on Branch with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Branch) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Branch with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in BranchMultiError, or nil if none found.
func (m *Branch) ValidateAll() error {
	return m.validate(true)
}

func (m *Branch) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return BranchMultiError(errors)
	}

	return nil
}

// BranchMultiError is an error wrapping multiple validation errors returned by
// Branch.ValidateAll() if the designated constraints aren't met.
type BranchMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchMultiError) AllErrors() []error { return m }

// BranchValidationError is the validation error returned by Branch.Validate if
// the designated constraints aren't met.
type BranchValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchValidationError) ErrorName() string { return "BranchValidationError" }

// Error satisfies the builtin error interface
func (e BranchValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranch.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchValidationError{}

// Validate checks the field values on BranchPicker with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BranchPicker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BranchPicker with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BranchPickerMultiError, or
// nil if none found.
func (m *BranchPicker) ValidateAll() error {
	return m.validate(true)
}

func (m *BranchPicker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Picker.(type) {
	case *BranchPicker_Name:
		if v == nil {
			err := BranchPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetName()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BranchPickerValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BranchPickerValidationError{
						field:  "Name",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetName()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BranchPickerValidationError{
					field:  "Name",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return BranchPickerMultiError(errors)
	}

	return nil
}

// BranchPickerMultiError is an error wrapping multiple validation errors
// returned by BranchPicker.ValidateAll() if the designated constraints aren't met.
type BranchPickerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchPickerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchPickerMultiError) AllErrors() []error { return m }

// BranchPickerValidationError is the validation error returned by
// BranchPicker.Validate if the designated constraints aren't met.
type BranchPickerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchPickerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchPickerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchPickerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchPickerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchPickerValidationError) ErrorName() string { return "BranchPickerValidationError" }

// Error satisfies the builtin error interface
func (e BranchPickerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranchPicker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchPickerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchPickerValidationError{}

// Validate checks the field values on File with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *File) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on File with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FileMultiError, or nil if none found.
func (m *File) ValidateAll() error {
	return m.validate(true)
}

func (m *File) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Path

	// no validation rules for Datum

	if len(errors) > 0 {
		return FileMultiError(errors)
	}

	return nil
}

// FileMultiError is an error wrapping multiple validation errors returned by
// File.ValidateAll() if the designated constraints aren't met.
type FileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileMultiError) AllErrors() []error { return m }

// FileValidationError is the validation error returned by File.Validate if the
// designated constraints aren't met.
type FileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileValidationError) ErrorName() string { return "FileValidationError" }

// Error satisfies the builtin error interface
func (e FileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileValidationError{}

// Validate checks the field values on RepoInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoInfoMultiError, or nil
// if none found.
func (m *RepoInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoInfoValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreated()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "Created",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreated()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoInfoValidationError{
				field:  "Created",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SizeBytesUpperBound

	// no validation rules for Description

	for idx, item := range m.GetBranches() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RepoInfoValidationError{
						field:  fmt.Sprintf("Branches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RepoInfoValidationError{
						field:  fmt.Sprintf("Branches[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RepoInfoValidationError{
					field:  fmt.Sprintf("Branches[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetAuthInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "AuthInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "AuthInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoInfoValidationError{
				field:  "AuthInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoInfoValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RepoInfoMultiError(errors)
	}

	return nil
}

// RepoInfoMultiError is an error wrapping multiple validation errors returned
// by RepoInfo.ValidateAll() if the designated constraints aren't met.
type RepoInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoInfoMultiError) AllErrors() []error { return m }

// RepoInfoValidationError is the validation error returned by
// RepoInfo.Validate if the designated constraints aren't met.
type RepoInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoInfoValidationError) ErrorName() string { return "RepoInfoValidationError" }

// Error satisfies the builtin error interface
func (e RepoInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoInfoValidationError{}

// Validate checks the field values on AuthInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AuthInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AuthInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AuthInfoMultiError, or nil
// if none found.
func (m *AuthInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *AuthInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return AuthInfoMultiError(errors)
	}

	return nil
}

// AuthInfoMultiError is an error wrapping multiple validation errors returned
// by AuthInfo.ValidateAll() if the designated constraints aren't met.
type AuthInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AuthInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AuthInfoMultiError) AllErrors() []error { return m }

// AuthInfoValidationError is the validation error returned by
// AuthInfo.Validate if the designated constraints aren't met.
type AuthInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AuthInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AuthInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AuthInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AuthInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AuthInfoValidationError) ErrorName() string { return "AuthInfoValidationError" }

// Error satisfies the builtin error interface
func (e AuthInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAuthInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AuthInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AuthInfoValidationError{}

// Validate checks the field values on BranchInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BranchInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BranchInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BranchInfoMultiError, or
// nil if none found.
func (m *BranchInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *BranchInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchInfoValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchInfoValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchInfoValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchInfoValidationError{
					field:  "Head",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchInfoValidationError{
					field:  "Head",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchInfoValidationError{
				field:  "Head",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProvenance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BranchInfoValidationError{
						field:  fmt.Sprintf("Provenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BranchInfoValidationError{
						field:  fmt.Sprintf("Provenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BranchInfoValidationError{
					field:  fmt.Sprintf("Provenance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetSubvenance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BranchInfoValidationError{
						field:  fmt.Sprintf("Subvenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BranchInfoValidationError{
						field:  fmt.Sprintf("Subvenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BranchInfoValidationError{
					field:  fmt.Sprintf("Subvenance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetDirectProvenance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BranchInfoValidationError{
						field:  fmt.Sprintf("DirectProvenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BranchInfoValidationError{
						field:  fmt.Sprintf("DirectProvenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BranchInfoValidationError{
					field:  fmt.Sprintf("DirectProvenance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTrigger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchInfoValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchInfoValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrigger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchInfoValidationError{
				field:  "Trigger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return BranchInfoMultiError(errors)
	}

	return nil
}

// BranchInfoMultiError is an error wrapping multiple validation errors
// returned by BranchInfo.ValidateAll() if the designated constraints aren't met.
type BranchInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchInfoMultiError) AllErrors() []error { return m }

// BranchInfoValidationError is the validation error returned by
// BranchInfo.Validate if the designated constraints aren't met.
type BranchInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchInfoValidationError) ErrorName() string { return "BranchInfoValidationError" }

// Error satisfies the builtin error interface
func (e BranchInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranchInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchInfoValidationError{}

// Validate checks the field values on Trigger with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Trigger) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Trigger with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TriggerMultiError, or nil if none found.
func (m *Trigger) ValidateAll() error {
	return m.validate(true)
}

func (m *Trigger) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Branch

	// no validation rules for All

	// no validation rules for RateLimitSpec

	// no validation rules for Size

	// no validation rules for Commits

	// no validation rules for CronSpec

	if len(errors) > 0 {
		return TriggerMultiError(errors)
	}

	return nil
}

// TriggerMultiError is an error wrapping multiple validation errors returned
// by Trigger.ValidateAll() if the designated constraints aren't met.
type TriggerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TriggerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TriggerMultiError) AllErrors() []error { return m }

// TriggerValidationError is the validation error returned by Trigger.Validate
// if the designated constraints aren't met.
type TriggerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TriggerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TriggerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TriggerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TriggerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TriggerValidationError) ErrorName() string { return "TriggerValidationError" }

// Error satisfies the builtin error interface
func (e TriggerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTrigger.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TriggerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TriggerValidationError{}

// Validate checks the field values on CommitOrigin with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommitOrigin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitOrigin with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommitOriginMultiError, or
// nil if none found.
func (m *CommitOrigin) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitOrigin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Kind

	if len(errors) > 0 {
		return CommitOriginMultiError(errors)
	}

	return nil
}

// CommitOriginMultiError is an error wrapping multiple validation errors
// returned by CommitOrigin.ValidateAll() if the designated constraints aren't met.
type CommitOriginMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitOriginMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitOriginMultiError) AllErrors() []error { return m }

// CommitOriginValidationError is the validation error returned by
// CommitOrigin.Validate if the designated constraints aren't met.
type CommitOriginValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitOriginValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitOriginValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitOriginValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitOriginValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitOriginValidationError) ErrorName() string { return "CommitOriginValidationError" }

// Error satisfies the builtin error interface
func (e CommitOriginValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitOrigin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitOriginValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitOriginValidationError{}

// Validate checks the field values on Commit with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Commit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Commit with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CommitMultiError, or nil if none found.
func (m *Commit) ValidateAll() error {
	return m.validate(true)
}

func (m *Commit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommitMultiError(errors)
	}

	return nil
}

// CommitMultiError is an error wrapping multiple validation errors returned by
// Commit.ValidateAll() if the designated constraints aren't met.
type CommitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitMultiError) AllErrors() []error { return m }

// CommitValidationError is the validation error returned by Commit.Validate if
// the designated constraints aren't met.
type CommitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitValidationError) ErrorName() string { return "CommitValidationError" }

// Error satisfies the builtin error interface
func (e CommitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitValidationError{}

// Validate checks the field values on CommitPicker with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommitPicker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitPicker with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommitPickerMultiError, or
// nil if none found.
func (m *CommitPicker) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitPicker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Picker.(type) {
	case *CommitPicker_BranchHead:
		if v == nil {
			err := CommitPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBranchHead()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "BranchHead",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "BranchHead",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBranchHead()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitPickerValidationError{
					field:  "BranchHead",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CommitPicker_Id:
		if v == nil {
			err := CommitPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetId()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "Id",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "Id",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitPickerValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CommitPicker_Ancestor:
		if v == nil {
			err := CommitPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAncestor()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "Ancestor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "Ancestor",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAncestor()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitPickerValidationError{
					field:  "Ancestor",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *CommitPicker_BranchRoot_:
		if v == nil {
			err := CommitPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBranchRoot()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "BranchRoot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitPickerValidationError{
						field:  "BranchRoot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBranchRoot()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitPickerValidationError{
					field:  "BranchRoot",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return CommitPickerMultiError(errors)
	}

	return nil
}

// CommitPickerMultiError is an error wrapping multiple validation errors
// returned by CommitPicker.ValidateAll() if the designated constraints aren't met.
type CommitPickerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitPickerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitPickerMultiError) AllErrors() []error { return m }

// CommitPickerValidationError is the validation error returned by
// CommitPicker.Validate if the designated constraints aren't met.
type CommitPickerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitPickerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitPickerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitPickerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitPickerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitPickerValidationError) ErrorName() string { return "CommitPickerValidationError" }

// Error satisfies the builtin error interface
func (e CommitPickerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitPicker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitPickerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitPickerValidationError{}

// Validate checks the field values on CommitInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommitInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommitInfoMultiError, or
// nil if none found.
func (m *CommitInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOrigin()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Origin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Origin",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOrigin()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "Origin",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetParentCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "ParentCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "ParentCommit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParentCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "ParentCommit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetChildCommits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitInfoValidationError{
						field:  fmt.Sprintf("ChildCommits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitInfoValidationError{
						field:  fmt.Sprintf("ChildCommits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitInfoValidationError{
					field:  fmt.Sprintf("ChildCommits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetStarted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Started",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Started",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStarted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "Started",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinishing()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Finishing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Finishing",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinishing()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "Finishing",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFinished()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Finished",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Finished",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFinished()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "Finished",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetDirectProvenance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitInfoValidationError{
						field:  fmt.Sprintf("DirectProvenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitInfoValidationError{
						field:  fmt.Sprintf("DirectProvenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitInfoValidationError{
					field:  fmt.Sprintf("DirectProvenance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Error

	// no validation rules for SizeBytesUpperBound

	if all {
		switch v := interface{}(m.GetDetails()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfoValidationError{
					field:  "Details",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDetails()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfoValidationError{
				field:  "Details",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Metadata

	if len(errors) > 0 {
		return CommitInfoMultiError(errors)
	}

	return nil
}

// CommitInfoMultiError is an error wrapping multiple validation errors
// returned by CommitInfo.ValidateAll() if the designated constraints aren't met.
type CommitInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitInfoMultiError) AllErrors() []error { return m }

// CommitInfoValidationError is the validation error returned by
// CommitInfo.Validate if the designated constraints aren't met.
type CommitInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitInfoValidationError) ErrorName() string { return "CommitInfoValidationError" }

// Error satisfies the builtin error interface
func (e CommitInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitInfoValidationError{}

// Validate checks the field values on CommitSet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommitSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitSet with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommitSetMultiError, or nil
// if none found.
func (m *CommitSet) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Id

	if len(errors) > 0 {
		return CommitSetMultiError(errors)
	}

	return nil
}

// CommitSetMultiError is an error wrapping multiple validation errors returned
// by CommitSet.ValidateAll() if the designated constraints aren't met.
type CommitSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitSetMultiError) AllErrors() []error { return m }

// CommitSetValidationError is the validation error returned by
// CommitSet.Validate if the designated constraints aren't met.
type CommitSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitSetValidationError) ErrorName() string { return "CommitSetValidationError" }

// Error satisfies the builtin error interface
func (e CommitSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitSetValidationError{}

// Validate checks the field values on CommitSetInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommitSetInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitSetInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommitSetInfoMultiError, or
// nil if none found.
func (m *CommitSetInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitSetInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommitSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitSetInfoValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitSetInfoValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitSetInfoValidationError{
				field:  "CommitSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetCommits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitSetInfoValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitSetInfoValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitSetInfoValidationError{
					field:  fmt.Sprintf("Commits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CommitSetInfoMultiError(errors)
	}

	return nil
}

// CommitSetInfoMultiError is an error wrapping multiple validation errors
// returned by CommitSetInfo.ValidateAll() if the designated constraints
// aren't met.
type CommitSetInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitSetInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitSetInfoMultiError) AllErrors() []error { return m }

// CommitSetInfoValidationError is the validation error returned by
// CommitSetInfo.Validate if the designated constraints aren't met.
type CommitSetInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitSetInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitSetInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitSetInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitSetInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitSetInfoValidationError) ErrorName() string { return "CommitSetInfoValidationError" }

// Error satisfies the builtin error interface
func (e CommitSetInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitSetInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitSetInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitSetInfoValidationError{}

// Validate checks the field values on FileInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileInfoMultiError, or nil
// if none found.
func (m *FileInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *FileInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileInfoValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileInfoValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileInfoValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileType

	if all {
		switch v := interface{}(m.GetCommitted()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileInfoValidationError{
					field:  "Committed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileInfoValidationError{
					field:  "Committed",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitted()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileInfoValidationError{
				field:  "Committed",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for SizeBytes

	// no validation rules for Hash

	if len(errors) > 0 {
		return FileInfoMultiError(errors)
	}

	return nil
}

// FileInfoMultiError is an error wrapping multiple validation errors returned
// by FileInfo.ValidateAll() if the designated constraints aren't met.
type FileInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileInfoMultiError) AllErrors() []error { return m }

// FileInfoValidationError is the validation error returned by
// FileInfo.Validate if the designated constraints aren't met.
type FileInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileInfoValidationError) ErrorName() string { return "FileInfoValidationError" }

// Error satisfies the builtin error interface
func (e FileInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileInfoValidationError{}

// Validate checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Project) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Project with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ProjectMultiError, or nil if none found.
func (m *Project) ValidateAll() error {
	return m.validate(true)
}

func (m *Project) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ProjectMultiError(errors)
	}

	return nil
}

// ProjectMultiError is an error wrapping multiple validation errors returned
// by Project.ValidateAll() if the designated constraints aren't met.
type ProjectMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectMultiError) AllErrors() []error { return m }

// ProjectValidationError is the validation error returned by Project.Validate
// if the designated constraints aren't met.
type ProjectValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectValidationError) ErrorName() string { return "ProjectValidationError" }

// Error satisfies the builtin error interface
func (e ProjectValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProject.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectValidationError{}

// Validate checks the field values on ProjectInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectInfoMultiError, or
// nil if none found.
func (m *ProjectInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectInfoValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectInfoValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectInfoValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetAuthInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectInfoValidationError{
					field:  "AuthInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectInfoValidationError{
					field:  "AuthInfo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAuthInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectInfoValidationError{
				field:  "AuthInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ProjectInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ProjectInfoValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ProjectInfoValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Metadata

	if len(errors) > 0 {
		return ProjectInfoMultiError(errors)
	}

	return nil
}

// ProjectInfoMultiError is an error wrapping multiple validation errors
// returned by ProjectInfo.ValidateAll() if the designated constraints aren't met.
type ProjectInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectInfoMultiError) AllErrors() []error { return m }

// ProjectInfoValidationError is the validation error returned by
// ProjectInfo.Validate if the designated constraints aren't met.
type ProjectInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectInfoValidationError) ErrorName() string { return "ProjectInfoValidationError" }

// Error satisfies the builtin error interface
func (e ProjectInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectInfoValidationError{}

// Validate checks the field values on ProjectPicker with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProjectPicker) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProjectPicker with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ProjectPickerMultiError, or
// nil if none found.
func (m *ProjectPicker) ValidateAll() error {
	return m.validate(true)
}

func (m *ProjectPicker) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Picker.(type) {
	case *ProjectPicker_Name:
		if v == nil {
			err := ProjectPickerValidationError{
				field:  "Picker",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Name
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ProjectPickerMultiError(errors)
	}

	return nil
}

// ProjectPickerMultiError is an error wrapping multiple validation errors
// returned by ProjectPicker.ValidateAll() if the designated constraints
// aren't met.
type ProjectPickerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProjectPickerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProjectPickerMultiError) AllErrors() []error { return m }

// ProjectPickerValidationError is the validation error returned by
// ProjectPicker.Validate if the designated constraints aren't met.
type ProjectPickerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProjectPickerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProjectPickerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProjectPickerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProjectPickerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProjectPickerValidationError) ErrorName() string { return "ProjectPickerValidationError" }

// Error satisfies the builtin error interface
func (e ProjectPickerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProjectPicker.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProjectPickerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProjectPickerValidationError{}

// Validate checks the field values on CreateRepoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateRepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateRepoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateRepoRequestMultiError, or nil if none found.
func (m *CreateRepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateRepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateRepoRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateRepoRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateRepoRequestValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Update

	if len(errors) > 0 {
		return CreateRepoRequestMultiError(errors)
	}

	return nil
}

// CreateRepoRequestMultiError is an error wrapping multiple validation errors
// returned by CreateRepoRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateRepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateRepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateRepoRequestMultiError) AllErrors() []error { return m }

// CreateRepoRequestValidationError is the validation error returned by
// CreateRepoRequest.Validate if the designated constraints aren't met.
type CreateRepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateRepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateRepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateRepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateRepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateRepoRequestValidationError) ErrorName() string {
	return "CreateRepoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateRepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateRepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateRepoRequestValidationError{}

// Validate checks the field values on InspectRepoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectRepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectRepoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectRepoRequestMultiError, or nil if none found.
func (m *InspectRepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectRepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectRepoRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectRepoRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectRepoRequestValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectRepoRequestMultiError(errors)
	}

	return nil
}

// InspectRepoRequestMultiError is an error wrapping multiple validation errors
// returned by InspectRepoRequest.ValidateAll() if the designated constraints
// aren't met.
type InspectRepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectRepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectRepoRequestMultiError) AllErrors() []error { return m }

// InspectRepoRequestValidationError is the validation error returned by
// InspectRepoRequest.Validate if the designated constraints aren't met.
type InspectRepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectRepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectRepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectRepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectRepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectRepoRequestValidationError) ErrorName() string {
	return "InspectRepoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectRepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectRepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectRepoRequestValidationError{}

// Validate checks the field values on ListRepoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListRepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListRepoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListRepoRequestMultiError, or nil if none found.
func (m *ListRepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListRepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListRepoRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListRepoRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListRepoRequestValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetPage()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListRepoRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListRepoRequestValidationError{
					field:  "Page",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPage()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListRepoRequestValidationError{
				field:  "Page",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListRepoRequestMultiError(errors)
	}

	return nil
}

// ListRepoRequestMultiError is an error wrapping multiple validation errors
// returned by ListRepoRequest.ValidateAll() if the designated constraints
// aren't met.
type ListRepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListRepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListRepoRequestMultiError) AllErrors() []error { return m }

// ListRepoRequestValidationError is the validation error returned by
// ListRepoRequest.Validate if the designated constraints aren't met.
type ListRepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListRepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListRepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListRepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListRepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListRepoRequestValidationError) ErrorName() string { return "ListRepoRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListRepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListRepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListRepoRequestValidationError{}

// Validate checks the field values on RepoPage with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RepoPage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoPage with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RepoPageMultiError, or nil
// if none found.
func (m *RepoPage) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoPage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Order

	// no validation rules for PageSize

	// no validation rules for PageIndex

	if len(errors) > 0 {
		return RepoPageMultiError(errors)
	}

	return nil
}

// RepoPageMultiError is an error wrapping multiple validation errors returned
// by RepoPage.ValidateAll() if the designated constraints aren't met.
type RepoPageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoPageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoPageMultiError) AllErrors() []error { return m }

// RepoPageValidationError is the validation error returned by
// RepoPage.Validate if the designated constraints aren't met.
type RepoPageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoPageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoPageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoPageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoPageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoPageValidationError) ErrorName() string { return "RepoPageValidationError" }

// Error satisfies the builtin error interface
func (e RepoPageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoPage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoPageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoPageValidationError{}

// Validate checks the field values on DeleteRepoRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepoRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepoRequestMultiError, or nil if none found.
func (m *DeleteRepoRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepoRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteRepoRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteRepoRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteRepoRequestValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return DeleteRepoRequestMultiError(errors)
	}

	return nil
}

// DeleteRepoRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteRepoRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteRepoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepoRequestMultiError) AllErrors() []error { return m }

// DeleteRepoRequestValidationError is the validation error returned by
// DeleteRepoRequest.Validate if the designated constraints aren't met.
type DeleteRepoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepoRequestValidationError) ErrorName() string {
	return "DeleteRepoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepoRequestValidationError{}

// Validate checks the field values on DeleteReposRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteReposRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteReposRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteReposRequestMultiError, or nil if none found.
func (m *DeleteReposRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteReposRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetProjects() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteReposRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteReposRequestValidationError{
						field:  fmt.Sprintf("Projects[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteReposRequestValidationError{
					field:  fmt.Sprintf("Projects[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Force

	// no validation rules for All

	if len(errors) > 0 {
		return DeleteReposRequestMultiError(errors)
	}

	return nil
}

// DeleteReposRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteReposRequest.ValidateAll() if the designated constraints
// aren't met.
type DeleteReposRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteReposRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteReposRequestMultiError) AllErrors() []error { return m }

// DeleteReposRequestValidationError is the validation error returned by
// DeleteReposRequest.Validate if the designated constraints aren't met.
type DeleteReposRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteReposRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteReposRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteReposRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteReposRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteReposRequestValidationError) ErrorName() string {
	return "DeleteReposRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteReposRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteReposRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteReposRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteReposRequestValidationError{}

// Validate checks the field values on DeleteRepoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteRepoResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteRepoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteRepoResponseMultiError, or nil if none found.
func (m *DeleteRepoResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteRepoResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Deleted

	if len(errors) > 0 {
		return DeleteRepoResponseMultiError(errors)
	}

	return nil
}

// DeleteRepoResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteRepoResponse.ValidateAll() if the designated constraints
// aren't met.
type DeleteRepoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteRepoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteRepoResponseMultiError) AllErrors() []error { return m }

// DeleteRepoResponseValidationError is the validation error returned by
// DeleteRepoResponse.Validate if the designated constraints aren't met.
type DeleteRepoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteRepoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteRepoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteRepoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteRepoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteRepoResponseValidationError) ErrorName() string {
	return "DeleteRepoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteRepoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteRepoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteRepoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteRepoResponseValidationError{}

// Validate checks the field values on DeleteReposResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteReposResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteReposResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteReposResponseMultiError, or nil if none found.
func (m *DeleteReposResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteReposResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRepos() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DeleteReposResponseValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DeleteReposResponseValidationError{
						field:  fmt.Sprintf("Repos[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DeleteReposResponseValidationError{
					field:  fmt.Sprintf("Repos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DeleteReposResponseMultiError(errors)
	}

	return nil
}

// DeleteReposResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteReposResponse.ValidateAll() if the designated
// constraints aren't met.
type DeleteReposResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteReposResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteReposResponseMultiError) AllErrors() []error { return m }

// DeleteReposResponseValidationError is the validation error returned by
// DeleteReposResponse.Validate if the designated constraints aren't met.
type DeleteReposResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteReposResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteReposResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteReposResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteReposResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteReposResponseValidationError) ErrorName() string {
	return "DeleteReposResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteReposResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteReposResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteReposResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteReposResponseValidationError{}

// Validate checks the field values on StartCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StartCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StartCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StartCommitRequestMultiError, or nil if none found.
func (m *StartCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *StartCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetParent()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartCommitRequestValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartCommitRequestValidationError{
					field:  "Parent",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetParent()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartCommitRequestValidationError{
				field:  "Parent",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StartCommitRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StartCommitRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StartCommitRequestValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StartCommitRequestMultiError(errors)
	}

	return nil
}

// StartCommitRequestMultiError is an error wrapping multiple validation errors
// returned by StartCommitRequest.ValidateAll() if the designated constraints
// aren't met.
type StartCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartCommitRequestMultiError) AllErrors() []error { return m }

// StartCommitRequestValidationError is the validation error returned by
// StartCommitRequest.Validate if the designated constraints aren't met.
type StartCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartCommitRequestValidationError) ErrorName() string {
	return "StartCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e StartCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStartCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartCommitRequestValidationError{}

// Validate checks the field values on FinishCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FinishCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FinishCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FinishCommitRequestMultiError, or nil if none found.
func (m *FinishCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FinishCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FinishCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FinishCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FinishCommitRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Error

	// no validation rules for Force

	if len(errors) > 0 {
		return FinishCommitRequestMultiError(errors)
	}

	return nil
}

// FinishCommitRequestMultiError is an error wrapping multiple validation
// errors returned by FinishCommitRequest.ValidateAll() if the designated
// constraints aren't met.
type FinishCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FinishCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FinishCommitRequestMultiError) AllErrors() []error { return m }

// FinishCommitRequestValidationError is the validation error returned by
// FinishCommitRequest.Validate if the designated constraints aren't met.
type FinishCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FinishCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FinishCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FinishCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FinishCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FinishCommitRequestValidationError) ErrorName() string {
	return "FinishCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FinishCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFinishCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FinishCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FinishCommitRequestValidationError{}

// Validate checks the field values on InspectCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectCommitRequestMultiError, or nil if none found.
func (m *InspectCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectCommitRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Wait

	if len(errors) > 0 {
		return InspectCommitRequestMultiError(errors)
	}

	return nil
}

// InspectCommitRequestMultiError is an error wrapping multiple validation
// errors returned by InspectCommitRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectCommitRequestMultiError) AllErrors() []error { return m }

// InspectCommitRequestValidationError is the validation error returned by
// InspectCommitRequest.Validate if the designated constraints aren't met.
type InspectCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectCommitRequestValidationError) ErrorName() string {
	return "InspectCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectCommitRequestValidationError{}

// Validate checks the field values on ListCommitRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommitRequestMultiError, or nil if none found.
func (m *ListCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommitRequestValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommitRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "To",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommitRequestValidationError{
				field:  "To",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Number

	// no validation rules for Reverse

	// no validation rules for All

	// no validation rules for OriginKind

	if all {
		switch v := interface{}(m.GetStartedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "StartedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommitRequestValidationError{
					field:  "StartedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommitRequestValidationError{
				field:  "StartedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCommitRequestMultiError(errors)
	}

	return nil
}

// ListCommitRequestMultiError is an error wrapping multiple validation errors
// returned by ListCommitRequest.ValidateAll() if the designated constraints
// aren't met.
type ListCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommitRequestMultiError) AllErrors() []error { return m }

// ListCommitRequestValidationError is the validation error returned by
// ListCommitRequest.Validate if the designated constraints aren't met.
type ListCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommitRequestValidationError) ErrorName() string {
	return "ListCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommitRequestValidationError{}

// Validate checks the field values on InspectCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectCommitSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectCommitSetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectCommitSetRequestMultiError, or nil if none found.
func (m *InspectCommitSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectCommitSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommitSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectCommitSetRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectCommitSetRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectCommitSetRequestValidationError{
				field:  "CommitSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Wait

	if len(errors) > 0 {
		return InspectCommitSetRequestMultiError(errors)
	}

	return nil
}

// InspectCommitSetRequestMultiError is an error wrapping multiple validation
// errors returned by InspectCommitSetRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectCommitSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectCommitSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectCommitSetRequestMultiError) AllErrors() []error { return m }

// InspectCommitSetRequestValidationError is the validation error returned by
// InspectCommitSetRequest.Validate if the designated constraints aren't met.
type InspectCommitSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectCommitSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectCommitSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectCommitSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectCommitSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectCommitSetRequestValidationError) ErrorName() string {
	return "InspectCommitSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectCommitSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectCommitSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectCommitSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectCommitSetRequestValidationError{}

// Validate checks the field values on ListCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListCommitSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListCommitSetRequestMultiError, or nil if none found.
func (m *ListCommitSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListCommitSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListCommitSetRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListCommitSetRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListCommitSetRequestValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListCommitSetRequestMultiError(errors)
	}

	return nil
}

// ListCommitSetRequestMultiError is an error wrapping multiple validation
// errors returned by ListCommitSetRequest.ValidateAll() if the designated
// constraints aren't met.
type ListCommitSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCommitSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCommitSetRequestMultiError) AllErrors() []error { return m }

// ListCommitSetRequestValidationError is the validation error returned by
// ListCommitSetRequest.Validate if the designated constraints aren't met.
type ListCommitSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCommitSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCommitSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCommitSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCommitSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCommitSetRequestValidationError) ErrorName() string {
	return "ListCommitSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCommitSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCommitSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCommitSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCommitSetRequestValidationError{}

// Validate checks the field values on SquashCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SquashCommitSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SquashCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SquashCommitSetRequestMultiError, or nil if none found.
func (m *SquashCommitSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SquashCommitSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommitSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SquashCommitSetRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SquashCommitSetRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SquashCommitSetRequestValidationError{
				field:  "CommitSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SquashCommitSetRequestMultiError(errors)
	}

	return nil
}

// SquashCommitSetRequestMultiError is an error wrapping multiple validation
// errors returned by SquashCommitSetRequest.ValidateAll() if the designated
// constraints aren't met.
type SquashCommitSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SquashCommitSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SquashCommitSetRequestMultiError) AllErrors() []error { return m }

// SquashCommitSetRequestValidationError is the validation error returned by
// SquashCommitSetRequest.Validate if the designated constraints aren't met.
type SquashCommitSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SquashCommitSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SquashCommitSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SquashCommitSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SquashCommitSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SquashCommitSetRequestValidationError) ErrorName() string {
	return "SquashCommitSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SquashCommitSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSquashCommitSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SquashCommitSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SquashCommitSetRequestValidationError{}

// Validate checks the field values on DropCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DropCommitSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DropCommitSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DropCommitSetRequestMultiError, or nil if none found.
func (m *DropCommitSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DropCommitSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetCommitSet() == nil {
		err := DropCommitSetRequestValidationError{
			field:  "CommitSet",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCommitSet()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DropCommitSetRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DropCommitSetRequestValidationError{
					field:  "CommitSet",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommitSet()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DropCommitSetRequestValidationError{
				field:  "CommitSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DropCommitSetRequestMultiError(errors)
	}

	return nil
}

// DropCommitSetRequestMultiError is an error wrapping multiple validation
// errors returned by DropCommitSetRequest.ValidateAll() if the designated
// constraints aren't met.
type DropCommitSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DropCommitSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DropCommitSetRequestMultiError) AllErrors() []error { return m }

// DropCommitSetRequestValidationError is the validation error returned by
// DropCommitSetRequest.Validate if the designated constraints aren't met.
type DropCommitSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DropCommitSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DropCommitSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DropCommitSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DropCommitSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DropCommitSetRequestValidationError) ErrorName() string {
	return "DropCommitSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DropCommitSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDropCommitSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DropCommitSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DropCommitSetRequestValidationError{}

// Validate checks the field values on SubscribeCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubscribeCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubscribeCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubscribeCommitRequestMultiError, or nil if none found.
func (m *SubscribeCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SubscribeCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscribeCommitRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscribeCommitRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscribeCommitRequestValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Branch

	if all {
		switch v := interface{}(m.GetFrom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubscribeCommitRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubscribeCommitRequestValidationError{
					field:  "From",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubscribeCommitRequestValidationError{
				field:  "From",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for State

	// no validation rules for All

	// no validation rules for OriginKind

	if len(errors) > 0 {
		return SubscribeCommitRequestMultiError(errors)
	}

	return nil
}

// SubscribeCommitRequestMultiError is an error wrapping multiple validation
// errors returned by SubscribeCommitRequest.ValidateAll() if the designated
// constraints aren't met.
type SubscribeCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubscribeCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubscribeCommitRequestMultiError) AllErrors() []error { return m }

// SubscribeCommitRequestValidationError is the validation error returned by
// SubscribeCommitRequest.Validate if the designated constraints aren't met.
type SubscribeCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubscribeCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubscribeCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubscribeCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubscribeCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubscribeCommitRequestValidationError) ErrorName() string {
	return "SubscribeCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SubscribeCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubscribeCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubscribeCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubscribeCommitRequestValidationError{}

// Validate checks the field values on ClearCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ClearCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClearCommitRequestMultiError, or nil if none found.
func (m *ClearCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClearCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClearCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClearCommitRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ClearCommitRequestMultiError(errors)
	}

	return nil
}

// ClearCommitRequestMultiError is an error wrapping multiple validation errors
// returned by ClearCommitRequest.ValidateAll() if the designated constraints
// aren't met.
type ClearCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearCommitRequestMultiError) AllErrors() []error { return m }

// ClearCommitRequestValidationError is the validation error returned by
// ClearCommitRequest.Validate if the designated constraints aren't met.
type ClearCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearCommitRequestValidationError) ErrorName() string {
	return "ClearCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClearCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearCommitRequestValidationError{}

// Validate checks the field values on SquashCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SquashCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SquashCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SquashCommitRequestMultiError, or nil if none found.
func (m *SquashCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SquashCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SquashCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SquashCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SquashCommitRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Recursive

	if len(errors) > 0 {
		return SquashCommitRequestMultiError(errors)
	}

	return nil
}

// SquashCommitRequestMultiError is an error wrapping multiple validation
// errors returned by SquashCommitRequest.ValidateAll() if the designated
// constraints aren't met.
type SquashCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SquashCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SquashCommitRequestMultiError) AllErrors() []error { return m }

// SquashCommitRequestValidationError is the validation error returned by
// SquashCommitRequest.Validate if the designated constraints aren't met.
type SquashCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SquashCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SquashCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SquashCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SquashCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SquashCommitRequestValidationError) ErrorName() string {
	return "SquashCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SquashCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSquashCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SquashCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SquashCommitRequestValidationError{}

// Validate checks the field values on SquashCommitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SquashCommitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SquashCommitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SquashCommitResponseMultiError, or nil if none found.
func (m *SquashCommitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SquashCommitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SquashCommitResponseMultiError(errors)
	}

	return nil
}

// SquashCommitResponseMultiError is an error wrapping multiple validation
// errors returned by SquashCommitResponse.ValidateAll() if the designated
// constraints aren't met.
type SquashCommitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SquashCommitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SquashCommitResponseMultiError) AllErrors() []error { return m }

// SquashCommitResponseValidationError is the validation error returned by
// SquashCommitResponse.Validate if the designated constraints aren't met.
type SquashCommitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SquashCommitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SquashCommitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SquashCommitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SquashCommitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SquashCommitResponseValidationError) ErrorName() string {
	return "SquashCommitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SquashCommitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSquashCommitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SquashCommitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SquashCommitResponseValidationError{}

// Validate checks the field values on DropCommitRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DropCommitRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DropCommitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DropCommitRequestMultiError, or nil if none found.
func (m *DropCommitRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DropCommitRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DropCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DropCommitRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DropCommitRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Recursive

	if len(errors) > 0 {
		return DropCommitRequestMultiError(errors)
	}

	return nil
}

// DropCommitRequestMultiError is an error wrapping multiple validation errors
// returned by DropCommitRequest.ValidateAll() if the designated constraints
// aren't met.
type DropCommitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DropCommitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DropCommitRequestMultiError) AllErrors() []error { return m }

// DropCommitRequestValidationError is the validation error returned by
// DropCommitRequest.Validate if the designated constraints aren't met.
type DropCommitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DropCommitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DropCommitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DropCommitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DropCommitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DropCommitRequestValidationError) ErrorName() string {
	return "DropCommitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DropCommitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDropCommitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DropCommitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DropCommitRequestValidationError{}

// Validate checks the field values on WalkCommitProvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalkCommitProvenanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalkCommitProvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalkCommitProvenanceRequestMultiError, or nil if none found.
func (m *WalkCommitProvenanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WalkCommitProvenanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStart() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalkCommitProvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalkCommitProvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalkCommitProvenanceRequestValidationError{
					field:  fmt.Sprintf("Start[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MaxCommits

	// no validation rules for MaxDepth

	if len(errors) > 0 {
		return WalkCommitProvenanceRequestMultiError(errors)
	}

	return nil
}

// WalkCommitProvenanceRequestMultiError is an error wrapping multiple
// validation errors returned by WalkCommitProvenanceRequest.ValidateAll() if
// the designated constraints aren't met.
type WalkCommitProvenanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalkCommitProvenanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalkCommitProvenanceRequestMultiError) AllErrors() []error { return m }

// WalkCommitProvenanceRequestValidationError is the validation error returned
// by WalkCommitProvenanceRequest.Validate if the designated constraints
// aren't met.
type WalkCommitProvenanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalkCommitProvenanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalkCommitProvenanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalkCommitProvenanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalkCommitProvenanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalkCommitProvenanceRequestValidationError) ErrorName() string {
	return "WalkCommitProvenanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WalkCommitProvenanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalkCommitProvenanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalkCommitProvenanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalkCommitProvenanceRequestValidationError{}

// Validate checks the field values on WalkCommitSubvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalkCommitSubvenanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalkCommitSubvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalkCommitSubvenanceRequestMultiError, or nil if none found.
func (m *WalkCommitSubvenanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WalkCommitSubvenanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStart() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalkCommitSubvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalkCommitSubvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalkCommitSubvenanceRequestValidationError{
					field:  fmt.Sprintf("Start[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MaxCommits

	// no validation rules for MaxDepth

	if len(errors) > 0 {
		return WalkCommitSubvenanceRequestMultiError(errors)
	}

	return nil
}

// WalkCommitSubvenanceRequestMultiError is an error wrapping multiple
// validation errors returned by WalkCommitSubvenanceRequest.ValidateAll() if
// the designated constraints aren't met.
type WalkCommitSubvenanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalkCommitSubvenanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalkCommitSubvenanceRequestMultiError) AllErrors() []error { return m }

// WalkCommitSubvenanceRequestValidationError is the validation error returned
// by WalkCommitSubvenanceRequest.Validate if the designated constraints
// aren't met.
type WalkCommitSubvenanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalkCommitSubvenanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalkCommitSubvenanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalkCommitSubvenanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalkCommitSubvenanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalkCommitSubvenanceRequestValidationError) ErrorName() string {
	return "WalkCommitSubvenanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WalkCommitSubvenanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalkCommitSubvenanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalkCommitSubvenanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalkCommitSubvenanceRequestValidationError{}

// Validate checks the field values on WalkBranchProvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalkBranchProvenanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalkBranchProvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalkBranchProvenanceRequestMultiError, or nil if none found.
func (m *WalkBranchProvenanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WalkBranchProvenanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStart() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalkBranchProvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalkBranchProvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalkBranchProvenanceRequestValidationError{
					field:  fmt.Sprintf("Start[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MaxBranches

	// no validation rules for MaxDepth

	if len(errors) > 0 {
		return WalkBranchProvenanceRequestMultiError(errors)
	}

	return nil
}

// WalkBranchProvenanceRequestMultiError is an error wrapping multiple
// validation errors returned by WalkBranchProvenanceRequest.ValidateAll() if
// the designated constraints aren't met.
type WalkBranchProvenanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalkBranchProvenanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalkBranchProvenanceRequestMultiError) AllErrors() []error { return m }

// WalkBranchProvenanceRequestValidationError is the validation error returned
// by WalkBranchProvenanceRequest.Validate if the designated constraints
// aren't met.
type WalkBranchProvenanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalkBranchProvenanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalkBranchProvenanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalkBranchProvenanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalkBranchProvenanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalkBranchProvenanceRequestValidationError) ErrorName() string {
	return "WalkBranchProvenanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WalkBranchProvenanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalkBranchProvenanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalkBranchProvenanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalkBranchProvenanceRequestValidationError{}

// Validate checks the field values on WalkBranchSubvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalkBranchSubvenanceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalkBranchSubvenanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalkBranchSubvenanceRequestMultiError, or nil if none found.
func (m *WalkBranchSubvenanceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WalkBranchSubvenanceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStart() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalkBranchSubvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalkBranchSubvenanceRequestValidationError{
						field:  fmt.Sprintf("Start[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalkBranchSubvenanceRequestValidationError{
					field:  fmt.Sprintf("Start[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for MaxBranches

	// no validation rules for MaxDepth

	if len(errors) > 0 {
		return WalkBranchSubvenanceRequestMultiError(errors)
	}

	return nil
}

// WalkBranchSubvenanceRequestMultiError is an error wrapping multiple
// validation errors returned by WalkBranchSubvenanceRequest.ValidateAll() if
// the designated constraints aren't met.
type WalkBranchSubvenanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalkBranchSubvenanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalkBranchSubvenanceRequestMultiError) AllErrors() []error { return m }

// WalkBranchSubvenanceRequestValidationError is the validation error returned
// by WalkBranchSubvenanceRequest.Validate if the designated constraints
// aren't met.
type WalkBranchSubvenanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalkBranchSubvenanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalkBranchSubvenanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalkBranchSubvenanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalkBranchSubvenanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalkBranchSubvenanceRequestValidationError) ErrorName() string {
	return "WalkBranchSubvenanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e WalkBranchSubvenanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalkBranchSubvenanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalkBranchSubvenanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalkBranchSubvenanceRequestValidationError{}

// Validate checks the field values on DropCommitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DropCommitResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DropCommitResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DropCommitResponseMultiError, or nil if none found.
func (m *DropCommitResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DropCommitResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DropCommitResponseMultiError(errors)
	}

	return nil
}

// DropCommitResponseMultiError is an error wrapping multiple validation errors
// returned by DropCommitResponse.ValidateAll() if the designated constraints
// aren't met.
type DropCommitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DropCommitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DropCommitResponseMultiError) AllErrors() []error { return m }

// DropCommitResponseValidationError is the validation error returned by
// DropCommitResponse.Validate if the designated constraints aren't met.
type DropCommitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DropCommitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DropCommitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DropCommitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DropCommitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DropCommitResponseValidationError) ErrorName() string {
	return "DropCommitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DropCommitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDropCommitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DropCommitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DropCommitResponseValidationError{}

// Validate checks the field values on CreateBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateBranchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateBranchRequestMultiError, or nil if none found.
func (m *CreateBranchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateBranchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHead()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBranchRequestValidationError{
					field:  "Head",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBranchRequestValidationError{
					field:  "Head",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHead()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBranchRequestValidationError{
				field:  "Head",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBranchRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBranchRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBranchRequestValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetProvenance() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateBranchRequestValidationError{
						field:  fmt.Sprintf("Provenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateBranchRequestValidationError{
						field:  fmt.Sprintf("Provenance[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateBranchRequestValidationError{
					field:  fmt.Sprintf("Provenance[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTrigger()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateBranchRequestValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateBranchRequestValidationError{
					field:  "Trigger",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTrigger()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateBranchRequestValidationError{
				field:  "Trigger",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for NewCommitSet

	if len(errors) > 0 {
		return CreateBranchRequestMultiError(errors)
	}

	return nil
}

// CreateBranchRequestMultiError is an error wrapping multiple validation
// errors returned by CreateBranchRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateBranchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateBranchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateBranchRequestMultiError) AllErrors() []error { return m }

// CreateBranchRequestValidationError is the validation error returned by
// CreateBranchRequest.Validate if the designated constraints aren't met.
type CreateBranchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateBranchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateBranchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateBranchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateBranchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateBranchRequestValidationError) ErrorName() string {
	return "CreateBranchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateBranchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateBranchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateBranchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateBranchRequestValidationError{}

// Validate checks the field values on FindCommitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FindCommitsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindCommitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FindCommitsRequestMultiError, or nil if none found.
func (m *FindCommitsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FindCommitsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetStart() == nil {
		err := FindCommitsRequestValidationError{
			field:  "Start",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FindCommitsRequestValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FindCommitsRequestValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FindCommitsRequestValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FilePath

	// no validation rules for Limit

	if len(errors) > 0 {
		return FindCommitsRequestMultiError(errors)
	}

	return nil
}

// FindCommitsRequestMultiError is an error wrapping multiple validation errors
// returned by FindCommitsRequest.ValidateAll() if the designated constraints
// aren't met.
type FindCommitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindCommitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindCommitsRequestMultiError) AllErrors() []error { return m }

// FindCommitsRequestValidationError is the validation error returned by
// FindCommitsRequest.Validate if the designated constraints aren't met.
type FindCommitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindCommitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindCommitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindCommitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindCommitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindCommitsRequestValidationError) ErrorName() string {
	return "FindCommitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FindCommitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindCommitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindCommitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindCommitsRequestValidationError{}

// Validate checks the field values on FindCommitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *FindCommitsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FindCommitsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FindCommitsResponseMultiError, or nil if none found.
func (m *FindCommitsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FindCommitsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CommitsSearched

	switch v := m.Result.(type) {
	case *FindCommitsResponse_FoundCommit:
		if v == nil {
			err := FindCommitsResponseValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFoundCommit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FindCommitsResponseValidationError{
						field:  "FoundCommit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FindCommitsResponseValidationError{
						field:  "FoundCommit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFoundCommit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FindCommitsResponseValidationError{
					field:  "FoundCommit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FindCommitsResponse_LastSearchedCommit:
		if v == nil {
			err := FindCommitsResponseValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLastSearchedCommit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FindCommitsResponseValidationError{
						field:  "LastSearchedCommit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FindCommitsResponseValidationError{
						field:  "LastSearchedCommit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastSearchedCommit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FindCommitsResponseValidationError{
					field:  "LastSearchedCommit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FindCommitsResponseMultiError(errors)
	}

	return nil
}

// FindCommitsResponseMultiError is an error wrapping multiple validation
// errors returned by FindCommitsResponse.ValidateAll() if the designated
// constraints aren't met.
type FindCommitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FindCommitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FindCommitsResponseMultiError) AllErrors() []error { return m }

// FindCommitsResponseValidationError is the validation error returned by
// FindCommitsResponse.Validate if the designated constraints aren't met.
type FindCommitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FindCommitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FindCommitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FindCommitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FindCommitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FindCommitsResponseValidationError) ErrorName() string {
	return "FindCommitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FindCommitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFindCommitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FindCommitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FindCommitsResponseValidationError{}

// Validate checks the field values on InspectBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectBranchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectBranchRequestMultiError, or nil if none found.
func (m *InspectBranchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectBranchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectBranchRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectBranchRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectBranchRequestValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectBranchRequestMultiError(errors)
	}

	return nil
}

// InspectBranchRequestMultiError is an error wrapping multiple validation
// errors returned by InspectBranchRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectBranchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectBranchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectBranchRequestMultiError) AllErrors() []error { return m }

// InspectBranchRequestValidationError is the validation error returned by
// InspectBranchRequest.Validate if the designated constraints aren't met.
type InspectBranchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectBranchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectBranchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectBranchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectBranchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectBranchRequestValidationError) ErrorName() string {
	return "InspectBranchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectBranchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectBranchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectBranchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectBranchRequestValidationError{}

// Validate checks the field values on ListBranchRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListBranchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListBranchRequestMultiError, or nil if none found.
func (m *ListBranchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListBranchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListBranchRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListBranchRequestValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListBranchRequestValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reverse

	if len(errors) > 0 {
		return ListBranchRequestMultiError(errors)
	}

	return nil
}

// ListBranchRequestMultiError is an error wrapping multiple validation errors
// returned by ListBranchRequest.ValidateAll() if the designated constraints
// aren't met.
type ListBranchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBranchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBranchRequestMultiError) AllErrors() []error { return m }

// ListBranchRequestValidationError is the validation error returned by
// ListBranchRequest.Validate if the designated constraints aren't met.
type ListBranchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBranchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBranchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBranchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBranchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBranchRequestValidationError) ErrorName() string {
	return "ListBranchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBranchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBranchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBranchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBranchRequestValidationError{}

// Validate checks the field values on DeleteBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteBranchRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteBranchRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteBranchRequestMultiError, or nil if none found.
func (m *DeleteBranchRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteBranchRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetBranch() == nil {
		err := DeleteBranchRequestValidationError{
			field:  "Branch",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteBranchRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteBranchRequestValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteBranchRequestValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return DeleteBranchRequestMultiError(errors)
	}

	return nil
}

// DeleteBranchRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteBranchRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteBranchRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteBranchRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteBranchRequestMultiError) AllErrors() []error { return m }

// DeleteBranchRequestValidationError is the validation error returned by
// DeleteBranchRequest.Validate if the designated constraints aren't met.
type DeleteBranchRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteBranchRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteBranchRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteBranchRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteBranchRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteBranchRequestValidationError) ErrorName() string {
	return "DeleteBranchRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteBranchRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteBranchRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteBranchRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteBranchRequestValidationError{}

// Validate checks the field values on CreateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateProjectRequestMultiError, or nil if none found.
func (m *CreateProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateProjectRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateProjectRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateProjectRequestValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Description

	// no validation rules for Update

	if len(errors) > 0 {
		return CreateProjectRequestMultiError(errors)
	}

	return nil
}

// CreateProjectRequestMultiError is an error wrapping multiple validation
// errors returned by CreateProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateProjectRequestMultiError) AllErrors() []error { return m }

// CreateProjectRequestValidationError is the validation error returned by
// CreateProjectRequest.Validate if the designated constraints aren't met.
type CreateProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateProjectRequestValidationError) ErrorName() string {
	return "CreateProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateProjectRequestValidationError{}

// Validate checks the field values on InspectProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectProjectRequestMultiError, or nil if none found.
func (m *InspectProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProject() == nil {
		err := InspectProjectRequestValidationError{
			field:  "Project",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectProjectRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectProjectRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectProjectRequestValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectProjectRequestMultiError(errors)
	}

	return nil
}

// InspectProjectRequestMultiError is an error wrapping multiple validation
// errors returned by InspectProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type InspectProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectProjectRequestMultiError) AllErrors() []error { return m }

// InspectProjectRequestValidationError is the validation error returned by
// InspectProjectRequest.Validate if the designated constraints aren't met.
type InspectProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectProjectRequestValidationError) ErrorName() string {
	return "InspectProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectProjectRequestValidationError{}

// Validate checks the field values on InspectProjectV2Request with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectProjectV2Request) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectProjectV2Request with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectProjectV2RequestMultiError, or nil if none found.
func (m *InspectProjectV2Request) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectProjectV2Request) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetProject() == nil {
		err := InspectProjectV2RequestValidationError{
			field:  "Project",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectProjectV2RequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectProjectV2RequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectProjectV2RequestValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectProjectV2RequestMultiError(errors)
	}

	return nil
}

// InspectProjectV2RequestMultiError is an error wrapping multiple validation
// errors returned by InspectProjectV2Request.ValidateAll() if the designated
// constraints aren't met.
type InspectProjectV2RequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectProjectV2RequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectProjectV2RequestMultiError) AllErrors() []error { return m }

// InspectProjectV2RequestValidationError is the validation error returned by
// InspectProjectV2Request.Validate if the designated constraints aren't met.
type InspectProjectV2RequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectProjectV2RequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectProjectV2RequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectProjectV2RequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectProjectV2RequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectProjectV2RequestValidationError) ErrorName() string {
	return "InspectProjectV2RequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectProjectV2RequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectProjectV2Request.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectProjectV2RequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectProjectV2RequestValidationError{}

// Validate checks the field values on InspectProjectV2Response with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectProjectV2Response) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectProjectV2Response with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectProjectV2ResponseMultiError, or nil if none found.
func (m *InspectProjectV2Response) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectProjectV2Response) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetInfo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectProjectV2ResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectProjectV2ResponseValidationError{
					field:  "Info",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInfo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectProjectV2ResponseValidationError{
				field:  "Info",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DefaultsJson

	if len(errors) > 0 {
		return InspectProjectV2ResponseMultiError(errors)
	}

	return nil
}

// InspectProjectV2ResponseMultiError is an error wrapping multiple validation
// errors returned by InspectProjectV2Response.ValidateAll() if the designated
// constraints aren't met.
type InspectProjectV2ResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectProjectV2ResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectProjectV2ResponseMultiError) AllErrors() []error { return m }

// InspectProjectV2ResponseValidationError is the validation error returned by
// InspectProjectV2Response.Validate if the designated constraints aren't met.
type InspectProjectV2ResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectProjectV2ResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectProjectV2ResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectProjectV2ResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectProjectV2ResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectProjectV2ResponseValidationError) ErrorName() string {
	return "InspectProjectV2ResponseValidationError"
}

// Error satisfies the builtin error interface
func (e InspectProjectV2ResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectProjectV2Response.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectProjectV2ResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectProjectV2ResponseValidationError{}

// Validate checks the field values on ListProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListProjectRequestMultiError, or nil if none found.
func (m *ListProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListProjectRequestMultiError(errors)
	}

	return nil
}

// ListProjectRequestMultiError is an error wrapping multiple validation errors
// returned by ListProjectRequest.ValidateAll() if the designated constraints
// aren't met.
type ListProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListProjectRequestMultiError) AllErrors() []error { return m }

// ListProjectRequestValidationError is the validation error returned by
// ListProjectRequest.Validate if the designated constraints aren't met.
type ListProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListProjectRequestValidationError) ErrorName() string {
	return "ListProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListProjectRequestValidationError{}

// Validate checks the field values on DeleteProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DeleteProjectRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteProjectRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeleteProjectRequestMultiError, or nil if none found.
func (m *DeleteProjectRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteProjectRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DeleteProjectRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DeleteProjectRequestValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DeleteProjectRequestValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Force

	if len(errors) > 0 {
		return DeleteProjectRequestMultiError(errors)
	}

	return nil
}

// DeleteProjectRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteProjectRequest.ValidateAll() if the designated
// constraints aren't met.
type DeleteProjectRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteProjectRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteProjectRequestMultiError) AllErrors() []error { return m }

// DeleteProjectRequestValidationError is the validation error returned by
// DeleteProjectRequest.Validate if the designated constraints aren't met.
type DeleteProjectRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteProjectRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteProjectRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteProjectRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteProjectRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteProjectRequestValidationError) ErrorName() string {
	return "DeleteProjectRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteProjectRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteProjectRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteProjectRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteProjectRequestValidationError{}

// Validate checks the field values on AddFile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFile with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddFileMultiError, or nil if none found.
func (m *AddFile) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Datum

	switch v := m.Source.(type) {
	case *AddFile_Raw:
		if v == nil {
			err := AddFileValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRaw()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddFileValidationError{
						field:  "Raw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddFileValidationError{
						field:  "Raw",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRaw()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddFileValidationError{
					field:  "Raw",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *AddFile_Url:
		if v == nil {
			err := AddFileValidationError{
				field:  "Source",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUrl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AddFileValidationError{
						field:  "Url",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AddFileValidationError{
						field:  "Url",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUrl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AddFileValidationError{
					field:  "Url",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AddFileMultiError(errors)
	}

	return nil
}

// AddFileMultiError is an error wrapping multiple validation errors returned
// by AddFile.ValidateAll() if the designated constraints aren't met.
type AddFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFileMultiError) AllErrors() []error { return m }

// AddFileValidationError is the validation error returned by AddFile.Validate
// if the designated constraints aren't met.
type AddFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFileValidationError) ErrorName() string { return "AddFileValidationError" }

// Error satisfies the builtin error interface
func (e AddFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFileValidationError{}

// Validate checks the field values on DeleteFile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DeleteFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DeleteFile with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DeleteFileMultiError, or
// nil if none found.
func (m *DeleteFile) ValidateAll() error {
	return m.validate(true)
}

func (m *DeleteFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Path

	// no validation rules for Datum

	if len(errors) > 0 {
		return DeleteFileMultiError(errors)
	}

	return nil
}

// DeleteFileMultiError is an error wrapping multiple validation errors
// returned by DeleteFile.ValidateAll() if the designated constraints aren't met.
type DeleteFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteFileMultiError) AllErrors() []error { return m }

// DeleteFileValidationError is the validation error returned by
// DeleteFile.Validate if the designated constraints aren't met.
type DeleteFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteFileValidationError) ErrorName() string { return "DeleteFileValidationError" }

// Error satisfies the builtin error interface
func (e DeleteFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteFileValidationError{}

// Validate checks the field values on CopyFile with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CopyFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CopyFile with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CopyFileMultiError, or nil
// if none found.
func (m *CopyFile) ValidateAll() error {
	return m.validate(true)
}

func (m *CopyFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Dst

	// no validation rules for Datum

	if m.GetSrc() == nil {
		err := CopyFileValidationError{
			field:  "Src",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetSrc()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CopyFileValidationError{
					field:  "Src",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CopyFileValidationError{
					field:  "Src",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSrc()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CopyFileValidationError{
				field:  "Src",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Append

	if len(errors) > 0 {
		return CopyFileMultiError(errors)
	}

	return nil
}

// CopyFileMultiError is an error wrapping multiple validation errors returned
// by CopyFile.ValidateAll() if the designated constraints aren't met.
type CopyFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CopyFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CopyFileMultiError) AllErrors() []error { return m }

// CopyFileValidationError is the validation error returned by
// CopyFile.Validate if the designated constraints aren't met.
type CopyFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CopyFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CopyFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CopyFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CopyFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CopyFileValidationError) ErrorName() string { return "CopyFileValidationError" }

// Error satisfies the builtin error interface
func (e CopyFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCopyFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CopyFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CopyFileValidationError{}

// Validate checks the field values on ModifyFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModifyFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModifyFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModifyFileRequestMultiError, or nil if none found.
func (m *ModifyFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ModifyFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Body.(type) {
	case *ModifyFileRequest_SetCommit:
		if v == nil {
			err := ModifyFileRequestValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetSetCommit() == nil {
			err := ModifyFileRequestValidationError{
				field:  "SetCommit",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetCommit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "SetCommit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "SetCommit",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetCommit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModifyFileRequestValidationError{
					field:  "SetCommit",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModifyFileRequest_AddFile:
		if v == nil {
			err := ModifyFileRequestValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetAddFile() == nil {
			err := ModifyFileRequestValidationError{
				field:  "AddFile",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAddFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "AddFile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "AddFile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAddFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModifyFileRequestValidationError{
					field:  "AddFile",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModifyFileRequest_DeleteFile:
		if v == nil {
			err := ModifyFileRequestValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetDeleteFile() == nil {
			err := ModifyFileRequestValidationError{
				field:  "DeleteFile",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeleteFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "DeleteFile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "DeleteFile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeleteFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModifyFileRequestValidationError{
					field:  "DeleteFile",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ModifyFileRequest_CopyFile:
		if v == nil {
			err := ModifyFileRequestValidationError{
				field:  "Body",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetCopyFile() == nil {
			err := ModifyFileRequestValidationError{
				field:  "CopyFile",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCopyFile()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "CopyFile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ModifyFileRequestValidationError{
						field:  "CopyFile",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCopyFile()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ModifyFileRequestValidationError{
					field:  "CopyFile",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ModifyFileRequestMultiError(errors)
	}

	return nil
}

// ModifyFileRequestMultiError is an error wrapping multiple validation errors
// returned by ModifyFileRequest.ValidateAll() if the designated constraints
// aren't met.
type ModifyFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModifyFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModifyFileRequestMultiError) AllErrors() []error { return m }

// ModifyFileRequestValidationError is the validation error returned by
// ModifyFileRequest.Validate if the designated constraints aren't met.
type ModifyFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModifyFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModifyFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModifyFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModifyFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModifyFileRequestValidationError) ErrorName() string {
	return "ModifyFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ModifyFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModifyFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModifyFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModifyFileRequestValidationError{}

// Validate checks the field values on GetFileRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetFileRequestMultiError,
// or nil if none found.
func (m *GetFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFileRequestValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for URL

	// no validation rules for Offset

	if all {
		switch v := interface{}(m.GetPathRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFileRequestValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFileRequestValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPathRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFileRequestValidationError{
				field:  "PathRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetFileRequestMultiError(errors)
	}

	return nil
}

// GetFileRequestMultiError is an error wrapping multiple validation errors
// returned by GetFileRequest.ValidateAll() if the designated constraints
// aren't met.
type GetFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileRequestMultiError) AllErrors() []error { return m }

// GetFileRequestValidationError is the validation error returned by
// GetFileRequest.Validate if the designated constraints aren't met.
type GetFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileRequestValidationError) ErrorName() string { return "GetFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileRequestValidationError{}

// Validate checks the field values on InspectFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InspectFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InspectFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InspectFileRequestMultiError, or nil if none found.
func (m *InspectFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InspectFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, InspectFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, InspectFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return InspectFileRequestValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return InspectFileRequestMultiError(errors)
	}

	return nil
}

// InspectFileRequestMultiError is an error wrapping multiple validation errors
// returned by InspectFileRequest.ValidateAll() if the designated constraints
// aren't met.
type InspectFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InspectFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InspectFileRequestMultiError) AllErrors() []error { return m }

// InspectFileRequestValidationError is the validation error returned by
// InspectFileRequest.Validate if the designated constraints aren't met.
type InspectFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InspectFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InspectFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InspectFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InspectFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InspectFileRequestValidationError) ErrorName() string {
	return "InspectFileRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InspectFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInspectFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InspectFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InspectFileRequestValidationError{}

// Validate checks the field values on ListFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListFileRequestMultiError, or nil if none found.
func (m *ListFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFileRequestValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaginationMarker()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListFileRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListFileRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaginationMarker()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListFileRequestValidationError{
				field:  "PaginationMarker",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Number

	// no validation rules for Reverse

	if len(errors) > 0 {
		return ListFileRequestMultiError(errors)
	}

	return nil
}

// ListFileRequestMultiError is an error wrapping multiple validation errors
// returned by ListFileRequest.ValidateAll() if the designated constraints
// aren't met.
type ListFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListFileRequestMultiError) AllErrors() []error { return m }

// ListFileRequestValidationError is the validation error returned by
// ListFileRequest.Validate if the designated constraints aren't met.
type ListFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListFileRequestValidationError) ErrorName() string { return "ListFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListFileRequestValidationError{}

// Validate checks the field values on WalkFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *WalkFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalkFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalkFileRequestMultiError, or nil if none found.
func (m *WalkFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *WalkFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalkFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalkFileRequestValidationError{
					field:  "File",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalkFileRequestValidationError{
				field:  "File",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPaginationMarker()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalkFileRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalkFileRequestValidationError{
					field:  "PaginationMarker",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPaginationMarker()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalkFileRequestValidationError{
				field:  "PaginationMarker",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Number

	// no validation rules for Reverse

	if len(errors) > 0 {
		return WalkFileRequestMultiError(errors)
	}

	return nil
}

// WalkFileRequestMultiError is an error wrapping multiple validation errors
// returned by WalkFileRequest.ValidateAll() if the designated constraints
// aren't met.
type WalkFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalkFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalkFileRequestMultiError) AllErrors() []error { return m }

// WalkFileRequestValidationError is the validation error returned by
// WalkFileRequest.Validate if the designated constraints aren't met.
type WalkFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalkFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalkFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalkFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalkFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalkFileRequestValidationError) ErrorName() string { return "WalkFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e WalkFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalkFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalkFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalkFileRequestValidationError{}

// Validate checks the field values on GlobFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GlobFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GlobFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GlobFileRequestMultiError, or nil if none found.
func (m *GlobFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GlobFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobFileRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobFileRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobFileRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Pattern

	if all {
		switch v := interface{}(m.GetPathRange()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GlobFileRequestValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GlobFileRequestValidationError{
					field:  "PathRange",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPathRange()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GlobFileRequestValidationError{
				field:  "PathRange",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GlobFileRequestMultiError(errors)
	}

	return nil
}

// GlobFileRequestMultiError is an error wrapping multiple validation errors
// returned by GlobFileRequest.ValidateAll() if the designated constraints
// aren't met.
type GlobFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GlobFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GlobFileRequestMultiError) AllErrors() []error { return m }

// GlobFileRequestValidationError is the validation error returned by
// GlobFileRequest.Validate if the designated constraints aren't met.
type GlobFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GlobFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GlobFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GlobFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GlobFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GlobFileRequestValidationError) ErrorName() string { return "GlobFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e GlobFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGlobFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GlobFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GlobFileRequestValidationError{}

// Validate checks the field values on DiffFileRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiffFileRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiffFileRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiffFileRequestMultiError, or nil if none found.
func (m *DiffFileRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DiffFileRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNewFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiffFileRequestValidationError{
					field:  "NewFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiffFileRequestValidationError{
					field:  "NewFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiffFileRequestValidationError{
				field:  "NewFile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOldFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiffFileRequestValidationError{
					field:  "OldFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiffFileRequestValidationError{
					field:  "OldFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiffFileRequestValidationError{
				field:  "OldFile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Shallow

	if len(errors) > 0 {
		return DiffFileRequestMultiError(errors)
	}

	return nil
}

// DiffFileRequestMultiError is an error wrapping multiple validation errors
// returned by DiffFileRequest.ValidateAll() if the designated constraints
// aren't met.
type DiffFileRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiffFileRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiffFileRequestMultiError) AllErrors() []error { return m }

// DiffFileRequestValidationError is the validation error returned by
// DiffFileRequest.Validate if the designated constraints aren't met.
type DiffFileRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiffFileRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiffFileRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiffFileRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiffFileRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiffFileRequestValidationError) ErrorName() string { return "DiffFileRequestValidationError" }

// Error satisfies the builtin error interface
func (e DiffFileRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiffFileRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiffFileRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiffFileRequestValidationError{}

// Validate checks the field values on DiffFileResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DiffFileResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DiffFileResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DiffFileResponseMultiError, or nil if none found.
func (m *DiffFileResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *DiffFileResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetNewFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiffFileResponseValidationError{
					field:  "NewFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiffFileResponseValidationError{
					field:  "NewFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNewFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiffFileResponseValidationError{
				field:  "NewFile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOldFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DiffFileResponseValidationError{
					field:  "OldFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DiffFileResponseValidationError{
					field:  "OldFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOldFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DiffFileResponseValidationError{
				field:  "OldFile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return DiffFileResponseMultiError(errors)
	}

	return nil
}

// DiffFileResponseMultiError is an error wrapping multiple validation errors
// returned by DiffFileResponse.ValidateAll() if the designated constraints
// aren't met.
type DiffFileResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DiffFileResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DiffFileResponseMultiError) AllErrors() []error { return m }

// DiffFileResponseValidationError is the validation error returned by
// DiffFileResponse.Validate if the designated constraints aren't met.
type DiffFileResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DiffFileResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DiffFileResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DiffFileResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DiffFileResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DiffFileResponseValidationError) ErrorName() string { return "DiffFileResponseValidationError" }

// Error satisfies the builtin error interface
func (e DiffFileResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDiffFileResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DiffFileResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DiffFileResponseValidationError{}

// Validate checks the field values on FsckRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FsckRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FsckRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FsckRequestMultiError, or
// nil if none found.
func (m *FsckRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *FsckRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Fix

	switch v := m.ZombieCheck.(type) {
	case *FsckRequest_ZombieTarget:
		if v == nil {
			err := FsckRequestValidationError{
				field:  "ZombieCheck",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZombieTarget()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, FsckRequestValidationError{
						field:  "ZombieTarget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, FsckRequestValidationError{
						field:  "ZombieTarget",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZombieTarget()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return FsckRequestValidationError{
					field:  "ZombieTarget",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *FsckRequest_ZombieAll:
		if v == nil {
			err := FsckRequestValidationError{
				field:  "ZombieCheck",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ZombieAll
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return FsckRequestMultiError(errors)
	}

	return nil
}

// FsckRequestMultiError is an error wrapping multiple validation errors
// returned by FsckRequest.ValidateAll() if the designated constraints aren't met.
type FsckRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FsckRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FsckRequestMultiError) AllErrors() []error { return m }

// FsckRequestValidationError is the validation error returned by
// FsckRequest.Validate if the designated constraints aren't met.
type FsckRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FsckRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FsckRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FsckRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FsckRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FsckRequestValidationError) ErrorName() string { return "FsckRequestValidationError" }

// Error satisfies the builtin error interface
func (e FsckRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFsckRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FsckRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FsckRequestValidationError{}

// Validate checks the field values on FsckResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FsckResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FsckResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FsckResponseMultiError, or
// nil if none found.
func (m *FsckResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *FsckResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Fix

	// no validation rules for Error

	if len(errors) > 0 {
		return FsckResponseMultiError(errors)
	}

	return nil
}

// FsckResponseMultiError is an error wrapping multiple validation errors
// returned by FsckResponse.ValidateAll() if the designated constraints aren't met.
type FsckResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FsckResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FsckResponseMultiError) AllErrors() []error { return m }

// FsckResponseValidationError is the validation error returned by
// FsckResponse.Validate if the designated constraints aren't met.
type FsckResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FsckResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FsckResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FsckResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FsckResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FsckResponseValidationError) ErrorName() string { return "FsckResponseValidationError" }

// Error satisfies the builtin error interface
func (e FsckResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFsckResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FsckResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FsckResponseValidationError{}

// Validate checks the field values on CreateFileSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateFileSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateFileSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateFileSetResponseMultiError, or nil if none found.
func (m *CreateFileSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateFileSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	if len(errors) > 0 {
		return CreateFileSetResponseMultiError(errors)
	}

	return nil
}

// CreateFileSetResponseMultiError is an error wrapping multiple validation
// errors returned by CreateFileSetResponse.ValidateAll() if the designated
// constraints aren't met.
type CreateFileSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateFileSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateFileSetResponseMultiError) AllErrors() []error { return m }

// CreateFileSetResponseValidationError is the validation error returned by
// CreateFileSetResponse.Validate if the designated constraints aren't met.
type CreateFileSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateFileSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateFileSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateFileSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateFileSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateFileSetResponseValidationError) ErrorName() string {
	return "CreateFileSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateFileSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateFileSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateFileSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateFileSetResponseValidationError{}

// Validate checks the field values on GetFileSetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetFileSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetFileSetRequestMultiError, or nil if none found.
func (m *GetFileSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetFileSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetFileSetRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetFileSetRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetFileSetRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Type

	if len(errors) > 0 {
		return GetFileSetRequestMultiError(errors)
	}

	return nil
}

// GetFileSetRequestMultiError is an error wrapping multiple validation errors
// returned by GetFileSetRequest.ValidateAll() if the designated constraints
// aren't met.
type GetFileSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetFileSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetFileSetRequestMultiError) AllErrors() []error { return m }

// GetFileSetRequestValidationError is the validation error returned by
// GetFileSetRequest.Validate if the designated constraints aren't met.
type GetFileSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetFileSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetFileSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetFileSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetFileSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetFileSetRequestValidationError) ErrorName() string {
	return "GetFileSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetFileSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetFileSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetFileSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetFileSetRequestValidationError{}

// Validate checks the field values on AddFileSetRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddFileSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFileSetRequestMultiError, or nil if none found.
func (m *AddFileSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFileSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddFileSetRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddFileSetRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddFileSetRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FileSetId

	if len(errors) > 0 {
		return AddFileSetRequestMultiError(errors)
	}

	return nil
}

// AddFileSetRequestMultiError is an error wrapping multiple validation errors
// returned by AddFileSetRequest.ValidateAll() if the designated constraints
// aren't met.
type AddFileSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFileSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFileSetRequestMultiError) AllErrors() []error { return m }

// AddFileSetRequestValidationError is the validation error returned by
// AddFileSetRequest.Validate if the designated constraints aren't met.
type AddFileSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFileSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFileSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFileSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFileSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFileSetRequestValidationError) ErrorName() string {
	return "AddFileSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddFileSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFileSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFileSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFileSetRequestValidationError{}

// Validate checks the field values on RenewFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RenewFileSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenewFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RenewFileSetRequestMultiError, or nil if none found.
func (m *RenewFileSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RenewFileSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	// no validation rules for TtlSeconds

	if len(errors) > 0 {
		return RenewFileSetRequestMultiError(errors)
	}

	return nil
}

// RenewFileSetRequestMultiError is an error wrapping multiple validation
// errors returned by RenewFileSetRequest.ValidateAll() if the designated
// constraints aren't met.
type RenewFileSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenewFileSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenewFileSetRequestMultiError) AllErrors() []error { return m }

// RenewFileSetRequestValidationError is the validation error returned by
// RenewFileSetRequest.Validate if the designated constraints aren't met.
type RenewFileSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenewFileSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenewFileSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenewFileSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenewFileSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenewFileSetRequestValidationError) ErrorName() string {
	return "RenewFileSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RenewFileSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenewFileSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenewFileSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenewFileSetRequestValidationError{}

// Validate checks the field values on ComposeFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ComposeFileSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ComposeFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ComposeFileSetRequestMultiError, or nil if none found.
func (m *ComposeFileSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ComposeFileSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TtlSeconds

	// no validation rules for Compact

	if len(errors) > 0 {
		return ComposeFileSetRequestMultiError(errors)
	}

	return nil
}

// ComposeFileSetRequestMultiError is an error wrapping multiple validation
// errors returned by ComposeFileSetRequest.ValidateAll() if the designated
// constraints aren't met.
type ComposeFileSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ComposeFileSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ComposeFileSetRequestMultiError) AllErrors() []error { return m }

// ComposeFileSetRequestValidationError is the validation error returned by
// ComposeFileSetRequest.Validate if the designated constraints aren't met.
type ComposeFileSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ComposeFileSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ComposeFileSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ComposeFileSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ComposeFileSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ComposeFileSetRequestValidationError) ErrorName() string {
	return "ComposeFileSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ComposeFileSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sComposeFileSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ComposeFileSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ComposeFileSetRequestValidationError{}

// Validate checks the field values on ShardFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ShardFileSetRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShardFileSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShardFileSetRequestMultiError, or nil if none found.
func (m *ShardFileSetRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ShardFileSetRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	// no validation rules for NumFiles

	// no validation rules for SizeBytes

	if len(errors) > 0 {
		return ShardFileSetRequestMultiError(errors)
	}

	return nil
}

// ShardFileSetRequestMultiError is an error wrapping multiple validation
// errors returned by ShardFileSetRequest.ValidateAll() if the designated
// constraints aren't met.
type ShardFileSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShardFileSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShardFileSetRequestMultiError) AllErrors() []error { return m }

// ShardFileSetRequestValidationError is the validation error returned by
// ShardFileSetRequest.Validate if the designated constraints aren't met.
type ShardFileSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShardFileSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShardFileSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShardFileSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShardFileSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShardFileSetRequestValidationError) ErrorName() string {
	return "ShardFileSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ShardFileSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShardFileSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShardFileSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShardFileSetRequestValidationError{}

// Validate checks the field values on PathRange with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PathRange) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PathRange with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PathRangeMultiError, or nil
// if none found.
func (m *PathRange) ValidateAll() error {
	return m.validate(true)
}

func (m *PathRange) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Lower

	// no validation rules for Upper

	if len(errors) > 0 {
		return PathRangeMultiError(errors)
	}

	return nil
}

// PathRangeMultiError is an error wrapping multiple validation errors returned
// by PathRange.ValidateAll() if the designated constraints aren't met.
type PathRangeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PathRangeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PathRangeMultiError) AllErrors() []error { return m }

// PathRangeValidationError is the validation error returned by
// PathRange.Validate if the designated constraints aren't met.
type PathRangeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PathRangeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PathRangeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PathRangeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PathRangeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PathRangeValidationError) ErrorName() string { return "PathRangeValidationError" }

// Error satisfies the builtin error interface
func (e PathRangeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPathRange.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PathRangeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PathRangeValidationError{}

// Validate checks the field values on ShardFileSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ShardFileSetResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShardFileSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShardFileSetResponseMultiError, or nil if none found.
func (m *ShardFileSetResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ShardFileSetResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetShards() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ShardFileSetResponseValidationError{
						field:  fmt.Sprintf("Shards[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ShardFileSetResponseValidationError{
						field:  fmt.Sprintf("Shards[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ShardFileSetResponseValidationError{
					field:  fmt.Sprintf("Shards[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ShardFileSetResponseMultiError(errors)
	}

	return nil
}

// ShardFileSetResponseMultiError is an error wrapping multiple validation
// errors returned by ShardFileSetResponse.ValidateAll() if the designated
// constraints aren't met.
type ShardFileSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShardFileSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShardFileSetResponseMultiError) AllErrors() []error { return m }

// ShardFileSetResponseValidationError is the validation error returned by
// ShardFileSetResponse.Validate if the designated constraints aren't met.
type ShardFileSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShardFileSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShardFileSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShardFileSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShardFileSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShardFileSetResponseValidationError) ErrorName() string {
	return "ShardFileSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ShardFileSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShardFileSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShardFileSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShardFileSetResponseValidationError{}

// Validate checks the field values on CheckStorageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckStorageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckStorageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckStorageRequestMultiError, or nil if none found.
func (m *CheckStorageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckStorageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ReadChunkData

	// no validation rules for ChunkBegin

	// no validation rules for ChunkEnd

	if len(errors) > 0 {
		return CheckStorageRequestMultiError(errors)
	}

	return nil
}

// CheckStorageRequestMultiError is an error wrapping multiple validation
// errors returned by CheckStorageRequest.ValidateAll() if the designated
// constraints aren't met.
type CheckStorageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckStorageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckStorageRequestMultiError) AllErrors() []error { return m }

// CheckStorageRequestValidationError is the validation error returned by
// CheckStorageRequest.Validate if the designated constraints aren't met.
type CheckStorageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckStorageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckStorageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckStorageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckStorageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckStorageRequestValidationError) ErrorName() string {
	return "CheckStorageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CheckStorageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckStorageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckStorageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckStorageRequestValidationError{}

// Validate checks the field values on CheckStorageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CheckStorageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CheckStorageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CheckStorageResponseMultiError, or nil if none found.
func (m *CheckStorageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *CheckStorageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ChunkObjectCount

	if len(errors) > 0 {
		return CheckStorageResponseMultiError(errors)
	}

	return nil
}

// CheckStorageResponseMultiError is an error wrapping multiple validation
// errors returned by CheckStorageResponse.ValidateAll() if the designated
// constraints aren't met.
type CheckStorageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CheckStorageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CheckStorageResponseMultiError) AllErrors() []error { return m }

// CheckStorageResponseValidationError is the validation error returned by
// CheckStorageResponse.Validate if the designated constraints aren't met.
type CheckStorageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CheckStorageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CheckStorageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CheckStorageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CheckStorageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CheckStorageResponseValidationError) ErrorName() string {
	return "CheckStorageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CheckStorageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCheckStorageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CheckStorageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CheckStorageResponseValidationError{}

// Validate checks the field values on PutCacheRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutCacheRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutCacheRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutCacheRequestMultiError, or nil if none found.
func (m *PutCacheRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PutCacheRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutCacheRequestValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutCacheRequestValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutCacheRequestValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Tag

	if len(errors) > 0 {
		return PutCacheRequestMultiError(errors)
	}

	return nil
}

// PutCacheRequestMultiError is an error wrapping multiple validation errors
// returned by PutCacheRequest.ValidateAll() if the designated constraints
// aren't met.
type PutCacheRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutCacheRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutCacheRequestMultiError) AllErrors() []error { return m }

// PutCacheRequestValidationError is the validation error returned by
// PutCacheRequest.Validate if the designated constraints aren't met.
type PutCacheRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutCacheRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutCacheRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutCacheRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutCacheRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutCacheRequestValidationError) ErrorName() string { return "PutCacheRequestValidationError" }

// Error satisfies the builtin error interface
func (e PutCacheRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutCacheRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutCacheRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutCacheRequestValidationError{}

// Validate checks the field values on GetCacheRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCacheRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCacheRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCacheRequestMultiError, or nil if none found.
func (m *GetCacheRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCacheRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Key

	if len(errors) > 0 {
		return GetCacheRequestMultiError(errors)
	}

	return nil
}

// GetCacheRequestMultiError is an error wrapping multiple validation errors
// returned by GetCacheRequest.ValidateAll() if the designated constraints
// aren't met.
type GetCacheRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCacheRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCacheRequestMultiError) AllErrors() []error { return m }

// GetCacheRequestValidationError is the validation error returned by
// GetCacheRequest.Validate if the designated constraints aren't met.
type GetCacheRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCacheRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCacheRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCacheRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCacheRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCacheRequestValidationError) ErrorName() string { return "GetCacheRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetCacheRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCacheRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCacheRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCacheRequestValidationError{}

// Validate checks the field values on GetCacheResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetCacheResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetCacheResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetCacheResponseMultiError, or nil if none found.
func (m *GetCacheResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetCacheResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GetCacheResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GetCacheResponseValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GetCacheResponseValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GetCacheResponseMultiError(errors)
	}

	return nil
}

// GetCacheResponseMultiError is an error wrapping multiple validation errors
// returned by GetCacheResponse.ValidateAll() if the designated constraints
// aren't met.
type GetCacheResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetCacheResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetCacheResponseMultiError) AllErrors() []error { return m }

// GetCacheResponseValidationError is the validation error returned by
// GetCacheResponse.Validate if the designated constraints aren't met.
type GetCacheResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetCacheResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetCacheResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetCacheResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetCacheResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetCacheResponseValidationError) ErrorName() string { return "GetCacheResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetCacheResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetCacheResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetCacheResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetCacheResponseValidationError{}

// Validate checks the field values on ClearCacheRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ClearCacheRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClearCacheRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ClearCacheRequestMultiError, or nil if none found.
func (m *ClearCacheRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ClearCacheRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TagPrefix

	if len(errors) > 0 {
		return ClearCacheRequestMultiError(errors)
	}

	return nil
}

// ClearCacheRequestMultiError is an error wrapping multiple validation errors
// returned by ClearCacheRequest.ValidateAll() if the designated constraints
// aren't met.
type ClearCacheRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClearCacheRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClearCacheRequestMultiError) AllErrors() []error { return m }

// ClearCacheRequestValidationError is the validation error returned by
// ClearCacheRequest.Validate if the designated constraints aren't met.
type ClearCacheRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClearCacheRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClearCacheRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClearCacheRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClearCacheRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClearCacheRequestValidationError) ErrorName() string {
	return "ClearCacheRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ClearCacheRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClearCacheRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClearCacheRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClearCacheRequestValidationError{}

// Validate checks the field values on ActivateAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateAuthRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateAuthRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateAuthRequestMultiError, or nil if none found.
func (m *ActivateAuthRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateAuthRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ActivateAuthRequestMultiError(errors)
	}

	return nil
}

// ActivateAuthRequestMultiError is an error wrapping multiple validation
// errors returned by ActivateAuthRequest.ValidateAll() if the designated
// constraints aren't met.
type ActivateAuthRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateAuthRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateAuthRequestMultiError) AllErrors() []error { return m }

// ActivateAuthRequestValidationError is the validation error returned by
// ActivateAuthRequest.Validate if the designated constraints aren't met.
type ActivateAuthRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateAuthRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateAuthRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateAuthRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateAuthRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateAuthRequestValidationError) ErrorName() string {
	return "ActivateAuthRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateAuthRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateAuthRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateAuthRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateAuthRequestValidationError{}

// Validate checks the field values on ActivateAuthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActivateAuthResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActivateAuthResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActivateAuthResponseMultiError, or nil if none found.
func (m *ActivateAuthResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ActivateAuthResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ActivateAuthResponseMultiError(errors)
	}

	return nil
}

// ActivateAuthResponseMultiError is an error wrapping multiple validation
// errors returned by ActivateAuthResponse.ValidateAll() if the designated
// constraints aren't met.
type ActivateAuthResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActivateAuthResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActivateAuthResponseMultiError) AllErrors() []error { return m }

// ActivateAuthResponseValidationError is the validation error returned by
// ActivateAuthResponse.Validate if the designated constraints aren't met.
type ActivateAuthResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActivateAuthResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActivateAuthResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActivateAuthResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActivateAuthResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActivateAuthResponseValidationError) ErrorName() string {
	return "ActivateAuthResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ActivateAuthResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActivateAuthResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActivateAuthResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActivateAuthResponseValidationError{}

// Validate checks the field values on ObjectStorageEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ObjectStorageEgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ObjectStorageEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ObjectStorageEgressMultiError, or nil if none found.
func (m *ObjectStorageEgress) ValidateAll() error {
	return m.validate(true)
}

func (m *ObjectStorageEgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if len(errors) > 0 {
		return ObjectStorageEgressMultiError(errors)
	}

	return nil
}

// ObjectStorageEgressMultiError is an error wrapping multiple validation
// errors returned by ObjectStorageEgress.ValidateAll() if the designated
// constraints aren't met.
type ObjectStorageEgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectStorageEgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectStorageEgressMultiError) AllErrors() []error { return m }

// ObjectStorageEgressValidationError is the validation error returned by
// ObjectStorageEgress.Validate if the designated constraints aren't met.
type ObjectStorageEgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectStorageEgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectStorageEgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectStorageEgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectStorageEgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectStorageEgressValidationError) ErrorName() string {
	return "ObjectStorageEgressValidationError"
}

// Error satisfies the builtin error interface
func (e ObjectStorageEgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectStorageEgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectStorageEgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectStorageEgressValidationError{}

// Validate checks the field values on SQLDatabaseEgress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SQLDatabaseEgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SQLDatabaseEgress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SQLDatabaseEgressMultiError, or nil if none found.
func (m *SQLDatabaseEgress) ValidateAll() error {
	return m.validate(true)
}

func (m *SQLDatabaseEgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Url

	if all {
		switch v := interface{}(m.GetFileFormat()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SQLDatabaseEgressValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SQLDatabaseEgressValidationError{
					field:  "FileFormat",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileFormat()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SQLDatabaseEgressValidationError{
				field:  "FileFormat",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSecret()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SQLDatabaseEgressValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SQLDatabaseEgressValidationError{
					field:  "Secret",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSecret()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SQLDatabaseEgressValidationError{
				field:  "Secret",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SQLDatabaseEgressMultiError(errors)
	}

	return nil
}

// SQLDatabaseEgressMultiError is an error wrapping multiple validation errors
// returned by SQLDatabaseEgress.ValidateAll() if the designated constraints
// aren't met.
type SQLDatabaseEgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SQLDatabaseEgressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SQLDatabaseEgressMultiError) AllErrors() []error { return m }

// SQLDatabaseEgressValidationError is the validation error returned by
// SQLDatabaseEgress.Validate if the designated constraints aren't met.
type SQLDatabaseEgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SQLDatabaseEgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SQLDatabaseEgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SQLDatabaseEgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SQLDatabaseEgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SQLDatabaseEgressValidationError) ErrorName() string {
	return "SQLDatabaseEgressValidationError"
}

// Error satisfies the builtin error interface
func (e SQLDatabaseEgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSQLDatabaseEgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SQLDatabaseEgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SQLDatabaseEgressValidationError{}

// Validate checks the field values on EgressRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EgressRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EgressRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EgressRequestMultiError, or
// nil if none found.
func (m *EgressRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EgressRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EgressRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EgressRequestValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EgressRequestValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Target.(type) {
	case *EgressRequest_ObjectStorage:
		if v == nil {
			err := EgressRequestValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressRequestValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressRequestValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressRequest_SqlDatabase:
		if v == nil {
			err := EgressRequestValidationError{
				field:  "Target",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSqlDatabase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressRequestValidationError{
						field:  "SqlDatabase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressRequestValidationError{
						field:  "SqlDatabase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSqlDatabase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressRequestValidationError{
					field:  "SqlDatabase",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EgressRequestMultiError(errors)
	}

	return nil
}

// EgressRequestMultiError is an error wrapping multiple validation errors
// returned by EgressRequest.ValidateAll() if the designated constraints
// aren't met.
type EgressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EgressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EgressRequestMultiError) AllErrors() []error { return m }

// EgressRequestValidationError is the validation error returned by
// EgressRequest.Validate if the designated constraints aren't met.
type EgressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EgressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EgressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EgressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EgressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EgressRequestValidationError) ErrorName() string { return "EgressRequestValidationError" }

// Error satisfies the builtin error interface
func (e EgressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEgressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EgressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EgressRequestValidationError{}

// Validate checks the field values on EgressResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EgressResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EgressResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EgressResponseMultiError,
// or nil if none found.
func (m *EgressResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *EgressResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Result.(type) {
	case *EgressResponse_ObjectStorage:
		if v == nil {
			err := EgressResponseValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetObjectStorage()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressResponseValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressResponseValidationError{
						field:  "ObjectStorage",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetObjectStorage()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressResponseValidationError{
					field:  "ObjectStorage",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *EgressResponse_SqlDatabase:
		if v == nil {
			err := EgressResponseValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSqlDatabase()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EgressResponseValidationError{
						field:  "SqlDatabase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EgressResponseValidationError{
						field:  "SqlDatabase",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSqlDatabase()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EgressResponseValidationError{
					field:  "SqlDatabase",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return EgressResponseMultiError(errors)
	}

	return nil
}

// EgressResponseMultiError is an error wrapping multiple validation errors
// returned by EgressResponse.ValidateAll() if the designated constraints
// aren't met.
type EgressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EgressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EgressResponseMultiError) AllErrors() []error { return m }

// EgressResponseValidationError is the validation error returned by
// EgressResponse.Validate if the designated constraints aren't met.
type EgressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EgressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EgressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EgressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EgressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EgressResponseValidationError) ErrorName() string { return "EgressResponseValidationError" }

// Error satisfies the builtin error interface
func (e EgressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEgressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EgressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EgressResponseValidationError{}

// Validate checks the field values on RepoPicker_RepoName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RepoPicker_RepoName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoPicker_RepoName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoPicker_RepoNameMultiError, or nil if none found.
func (m *RepoPicker_RepoName) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoPicker_RepoName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetProject()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RepoPicker_RepoNameValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RepoPicker_RepoNameValidationError{
					field:  "Project",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProject()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RepoPicker_RepoNameValidationError{
				field:  "Project",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	// no validation rules for Type

	if len(errors) > 0 {
		return RepoPicker_RepoNameMultiError(errors)
	}

	return nil
}

// RepoPicker_RepoNameMultiError is an error wrapping multiple validation
// errors returned by RepoPicker_RepoName.ValidateAll() if the designated
// constraints aren't met.
type RepoPicker_RepoNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoPicker_RepoNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoPicker_RepoNameMultiError) AllErrors() []error { return m }

// RepoPicker_RepoNameValidationError is the validation error returned by
// RepoPicker_RepoName.Validate if the designated constraints aren't met.
type RepoPicker_RepoNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoPicker_RepoNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoPicker_RepoNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoPicker_RepoNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoPicker_RepoNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoPicker_RepoNameValidationError) ErrorName() string {
	return "RepoPicker_RepoNameValidationError"
}

// Error satisfies the builtin error interface
func (e RepoPicker_RepoNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoPicker_RepoName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoPicker_RepoNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoPicker_RepoNameValidationError{}

// Validate checks the field values on BranchPicker_BranchName with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BranchPicker_BranchName) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BranchPicker_BranchName with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BranchPicker_BranchNameMultiError, or nil if none found.
func (m *BranchPicker_BranchName) ValidateAll() error {
	return m.validate(true)
}

func (m *BranchPicker_BranchName) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BranchPicker_BranchNameValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BranchPicker_BranchNameValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BranchPicker_BranchNameValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Name

	if len(errors) > 0 {
		return BranchPicker_BranchNameMultiError(errors)
	}

	return nil
}

// BranchPicker_BranchNameMultiError is an error wrapping multiple validation
// errors returned by BranchPicker_BranchName.ValidateAll() if the designated
// constraints aren't met.
type BranchPicker_BranchNameMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BranchPicker_BranchNameMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BranchPicker_BranchNameMultiError) AllErrors() []error { return m }

// BranchPicker_BranchNameValidationError is the validation error returned by
// BranchPicker_BranchName.Validate if the designated constraints aren't met.
type BranchPicker_BranchNameValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BranchPicker_BranchNameValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BranchPicker_BranchNameValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BranchPicker_BranchNameValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BranchPicker_BranchNameValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BranchPicker_BranchNameValidationError) ErrorName() string {
	return "BranchPicker_BranchNameValidationError"
}

// Error satisfies the builtin error interface
func (e BranchPicker_BranchNameValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBranchPicker_BranchName.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BranchPicker_BranchNameValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BranchPicker_BranchNameValidationError{}

// Validate checks the field values on RepoInfo_Details with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RepoInfo_Details) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RepoInfo_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RepoInfo_DetailsMultiError, or nil if none found.
func (m *RepoInfo_Details) ValidateAll() error {
	return m.validate(true)
}

func (m *RepoInfo_Details) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SizeBytes

	if len(errors) > 0 {
		return RepoInfo_DetailsMultiError(errors)
	}

	return nil
}

// RepoInfo_DetailsMultiError is an error wrapping multiple validation errors
// returned by RepoInfo_Details.ValidateAll() if the designated constraints
// aren't met.
type RepoInfo_DetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RepoInfo_DetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RepoInfo_DetailsMultiError) AllErrors() []error { return m }

// RepoInfo_DetailsValidationError is the validation error returned by
// RepoInfo_Details.Validate if the designated constraints aren't met.
type RepoInfo_DetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RepoInfo_DetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RepoInfo_DetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RepoInfo_DetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RepoInfo_DetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RepoInfo_DetailsValidationError) ErrorName() string { return "RepoInfo_DetailsValidationError" }

// Error satisfies the builtin error interface
func (e RepoInfo_DetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRepoInfo_Details.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RepoInfo_DetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RepoInfo_DetailsValidationError{}

// Validate checks the field values on CommitPicker_CommitByGlobalId with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommitPicker_CommitByGlobalId) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitPicker_CommitByGlobalId with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CommitPicker_CommitByGlobalIdMultiError, or nil if none found.
func (m *CommitPicker_CommitByGlobalId) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitPicker_CommitByGlobalId) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRepo()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitPicker_CommitByGlobalIdValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitPicker_CommitByGlobalIdValidationError{
					field:  "Repo",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRepo()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitPicker_CommitByGlobalIdValidationError{
				field:  "Repo",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Id

	if len(errors) > 0 {
		return CommitPicker_CommitByGlobalIdMultiError(errors)
	}

	return nil
}

// CommitPicker_CommitByGlobalIdMultiError is an error wrapping multiple
// validation errors returned by CommitPicker_CommitByGlobalId.ValidateAll()
// if the designated constraints aren't met.
type CommitPicker_CommitByGlobalIdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitPicker_CommitByGlobalIdMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitPicker_CommitByGlobalIdMultiError) AllErrors() []error { return m }

// CommitPicker_CommitByGlobalIdValidationError is the validation error
// returned by CommitPicker_CommitByGlobalId.Validate if the designated
// constraints aren't met.
type CommitPicker_CommitByGlobalIdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitPicker_CommitByGlobalIdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitPicker_CommitByGlobalIdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitPicker_CommitByGlobalIdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitPicker_CommitByGlobalIdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitPicker_CommitByGlobalIdValidationError) ErrorName() string {
	return "CommitPicker_CommitByGlobalIdValidationError"
}

// Error satisfies the builtin error interface
func (e CommitPicker_CommitByGlobalIdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitPicker_CommitByGlobalId.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitPicker_CommitByGlobalIdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitPicker_CommitByGlobalIdValidationError{}

// Validate checks the field values on CommitPicker_BranchRoot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommitPicker_BranchRoot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitPicker_BranchRoot with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommitPicker_BranchRootMultiError, or nil if none found.
func (m *CommitPicker_BranchRoot) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitPicker_BranchRoot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Offset

	if all {
		switch v := interface{}(m.GetBranch()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitPicker_BranchRootValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitPicker_BranchRootValidationError{
					field:  "Branch",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBranch()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitPicker_BranchRootValidationError{
				field:  "Branch",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommitPicker_BranchRootMultiError(errors)
	}

	return nil
}

// CommitPicker_BranchRootMultiError is an error wrapping multiple validation
// errors returned by CommitPicker_BranchRoot.ValidateAll() if the designated
// constraints aren't met.
type CommitPicker_BranchRootMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitPicker_BranchRootMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitPicker_BranchRootMultiError) AllErrors() []error { return m }

// CommitPicker_BranchRootValidationError is the validation error returned by
// CommitPicker_BranchRoot.Validate if the designated constraints aren't met.
type CommitPicker_BranchRootValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitPicker_BranchRootValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitPicker_BranchRootValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitPicker_BranchRootValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitPicker_BranchRootValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitPicker_BranchRootValidationError) ErrorName() string {
	return "CommitPicker_BranchRootValidationError"
}

// Error satisfies the builtin error interface
func (e CommitPicker_BranchRootValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitPicker_BranchRoot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitPicker_BranchRootValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitPicker_BranchRootValidationError{}

// Validate checks the field values on CommitPicker_AncestorOf with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommitPicker_AncestorOf) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitPicker_AncestorOf with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommitPicker_AncestorOfMultiError, or nil if none found.
func (m *CommitPicker_AncestorOf) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitPicker_AncestorOf) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Offset

	if all {
		switch v := interface{}(m.GetStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitPicker_AncestorOfValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitPicker_AncestorOfValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitPicker_AncestorOfValidationError{
				field:  "Start",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommitPicker_AncestorOfMultiError(errors)
	}

	return nil
}

// CommitPicker_AncestorOfMultiError is an error wrapping multiple validation
// errors returned by CommitPicker_AncestorOf.ValidateAll() if the designated
// constraints aren't met.
type CommitPicker_AncestorOfMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitPicker_AncestorOfMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitPicker_AncestorOfMultiError) AllErrors() []error { return m }

// CommitPicker_AncestorOfValidationError is the validation error returned by
// CommitPicker_AncestorOf.Validate if the designated constraints aren't met.
type CommitPicker_AncestorOfValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitPicker_AncestorOfValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitPicker_AncestorOfValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitPicker_AncestorOfValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitPicker_AncestorOfValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitPicker_AncestorOfValidationError) ErrorName() string {
	return "CommitPicker_AncestorOfValidationError"
}

// Error satisfies the builtin error interface
func (e CommitPicker_AncestorOfValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitPicker_AncestorOf.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitPicker_AncestorOfValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitPicker_AncestorOfValidationError{}

// Validate checks the field values on CommitInfo_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CommitInfo_Details) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitInfo_Details with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CommitInfo_DetailsMultiError, or nil if none found.
func (m *CommitInfo_Details) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitInfo_Details) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SizeBytes

	if all {
		switch v := interface{}(m.GetCompactingTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfo_DetailsValidationError{
					field:  "CompactingTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfo_DetailsValidationError{
					field:  "CompactingTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCompactingTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfo_DetailsValidationError{
				field:  "CompactingTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetValidatingTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitInfo_DetailsValidationError{
					field:  "ValidatingTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitInfo_DetailsValidationError{
					field:  "ValidatingTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidatingTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitInfo_DetailsValidationError{
				field:  "ValidatingTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommitInfo_DetailsMultiError(errors)
	}

	return nil
}

// CommitInfo_DetailsMultiError is an error wrapping multiple validation errors
// returned by CommitInfo_Details.ValidateAll() if the designated constraints
// aren't met.
type CommitInfo_DetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitInfo_DetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitInfo_DetailsMultiError) AllErrors() []error { return m }

// CommitInfo_DetailsValidationError is the validation error returned by
// CommitInfo_Details.Validate if the designated constraints aren't met.
type CommitInfo_DetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitInfo_DetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitInfo_DetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitInfo_DetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitInfo_DetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitInfo_DetailsValidationError) ErrorName() string {
	return "CommitInfo_DetailsValidationError"
}

// Error satisfies the builtin error interface
func (e CommitInfo_DetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitInfo_Details.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitInfo_DetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitInfo_DetailsValidationError{}

// Validate checks the field values on AddFile_URLSource with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AddFile_URLSource) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddFile_URLSource with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddFile_URLSourceMultiError, or nil if none found.
func (m *AddFile_URLSource) ValidateAll() error {
	return m.validate(true)
}

func (m *AddFile_URLSource) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for URL

	// no validation rules for Recursive

	// no validation rules for Concurrency

	if len(errors) > 0 {
		return AddFile_URLSourceMultiError(errors)
	}

	return nil
}

// AddFile_URLSourceMultiError is an error wrapping multiple validation errors
// returned by AddFile_URLSource.ValidateAll() if the designated constraints
// aren't met.
type AddFile_URLSourceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddFile_URLSourceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddFile_URLSourceMultiError) AllErrors() []error { return m }

// AddFile_URLSourceValidationError is the validation error returned by
// AddFile_URLSource.Validate if the designated constraints aren't met.
type AddFile_URLSourceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddFile_URLSourceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddFile_URLSourceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddFile_URLSourceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddFile_URLSourceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddFile_URLSourceValidationError) ErrorName() string {
	return "AddFile_URLSourceValidationError"
}

// Error satisfies the builtin error interface
func (e AddFile_URLSourceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddFile_URLSource.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddFile_URLSourceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddFile_URLSourceValidationError{}

// Validate checks the field values on SQLDatabaseEgress_FileFormat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SQLDatabaseEgress_FileFormat) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SQLDatabaseEgress_FileFormat with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SQLDatabaseEgress_FileFormatMultiError, or nil if none found.
func (m *SQLDatabaseEgress_FileFormat) ValidateAll() error {
	return m.validate(true)
}

func (m *SQLDatabaseEgress_FileFormat) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	if len(errors) > 0 {
		return SQLDatabaseEgress_FileFormatMultiError(errors)
	}

	return nil
}

// SQLDatabaseEgress_FileFormatMultiError is an error wrapping multiple
// validation errors returned by SQLDatabaseEgress_FileFormat.ValidateAll() if
// the designated constraints aren't met.
type SQLDatabaseEgress_FileFormatMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SQLDatabaseEgress_FileFormatMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SQLDatabaseEgress_FileFormatMultiError) AllErrors() []error { return m }

// SQLDatabaseEgress_FileFormatValidationError is the validation error returned
// by SQLDatabaseEgress_FileFormat.Validate if the designated constraints
// aren't met.
type SQLDatabaseEgress_FileFormatValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SQLDatabaseEgress_FileFormatValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SQLDatabaseEgress_FileFormatValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SQLDatabaseEgress_FileFormatValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SQLDatabaseEgress_FileFormatValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SQLDatabaseEgress_FileFormatValidationError) ErrorName() string {
	return "SQLDatabaseEgress_FileFormatValidationError"
}

// Error satisfies the builtin error interface
func (e SQLDatabaseEgress_FileFormatValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSQLDatabaseEgress_FileFormat.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SQLDatabaseEgress_FileFormatValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SQLDatabaseEgress_FileFormatValidationError{}

// Validate checks the field values on SQLDatabaseEgress_Secret with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SQLDatabaseEgress_Secret) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SQLDatabaseEgress_Secret with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SQLDatabaseEgress_SecretMultiError, or nil if none found.
func (m *SQLDatabaseEgress_Secret) ValidateAll() error {
	return m.validate(true)
}

func (m *SQLDatabaseEgress_Secret) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Key

	if len(errors) > 0 {
		return SQLDatabaseEgress_SecretMultiError(errors)
	}

	return nil
}

// SQLDatabaseEgress_SecretMultiError is an error wrapping multiple validation
// errors returned by SQLDatabaseEgress_Secret.ValidateAll() if the designated
// constraints aren't met.
type SQLDatabaseEgress_SecretMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SQLDatabaseEgress_SecretMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SQLDatabaseEgress_SecretMultiError) AllErrors() []error { return m }

// SQLDatabaseEgress_SecretValidationError is the validation error returned by
// SQLDatabaseEgress_Secret.Validate if the designated constraints aren't met.
type SQLDatabaseEgress_SecretValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SQLDatabaseEgress_SecretValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SQLDatabaseEgress_SecretValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SQLDatabaseEgress_SecretValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SQLDatabaseEgress_SecretValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SQLDatabaseEgress_SecretValidationError) ErrorName() string {
	return "SQLDatabaseEgress_SecretValidationError"
}

// Error satisfies the builtin error interface
func (e SQLDatabaseEgress_SecretValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSQLDatabaseEgress_Secret.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SQLDatabaseEgress_SecretValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SQLDatabaseEgress_SecretValidationError{}

// Validate checks the field values on EgressResponse_ObjectStorageResult with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *EgressResponse_ObjectStorageResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EgressResponse_ObjectStorageResult
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// EgressResponse_ObjectStorageResultMultiError, or nil if none found.
func (m *EgressResponse_ObjectStorageResult) ValidateAll() error {
	return m.validate(true)
}

func (m *EgressResponse_ObjectStorageResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for BytesWritten

	if len(errors) > 0 {
		return EgressResponse_ObjectStorageResultMultiError(errors)
	}

	return nil
}

// EgressResponse_ObjectStorageResultMultiError is an error wrapping multiple
// validation errors returned by
// EgressResponse_ObjectStorageResult.ValidateAll() if the designated
// constraints aren't met.
type EgressResponse_ObjectStorageResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EgressResponse_ObjectStorageResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EgressResponse_ObjectStorageResultMultiError) AllErrors() []error { return m }

// EgressResponse_ObjectStorageResultValidationError is the validation error
// returned by EgressResponse_ObjectStorageResult.Validate if the designated
// constraints aren't met.
type EgressResponse_ObjectStorageResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EgressResponse_ObjectStorageResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EgressResponse_ObjectStorageResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EgressResponse_ObjectStorageResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EgressResponse_ObjectStorageResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EgressResponse_ObjectStorageResultValidationError) ErrorName() string {
	return "EgressResponse_ObjectStorageResultValidationError"
}

// Error satisfies the builtin error interface
func (e EgressResponse_ObjectStorageResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEgressResponse_ObjectStorageResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EgressResponse_ObjectStorageResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EgressResponse_ObjectStorageResultValidationError{}

// Validate checks the field values on EgressResponse_SQLDatabaseResult with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *EgressResponse_SQLDatabaseResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EgressResponse_SQLDatabaseResult with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// EgressResponse_SQLDatabaseResultMultiError, or nil if none found.
func (m *EgressResponse_SQLDatabaseResult) ValidateAll() error {
	return m.validate(true)
}

func (m *EgressResponse_SQLDatabaseResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RowsWritten

	if len(errors) > 0 {
		return EgressResponse_SQLDatabaseResultMultiError(errors)
	}

	return nil
}

// EgressResponse_SQLDatabaseResultMultiError is an error wrapping multiple
// validation errors returned by
// EgressResponse_SQLDatabaseResult.ValidateAll() if the designated
// constraints aren't met.
type EgressResponse_SQLDatabaseResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EgressResponse_SQLDatabaseResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EgressResponse_SQLDatabaseResultMultiError) AllErrors() []error { return m }

// EgressResponse_SQLDatabaseResultValidationError is the validation error
// returned by EgressResponse_SQLDatabaseResult.Validate if the designated
// constraints aren't met.
type EgressResponse_SQLDatabaseResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EgressResponse_SQLDatabaseResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EgressResponse_SQLDatabaseResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EgressResponse_SQLDatabaseResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EgressResponse_SQLDatabaseResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EgressResponse_SQLDatabaseResultValidationError) ErrorName() string {
	return "EgressResponse_SQLDatabaseResultValidationError"
}

// Error satisfies the builtin error interface
func (e EgressResponse_SQLDatabaseResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEgressResponse_SQLDatabaseResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EgressResponse_SQLDatabaseResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EgressResponse_SQLDatabaseResultValidationError{}
