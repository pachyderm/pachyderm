// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pfs/pfs.proto

package pfs

import (
	context "context"
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	auth "github.com/pachyderm/pachyderm/v2/src/auth"
	task "github.com/pachyderm/pachyderm/v2/src/task"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// These are the different places where a commit may be originated from
type OriginKind int32

const (
	OriginKind_ORIGIN_KIND_UNKNOWN OriginKind = 0
	OriginKind_USER                OriginKind = 1
	OriginKind_AUTO                OriginKind = 2
	OriginKind_FSCK                OriginKind = 3
)

var OriginKind_name = map[int32]string{
	0: "ORIGIN_KIND_UNKNOWN",
	1: "USER",
	2: "AUTO",
	3: "FSCK",
}

var OriginKind_value = map[string]int32{
	"ORIGIN_KIND_UNKNOWN": 0,
	"USER":                1,
	"AUTO":                2,
	"FSCK":                3,
}

func (x OriginKind) String() string {
	return proto.EnumName(OriginKind_name, int32(x))
}

func (OriginKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{0}
}

type FileType int32

const (
	FileType_RESERVED FileType = 0
	FileType_FILE     FileType = 1
	FileType_DIR      FileType = 2
)

var FileType_name = map[int32]string{
	0: "RESERVED",
	1: "FILE",
	2: "DIR",
}

var FileType_value = map[string]int32{
	"RESERVED": 0,
	"FILE":     1,
	"DIR":      2,
}

func (x FileType) String() string {
	return proto.EnumName(FileType_name, int32(x))
}

func (FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{1}
}

// CommitState describes the states a commit can be in.
// The states are increasingly specific, i.e. a commit that is FINISHED also counts as STARTED.
type CommitState int32

const (
	CommitState_COMMIT_STATE_UNKNOWN CommitState = 0
	CommitState_STARTED              CommitState = 1
	CommitState_READY                CommitState = 2
	CommitState_FINISHING            CommitState = 3
	CommitState_FINISHED             CommitState = 4
)

var CommitState_name = map[int32]string{
	0: "COMMIT_STATE_UNKNOWN",
	1: "STARTED",
	2: "READY",
	3: "FINISHING",
	4: "FINISHED",
}

var CommitState_value = map[string]int32{
	"COMMIT_STATE_UNKNOWN": 0,
	"STARTED":              1,
	"READY":                2,
	"FINISHING":            3,
	"FINISHED":             4,
}

func (x CommitState) String() string {
	return proto.EnumName(CommitState_name, int32(x))
}

func (CommitState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{2}
}

type Delimiter int32

const (
	Delimiter_NONE Delimiter = 0
	Delimiter_JSON Delimiter = 1
	Delimiter_LINE Delimiter = 2
	Delimiter_SQL  Delimiter = 3
	Delimiter_CSV  Delimiter = 4
)

var Delimiter_name = map[int32]string{
	0: "NONE",
	1: "JSON",
	2: "LINE",
	3: "SQL",
	4: "CSV",
}

var Delimiter_value = map[string]int32{
	"NONE": 0,
	"JSON": 1,
	"LINE": 2,
	"SQL":  3,
	"CSV":  4,
}

func (x Delimiter) String() string {
	return proto.EnumName(Delimiter_name, int32(x))
}

func (Delimiter) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{3}
}

type SQLDatabaseEgress_FileFormat_Type int32

const (
	SQLDatabaseEgress_FileFormat_UNKNOWN SQLDatabaseEgress_FileFormat_Type = 0
	SQLDatabaseEgress_FileFormat_CSV     SQLDatabaseEgress_FileFormat_Type = 1
	SQLDatabaseEgress_FileFormat_JSON    SQLDatabaseEgress_FileFormat_Type = 2
	SQLDatabaseEgress_FileFormat_PARQUET SQLDatabaseEgress_FileFormat_Type = 3
)

var SQLDatabaseEgress_FileFormat_Type_name = map[int32]string{
	0: "UNKNOWN",
	1: "CSV",
	2: "JSON",
	3: "PARQUET",
}

var SQLDatabaseEgress_FileFormat_Type_value = map[string]int32{
	"UNKNOWN": 0,
	"CSV":     1,
	"JSON":    2,
	"PARQUET": 3,
}

func (x SQLDatabaseEgress_FileFormat_Type) String() string {
	return proto.EnumName(SQLDatabaseEgress_FileFormat_Type_name, int32(x))
}

func (SQLDatabaseEgress_FileFormat_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{73, 0, 0}
}

type Repo struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Type                 string   `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	Project              *Project `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Repo) Reset()                      { *m = Repo{} }
func (m *Repo) autogeneratedString() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()                 {}
func (*Repo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{0}
}
func (m *Repo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Repo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Repo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Repo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Repo.Merge(m, src)
}
func (m *Repo) XXX_Size() int {
	return m.Size()
}
func (m *Repo) XXX_DiscardUnknown() {
	xxx_messageInfo_Repo.DiscardUnknown(m)
}

var xxx_messageInfo_Repo proto.InternalMessageInfo

func (m *Repo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Repo) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Repo) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

type Branch struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Branch) Reset()                      { *m = Branch{} }
func (m *Branch) autogeneratedString() string { return proto.CompactTextString(m) }
func (*Branch) ProtoMessage()                 {}
func (*Branch) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{1}
}
func (m *Branch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Branch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Branch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Branch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Branch.Merge(m, src)
}
func (m *Branch) XXX_Size() int {
	return m.Size()
}
func (m *Branch) XXX_DiscardUnknown() {
	xxx_messageInfo_Branch.DiscardUnknown(m)
}

var xxx_messageInfo_Branch proto.InternalMessageInfo

func (m *Branch) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Branch) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type File struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Path                 string   `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
	Datum                string   `protobuf:"bytes,3,opt,name=datum,proto3" json:"datum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{2}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (m *File) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *File) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *File) GetDatum() string {
	if m != nil {
		return m.Datum
	}
	return ""
}

// RepoInfo is the main data structure representing a Repo in etcd
type RepoInfo struct {
	Repo                *Repo            `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Created             *types.Timestamp `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	SizeBytesUpperBound int64            `protobuf:"varint,3,opt,name=size_bytes_upper_bound,json=sizeBytesUpperBound,proto3" json:"size_bytes_upper_bound,omitempty"`
	Description         string           `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	Branches            []*Branch        `protobuf:"bytes,5,rep,name=branches,proto3" json:"branches,omitempty"`
	// Set by ListRepo and InspectRepo if Pachyderm's auth system is active, but
	// not stored in etcd. To set a user's auth scope for a repo, use the
	// Pachyderm Auth API (in src/client/auth/auth.proto)
	AuthInfo             *AuthInfo         `protobuf:"bytes,6,opt,name=auth_info,json=authInfo,proto3" json:"auth_info,omitempty"`
	Details              *RepoInfo_Details `protobuf:"bytes,7,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *RepoInfo) Reset()         { *m = RepoInfo{} }
func (m *RepoInfo) String() string { return proto.CompactTextString(m) }
func (*RepoInfo) ProtoMessage()    {}
func (*RepoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{3}
}
func (m *RepoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoInfo.Merge(m, src)
}
func (m *RepoInfo) XXX_Size() int {
	return m.Size()
}
func (m *RepoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_RepoInfo proto.InternalMessageInfo

func (m *RepoInfo) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *RepoInfo) GetCreated() *types.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *RepoInfo) GetSizeBytesUpperBound() int64 {
	if m != nil {
		return m.SizeBytesUpperBound
	}
	return 0
}

func (m *RepoInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *RepoInfo) GetBranches() []*Branch {
	if m != nil {
		return m.Branches
	}
	return nil
}

func (m *RepoInfo) GetAuthInfo() *AuthInfo {
	if m != nil {
		return m.AuthInfo
	}
	return nil
}

func (m *RepoInfo) GetDetails() *RepoInfo_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

// Details are only provided when explicitly requested
type RepoInfo_Details struct {
	SizeBytes            int64    `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RepoInfo_Details) Reset()         { *m = RepoInfo_Details{} }
func (m *RepoInfo_Details) String() string { return proto.CompactTextString(m) }
func (*RepoInfo_Details) ProtoMessage()    {}
func (*RepoInfo_Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{3, 0}
}
func (m *RepoInfo_Details) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RepoInfo_Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RepoInfo_Details.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RepoInfo_Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RepoInfo_Details.Merge(m, src)
}
func (m *RepoInfo_Details) XXX_Size() int {
	return m.Size()
}
func (m *RepoInfo_Details) XXX_DiscardUnknown() {
	xxx_messageInfo_RepoInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_RepoInfo_Details proto.InternalMessageInfo

func (m *RepoInfo_Details) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// AuthInfo includes the caller's access scope for a resource, and is returned
// by services like ListRepo, InspectRepo, and ListProject, but is not persisted in the database.
// It's used by the Pachyderm dashboard to render repo access appropriately.
// To set a user's auth scope for a resource, use the Pachyderm Auth API (in src/auth/auth.proto)
type AuthInfo struct {
	// The callers access level to the relevant resource. These are very granular
	// permissions - for the end user it makes sense to show them the roles
	// they have instead.
	Permissions []auth.Permission `protobuf:"varint,1,rep,packed,name=permissions,proto3,enum=auth_v2.Permission" json:"permissions,omitempty"`
	// The caller's roles on the relevant resource. This includes inherited
	// roles from the cluster, project, group membership, etc.
	Roles                []string `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthInfo) Reset()         { *m = AuthInfo{} }
func (m *AuthInfo) String() string { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()    {}
func (*AuthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{4}
}
func (m *AuthInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInfo.Merge(m, src)
}
func (m *AuthInfo) XXX_Size() int {
	return m.Size()
}
func (m *AuthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInfo proto.InternalMessageInfo

func (m *AuthInfo) GetPermissions() []auth.Permission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *AuthInfo) GetRoles() []string {
	if m != nil {
		return m.Roles
	}
	return nil
}

type BranchInfo struct {
	Branch               *Branch   `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	Head                 *Commit   `protobuf:"bytes,2,opt,name=head,proto3" json:"head,omitempty"`
	Provenance           []*Branch `protobuf:"bytes,3,rep,name=provenance,proto3" json:"provenance,omitempty"`
	Subvenance           []*Branch `protobuf:"bytes,4,rep,name=subvenance,proto3" json:"subvenance,omitempty"`
	DirectProvenance     []*Branch `protobuf:"bytes,5,rep,name=direct_provenance,json=directProvenance,proto3" json:"direct_provenance,omitempty"`
	Trigger              *Trigger  `protobuf:"bytes,6,opt,name=trigger,proto3" json:"trigger,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *BranchInfo) Reset()         { *m = BranchInfo{} }
func (m *BranchInfo) String() string { return proto.CompactTextString(m) }
func (*BranchInfo) ProtoMessage()    {}
func (*BranchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{5}
}
func (m *BranchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BranchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BranchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BranchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BranchInfo.Merge(m, src)
}
func (m *BranchInfo) XXX_Size() int {
	return m.Size()
}
func (m *BranchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BranchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BranchInfo proto.InternalMessageInfo

func (m *BranchInfo) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *BranchInfo) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *BranchInfo) GetProvenance() []*Branch {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *BranchInfo) GetSubvenance() []*Branch {
	if m != nil {
		return m.Subvenance
	}
	return nil
}

func (m *BranchInfo) GetDirectProvenance() []*Branch {
	if m != nil {
		return m.DirectProvenance
	}
	return nil
}

func (m *BranchInfo) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

// Trigger defines the conditions under which a head is moved, and to which
// branch it is moved.
type Trigger struct {
	// Which branch this trigger refers to
	Branch string `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	// All indicates that all conditions must be satisfied before the trigger
	// happens, otherwise any conditions being satisfied will trigger it.
	All bool `protobuf:"varint,2,opt,name=all,proto3" json:"all,omitempty"`
	// Triggers if the cron spec has been satisfied since the last trigger and
	// there's been a new commit.
	CronSpec string `protobuf:"bytes,3,opt,name=cron_spec,json=cronSpec,proto3" json:"cron_spec,omitempty"`
	// Triggers if there's been `size` new data added since the last trigger.
	Size_ string `protobuf:"bytes,4,opt,name=size,proto3" json:"size,omitempty"`
	// Triggers if there's been `commits` new commits added since the last trigger.
	Commits              int64    `protobuf:"varint,5,opt,name=commits,proto3" json:"commits,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Trigger) Reset()         { *m = Trigger{} }
func (m *Trigger) String() string { return proto.CompactTextString(m) }
func (*Trigger) ProtoMessage()    {}
func (*Trigger) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{6}
}
func (m *Trigger) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Trigger) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Trigger.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Trigger) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Trigger.Merge(m, src)
}
func (m *Trigger) XXX_Size() int {
	return m.Size()
}
func (m *Trigger) XXX_DiscardUnknown() {
	xxx_messageInfo_Trigger.DiscardUnknown(m)
}

var xxx_messageInfo_Trigger proto.InternalMessageInfo

func (m *Trigger) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *Trigger) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *Trigger) GetCronSpec() string {
	if m != nil {
		return m.CronSpec
	}
	return ""
}

func (m *Trigger) GetSize_() string {
	if m != nil {
		return m.Size_
	}
	return ""
}

func (m *Trigger) GetCommits() int64 {
	if m != nil {
		return m.Commits
	}
	return 0
}

type CommitOrigin struct {
	Kind                 OriginKind `protobuf:"varint,1,opt,name=kind,proto3,enum=pfs_v2.OriginKind" json:"kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CommitOrigin) Reset()         { *m = CommitOrigin{} }
func (m *CommitOrigin) String() string { return proto.CompactTextString(m) }
func (*CommitOrigin) ProtoMessage()    {}
func (*CommitOrigin) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{7}
}
func (m *CommitOrigin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitOrigin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitOrigin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitOrigin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitOrigin.Merge(m, src)
}
func (m *CommitOrigin) XXX_Size() int {
	return m.Size()
}
func (m *CommitOrigin) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitOrigin.DiscardUnknown(m)
}

var xxx_messageInfo_CommitOrigin proto.InternalMessageInfo

func (m *CommitOrigin) GetKind() OriginKind {
	if m != nil {
		return m.Kind
	}
	return OriginKind_ORIGIN_KIND_UNKNOWN
}

// Commit is a reference to a commit (e.g. the collection of branches and the
// collection of currently-open commits in etcd are collections of Commit
// protos)
type Commit struct {
	Repo *Repo  `protobuf:"bytes,3,opt,name=repo,proto3" json:"repo,omitempty"`
	Id   string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// only used by the client
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Commit) Reset()                      { *m = Commit{} }
func (m *Commit) autogeneratedString() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()                 {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{8}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

func (m *Commit) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *Commit) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Commit) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

// CommitInfo is the main data structure representing a commit in etcd
type CommitInfo struct {
	Commit *Commit       `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Origin *CommitOrigin `protobuf:"bytes,2,opt,name=origin,proto3" json:"origin,omitempty"`
	// description is a user-provided script describing this commit
	Description          string              `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	ParentCommit         *Commit             `protobuf:"bytes,4,opt,name=parent_commit,json=parentCommit,proto3" json:"parent_commit,omitempty"`
	ChildCommits         []*Commit           `protobuf:"bytes,5,rep,name=child_commits,json=childCommits,proto3" json:"child_commits,omitempty"`
	Started              *types.Timestamp    `protobuf:"bytes,6,opt,name=started,proto3" json:"started,omitempty"`
	Finishing            *types.Timestamp    `protobuf:"bytes,7,opt,name=finishing,proto3" json:"finishing,omitempty"`
	Finished             *types.Timestamp    `protobuf:"bytes,8,opt,name=finished,proto3" json:"finished,omitempty"`
	DirectProvenance     []*Commit           `protobuf:"bytes,13,rep,name=direct_provenance,json=directProvenance,proto3" json:"direct_provenance,omitempty"`
	Error                string              `protobuf:"bytes,10,opt,name=error,proto3" json:"error,omitempty"`
	SizeBytesUpperBound  int64               `protobuf:"varint,11,opt,name=size_bytes_upper_bound,json=sizeBytesUpperBound,proto3" json:"size_bytes_upper_bound,omitempty"`
	Details              *CommitInfo_Details `protobuf:"bytes,12,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CommitInfo) Reset()         { *m = CommitInfo{} }
func (m *CommitInfo) String() string { return proto.CompactTextString(m) }
func (*CommitInfo) ProtoMessage()    {}
func (*CommitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{9}
}
func (m *CommitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfo.Merge(m, src)
}
func (m *CommitInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfo proto.InternalMessageInfo

func (m *CommitInfo) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *CommitInfo) GetOrigin() *CommitOrigin {
	if m != nil {
		return m.Origin
	}
	return nil
}

func (m *CommitInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CommitInfo) GetParentCommit() *Commit {
	if m != nil {
		return m.ParentCommit
	}
	return nil
}

func (m *CommitInfo) GetChildCommits() []*Commit {
	if m != nil {
		return m.ChildCommits
	}
	return nil
}

func (m *CommitInfo) GetStarted() *types.Timestamp {
	if m != nil {
		return m.Started
	}
	return nil
}

func (m *CommitInfo) GetFinishing() *types.Timestamp {
	if m != nil {
		return m.Finishing
	}
	return nil
}

func (m *CommitInfo) GetFinished() *types.Timestamp {
	if m != nil {
		return m.Finished
	}
	return nil
}

func (m *CommitInfo) GetDirectProvenance() []*Commit {
	if m != nil {
		return m.DirectProvenance
	}
	return nil
}

func (m *CommitInfo) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *CommitInfo) GetSizeBytesUpperBound() int64 {
	if m != nil {
		return m.SizeBytesUpperBound
	}
	return 0
}

func (m *CommitInfo) GetDetails() *CommitInfo_Details {
	if m != nil {
		return m.Details
	}
	return nil
}

// Details are only provided when explicitly requested
type CommitInfo_Details struct {
	SizeBytes            int64           `protobuf:"varint,1,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	CompactingTime       *types.Duration `protobuf:"bytes,2,opt,name=compacting_time,json=compactingTime,proto3" json:"compacting_time,omitempty"`
	ValidatingTime       *types.Duration `protobuf:"bytes,3,opt,name=validating_time,json=validatingTime,proto3" json:"validating_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CommitInfo_Details) Reset()         { *m = CommitInfo_Details{} }
func (m *CommitInfo_Details) String() string { return proto.CompactTextString(m) }
func (*CommitInfo_Details) ProtoMessage()    {}
func (*CommitInfo_Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{9, 0}
}
func (m *CommitInfo_Details) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitInfo_Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitInfo_Details.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitInfo_Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitInfo_Details.Merge(m, src)
}
func (m *CommitInfo_Details) XXX_Size() int {
	return m.Size()
}
func (m *CommitInfo_Details) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_CommitInfo_Details proto.InternalMessageInfo

func (m *CommitInfo_Details) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *CommitInfo_Details) GetCompactingTime() *types.Duration {
	if m != nil {
		return m.CompactingTime
	}
	return nil
}

func (m *CommitInfo_Details) GetValidatingTime() *types.Duration {
	if m != nil {
		return m.ValidatingTime
	}
	return nil
}

type CommitSet struct {
	Id                   string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitSet) Reset()         { *m = CommitSet{} }
func (m *CommitSet) String() string { return proto.CompactTextString(m) }
func (*CommitSet) ProtoMessage()    {}
func (*CommitSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{10}
}
func (m *CommitSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitSet.Merge(m, src)
}
func (m *CommitSet) XXX_Size() int {
	return m.Size()
}
func (m *CommitSet) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitSet.DiscardUnknown(m)
}

var xxx_messageInfo_CommitSet proto.InternalMessageInfo

func (m *CommitSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type CommitSetInfo struct {
	CommitSet            *CommitSet    `protobuf:"bytes,1,opt,name=commit_set,json=commitSet,proto3" json:"commit_set,omitempty"`
	Commits              []*CommitInfo `protobuf:"bytes,2,rep,name=commits,proto3" json:"commits,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CommitSetInfo) Reset()         { *m = CommitSetInfo{} }
func (m *CommitSetInfo) String() string { return proto.CompactTextString(m) }
func (*CommitSetInfo) ProtoMessage()    {}
func (*CommitSetInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{11}
}
func (m *CommitSetInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitSetInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitSetInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitSetInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitSetInfo.Merge(m, src)
}
func (m *CommitSetInfo) XXX_Size() int {
	return m.Size()
}
func (m *CommitSetInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitSetInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CommitSetInfo proto.InternalMessageInfo

func (m *CommitSetInfo) GetCommitSet() *CommitSet {
	if m != nil {
		return m.CommitSet
	}
	return nil
}

func (m *CommitSetInfo) GetCommits() []*CommitInfo {
	if m != nil {
		return m.Commits
	}
	return nil
}

type FileInfo struct {
	File                 *File            `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	FileType             FileType         `protobuf:"varint,2,opt,name=file_type,json=fileType,proto3,enum=pfs_v2.FileType" json:"file_type,omitempty"`
	Committed            *types.Timestamp `protobuf:"bytes,3,opt,name=committed,proto3" json:"committed,omitempty"`
	SizeBytes            int64            `protobuf:"varint,4,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty"`
	Hash                 []byte           `protobuf:"bytes,5,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *FileInfo) Reset()         { *m = FileInfo{} }
func (m *FileInfo) String() string { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()    {}
func (*FileInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{12}
}
func (m *FileInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileInfo.Merge(m, src)
}
func (m *FileInfo) XXX_Size() int {
	return m.Size()
}
func (m *FileInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FileInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FileInfo proto.InternalMessageInfo

func (m *FileInfo) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileInfo) GetFileType() FileType {
	if m != nil {
		return m.FileType
	}
	return FileType_RESERVED
}

func (m *FileInfo) GetCommitted() *types.Timestamp {
	if m != nil {
		return m.Committed
	}
	return nil
}

func (m *FileInfo) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *FileInfo) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Project struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Project) Reset()                      { *m = Project{} }
func (m *Project) autogeneratedString() string { return proto.CompactTextString(m) }
func (*Project) ProtoMessage()                 {}
func (*Project) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{13}
}
func (m *Project) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Project) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Project.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Project) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Project.Merge(m, src)
}
func (m *Project) XXX_Size() int {
	return m.Size()
}
func (m *Project) XXX_DiscardUnknown() {
	xxx_messageInfo_Project.DiscardUnknown(m)
}

var xxx_messageInfo_Project proto.InternalMessageInfo

func (m *Project) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ProjectInfo struct {
	Project              *Project         `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Description          string           `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	AuthInfo             *AuthInfo        `protobuf:"bytes,3,opt,name=auth_info,json=authInfo,proto3" json:"auth_info,omitempty"`
	CreatedAt            *types.Timestamp `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ProjectInfo) Reset()         { *m = ProjectInfo{} }
func (m *ProjectInfo) String() string { return proto.CompactTextString(m) }
func (*ProjectInfo) ProtoMessage()    {}
func (*ProjectInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{14}
}
func (m *ProjectInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProjectInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProjectInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProjectInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProjectInfo.Merge(m, src)
}
func (m *ProjectInfo) XXX_Size() int {
	return m.Size()
}
func (m *ProjectInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ProjectInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ProjectInfo proto.InternalMessageInfo

func (m *ProjectInfo) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

func (m *ProjectInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ProjectInfo) GetAuthInfo() *AuthInfo {
	if m != nil {
		return m.AuthInfo
	}
	return nil
}

func (m *ProjectInfo) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

type CreateRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Update               bool     `protobuf:"varint,3,opt,name=update,proto3" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateRepoRequest) Reset()         { *m = CreateRepoRequest{} }
func (m *CreateRepoRequest) String() string { return proto.CompactTextString(m) }
func (*CreateRepoRequest) ProtoMessage()    {}
func (*CreateRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{15}
}
func (m *CreateRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateRepoRequest.Merge(m, src)
}
func (m *CreateRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateRepoRequest proto.InternalMessageInfo

func (m *CreateRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *CreateRepoRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateRepoRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

type InspectRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectRepoRequest) Reset()         { *m = InspectRepoRequest{} }
func (m *InspectRepoRequest) String() string { return proto.CompactTextString(m) }
func (*InspectRepoRequest) ProtoMessage()    {}
func (*InspectRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{16}
}
func (m *InspectRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectRepoRequest.Merge(m, src)
}
func (m *InspectRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectRepoRequest proto.InternalMessageInfo

func (m *InspectRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

type ListRepoRequest struct {
	// type is the type of (system) repos that should be returned
	// an empty string requests all repos
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	// projects filters out repos that do not belong in the list, while no projects means list all repos.
	Projects             []*Project `protobuf:"bytes,2,rep,name=projects,proto3" json:"projects,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ListRepoRequest) Reset()         { *m = ListRepoRequest{} }
func (m *ListRepoRequest) String() string { return proto.CompactTextString(m) }
func (*ListRepoRequest) ProtoMessage()    {}
func (*ListRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{17}
}
func (m *ListRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListRepoRequest.Merge(m, src)
}
func (m *ListRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListRepoRequest proto.InternalMessageInfo

func (m *ListRepoRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ListRepoRequest) GetProjects() []*Project {
	if m != nil {
		return m.Projects
	}
	return nil
}

type DeleteRepoRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteRepoRequest) Reset()         { *m = DeleteRepoRequest{} }
func (m *DeleteRepoRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteRepoRequest) ProtoMessage()    {}
func (*DeleteRepoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{18}
}
func (m *DeleteRepoRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteRepoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteRepoRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteRepoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteRepoRequest.Merge(m, src)
}
func (m *DeleteRepoRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteRepoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteRepoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteRepoRequest proto.InternalMessageInfo

func (m *DeleteRepoRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *DeleteRepoRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

// DeleteReposRequest is used to delete more than one repo at once.
type DeleteReposRequest struct {
	// All repos in each project will be deleted if the caller has
	// permission.
	Projects []*Project `protobuf:"bytes,1,rep,name=projects,proto3" json:"projects,omitempty"`
	Force    bool       `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	// If all is set, then all repos in all projects will be deleted if the caller
	// has permission.
	All                  bool     `protobuf:"varint,3,opt,name=all,proto3" json:"all,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteReposRequest) Reset()         { *m = DeleteReposRequest{} }
func (m *DeleteReposRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteReposRequest) ProtoMessage()    {}
func (*DeleteReposRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{19}
}
func (m *DeleteReposRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteReposRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteReposRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteReposRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteReposRequest.Merge(m, src)
}
func (m *DeleteReposRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteReposRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteReposRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteReposRequest proto.InternalMessageInfo

func (m *DeleteReposRequest) GetProjects() []*Project {
	if m != nil {
		return m.Projects
	}
	return nil
}

func (m *DeleteReposRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

func (m *DeleteReposRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

type DeleteReposResponse struct {
	Repos                []*Repo  `protobuf:"bytes,1,rep,name=repos,proto3" json:"repos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteReposResponse) Reset()         { *m = DeleteReposResponse{} }
func (m *DeleteReposResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteReposResponse) ProtoMessage()    {}
func (*DeleteReposResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{20}
}
func (m *DeleteReposResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteReposResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteReposResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteReposResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteReposResponse.Merge(m, src)
}
func (m *DeleteReposResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteReposResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteReposResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteReposResponse proto.InternalMessageInfo

func (m *DeleteReposResponse) GetRepos() []*Repo {
	if m != nil {
		return m.Repos
	}
	return nil
}

type StartCommitRequest struct {
	// parent may be empty in which case the commit that Branch points to will be used as the parent.
	// If the branch does not exist, the commit will have no parent.
	Parent *Commit `protobuf:"bytes,1,opt,name=parent,proto3" json:"parent,omitempty"`
	// description is a user-provided string describing this commit
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Branch               *Branch  `protobuf:"bytes,3,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StartCommitRequest) Reset()         { *m = StartCommitRequest{} }
func (m *StartCommitRequest) String() string { return proto.CompactTextString(m) }
func (*StartCommitRequest) ProtoMessage()    {}
func (*StartCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{21}
}
func (m *StartCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StartCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StartCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StartCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StartCommitRequest.Merge(m, src)
}
func (m *StartCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *StartCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StartCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StartCommitRequest proto.InternalMessageInfo

func (m *StartCommitRequest) GetParent() *Commit {
	if m != nil {
		return m.Parent
	}
	return nil
}

func (m *StartCommitRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *StartCommitRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

type FinishCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// description is a user-provided string describing this commit. Setting this
	// will overwrite the description set in StartCommit
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Error                string   `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Force                bool     `protobuf:"varint,4,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FinishCommitRequest) Reset()         { *m = FinishCommitRequest{} }
func (m *FinishCommitRequest) String() string { return proto.CompactTextString(m) }
func (*FinishCommitRequest) ProtoMessage()    {}
func (*FinishCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{22}
}
func (m *FinishCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FinishCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FinishCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FinishCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FinishCommitRequest.Merge(m, src)
}
func (m *FinishCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *FinishCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FinishCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FinishCommitRequest proto.InternalMessageInfo

func (m *FinishCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *FinishCommitRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FinishCommitRequest) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *FinishCommitRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type InspectCommitRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// Wait causes inspect commit to wait until the commit is in the desired state.
	Wait                 CommitState `protobuf:"varint,2,opt,name=wait,proto3,enum=pfs_v2.CommitState" json:"wait,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *InspectCommitRequest) Reset()         { *m = InspectCommitRequest{} }
func (m *InspectCommitRequest) String() string { return proto.CompactTextString(m) }
func (*InspectCommitRequest) ProtoMessage()    {}
func (*InspectCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{23}
}
func (m *InspectCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectCommitRequest.Merge(m, src)
}
func (m *InspectCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectCommitRequest proto.InternalMessageInfo

func (m *InspectCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *InspectCommitRequest) GetWait() CommitState {
	if m != nil {
		return m.Wait
	}
	return CommitState_COMMIT_STATE_UNKNOWN
}

type ListCommitRequest struct {
	Repo                 *Repo            `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	From                 *Commit          `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To                   *Commit          `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Number               int64            `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	Reverse              bool             `protobuf:"varint,5,opt,name=reverse,proto3" json:"reverse,omitempty"`
	All                  bool             `protobuf:"varint,6,opt,name=all,proto3" json:"all,omitempty"`
	OriginKind           OriginKind       `protobuf:"varint,7,opt,name=origin_kind,json=originKind,proto3,enum=pfs_v2.OriginKind" json:"origin_kind,omitempty"`
	StartedTime          *types.Timestamp `protobuf:"bytes,8,opt,name=started_time,json=startedTime,proto3" json:"started_time,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ListCommitRequest) Reset()         { *m = ListCommitRequest{} }
func (m *ListCommitRequest) String() string { return proto.CompactTextString(m) }
func (*ListCommitRequest) ProtoMessage()    {}
func (*ListCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{24}
}
func (m *ListCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCommitRequest.Merge(m, src)
}
func (m *ListCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCommitRequest proto.InternalMessageInfo

func (m *ListCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *ListCommitRequest) GetTo() *Commit {
	if m != nil {
		return m.To
	}
	return nil
}

func (m *ListCommitRequest) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ListCommitRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

func (m *ListCommitRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *ListCommitRequest) GetOriginKind() OriginKind {
	if m != nil {
		return m.OriginKind
	}
	return OriginKind_ORIGIN_KIND_UNKNOWN
}

func (m *ListCommitRequest) GetStartedTime() *types.Timestamp {
	if m != nil {
		return m.StartedTime
	}
	return nil
}

type InspectCommitSetRequest struct {
	CommitSet            *CommitSet `protobuf:"bytes,1,opt,name=commit_set,json=commitSet,proto3" json:"commit_set,omitempty"`
	Wait                 bool       `protobuf:"varint,2,opt,name=wait,proto3" json:"wait,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *InspectCommitSetRequest) Reset()         { *m = InspectCommitSetRequest{} }
func (m *InspectCommitSetRequest) String() string { return proto.CompactTextString(m) }
func (*InspectCommitSetRequest) ProtoMessage()    {}
func (*InspectCommitSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{25}
}
func (m *InspectCommitSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectCommitSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectCommitSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectCommitSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectCommitSetRequest.Merge(m, src)
}
func (m *InspectCommitSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectCommitSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectCommitSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectCommitSetRequest proto.InternalMessageInfo

func (m *InspectCommitSetRequest) GetCommitSet() *CommitSet {
	if m != nil {
		return m.CommitSet
	}
	return nil
}

func (m *InspectCommitSetRequest) GetWait() bool {
	if m != nil {
		return m.Wait
	}
	return false
}

type ListCommitSetRequest struct {
	Project              *Project `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListCommitSetRequest) Reset()         { *m = ListCommitSetRequest{} }
func (m *ListCommitSetRequest) String() string { return proto.CompactTextString(m) }
func (*ListCommitSetRequest) ProtoMessage()    {}
func (*ListCommitSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{26}
}
func (m *ListCommitSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListCommitSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListCommitSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListCommitSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListCommitSetRequest.Merge(m, src)
}
func (m *ListCommitSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListCommitSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListCommitSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListCommitSetRequest proto.InternalMessageInfo

func (m *ListCommitSetRequest) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

type SquashCommitSetRequest struct {
	CommitSet            *CommitSet `protobuf:"bytes,1,opt,name=commit_set,json=commitSet,proto3" json:"commit_set,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *SquashCommitSetRequest) Reset()         { *m = SquashCommitSetRequest{} }
func (m *SquashCommitSetRequest) String() string { return proto.CompactTextString(m) }
func (*SquashCommitSetRequest) ProtoMessage()    {}
func (*SquashCommitSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{27}
}
func (m *SquashCommitSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SquashCommitSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SquashCommitSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SquashCommitSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SquashCommitSetRequest.Merge(m, src)
}
func (m *SquashCommitSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *SquashCommitSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SquashCommitSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SquashCommitSetRequest proto.InternalMessageInfo

func (m *SquashCommitSetRequest) GetCommitSet() *CommitSet {
	if m != nil {
		return m.CommitSet
	}
	return nil
}

type DropCommitSetRequest struct {
	CommitSet            *CommitSet `protobuf:"bytes,1,opt,name=commit_set,json=commitSet,proto3" json:"commit_set,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *DropCommitSetRequest) Reset()         { *m = DropCommitSetRequest{} }
func (m *DropCommitSetRequest) String() string { return proto.CompactTextString(m) }
func (*DropCommitSetRequest) ProtoMessage()    {}
func (*DropCommitSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{28}
}
func (m *DropCommitSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DropCommitSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DropCommitSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DropCommitSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DropCommitSetRequest.Merge(m, src)
}
func (m *DropCommitSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *DropCommitSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DropCommitSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DropCommitSetRequest proto.InternalMessageInfo

func (m *DropCommitSetRequest) GetCommitSet() *CommitSet {
	if m != nil {
		return m.CommitSet
	}
	return nil
}

type SubscribeCommitRequest struct {
	Repo   *Repo  `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Branch string `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	// only commits created since this commit are returned
	From *Commit `protobuf:"bytes,3,opt,name=from,proto3" json:"from,omitempty"`
	// Don't return commits until they're in (at least) the desired state.
	State                CommitState `protobuf:"varint,4,opt,name=state,proto3,enum=pfs_v2.CommitState" json:"state,omitempty"`
	All                  bool        `protobuf:"varint,5,opt,name=all,proto3" json:"all,omitempty"`
	OriginKind           OriginKind  `protobuf:"varint,6,opt,name=origin_kind,json=originKind,proto3,enum=pfs_v2.OriginKind" json:"origin_kind,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *SubscribeCommitRequest) Reset()         { *m = SubscribeCommitRequest{} }
func (m *SubscribeCommitRequest) String() string { return proto.CompactTextString(m) }
func (*SubscribeCommitRequest) ProtoMessage()    {}
func (*SubscribeCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{29}
}
func (m *SubscribeCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubscribeCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubscribeCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubscribeCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubscribeCommitRequest.Merge(m, src)
}
func (m *SubscribeCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SubscribeCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SubscribeCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SubscribeCommitRequest proto.InternalMessageInfo

func (m *SubscribeCommitRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *SubscribeCommitRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *SubscribeCommitRequest) GetFrom() *Commit {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *SubscribeCommitRequest) GetState() CommitState {
	if m != nil {
		return m.State
	}
	return CommitState_COMMIT_STATE_UNKNOWN
}

func (m *SubscribeCommitRequest) GetAll() bool {
	if m != nil {
		return m.All
	}
	return false
}

func (m *SubscribeCommitRequest) GetOriginKind() OriginKind {
	if m != nil {
		return m.OriginKind
	}
	return OriginKind_ORIGIN_KIND_UNKNOWN
}

type ClearCommitRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearCommitRequest) Reset()         { *m = ClearCommitRequest{} }
func (m *ClearCommitRequest) String() string { return proto.CompactTextString(m) }
func (*ClearCommitRequest) ProtoMessage()    {}
func (*ClearCommitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{30}
}
func (m *ClearCommitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearCommitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearCommitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearCommitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearCommitRequest.Merge(m, src)
}
func (m *ClearCommitRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearCommitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearCommitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearCommitRequest proto.InternalMessageInfo

func (m *ClearCommitRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type CreateBranchRequest struct {
	Head                 *Commit   `protobuf:"bytes,1,opt,name=head,proto3" json:"head,omitempty"`
	Branch               *Branch   `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Provenance           []*Branch `protobuf:"bytes,3,rep,name=provenance,proto3" json:"provenance,omitempty"`
	Trigger              *Trigger  `protobuf:"bytes,4,opt,name=trigger,proto3" json:"trigger,omitempty"`
	NewCommitSet         bool      `protobuf:"varint,5,opt,name=new_commit_set,json=newCommitSet,proto3" json:"new_commit_set,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *CreateBranchRequest) Reset()         { *m = CreateBranchRequest{} }
func (m *CreateBranchRequest) String() string { return proto.CompactTextString(m) }
func (*CreateBranchRequest) ProtoMessage()    {}
func (*CreateBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{31}
}
func (m *CreateBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateBranchRequest.Merge(m, src)
}
func (m *CreateBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateBranchRequest proto.InternalMessageInfo

func (m *CreateBranchRequest) GetHead() *Commit {
	if m != nil {
		return m.Head
	}
	return nil
}

func (m *CreateBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *CreateBranchRequest) GetProvenance() []*Branch {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *CreateBranchRequest) GetTrigger() *Trigger {
	if m != nil {
		return m.Trigger
	}
	return nil
}

func (m *CreateBranchRequest) GetNewCommitSet() bool {
	if m != nil {
		return m.NewCommitSet
	}
	return false
}

type FindCommitsRequest struct {
	Start                *Commit  `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	FilePath             string   `protobuf:"bytes,2,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty"`
	Limit                uint32   `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FindCommitsRequest) Reset()         { *m = FindCommitsRequest{} }
func (m *FindCommitsRequest) String() string { return proto.CompactTextString(m) }
func (*FindCommitsRequest) ProtoMessage()    {}
func (*FindCommitsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{32}
}
func (m *FindCommitsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCommitsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCommitsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCommitsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCommitsRequest.Merge(m, src)
}
func (m *FindCommitsRequest) XXX_Size() int {
	return m.Size()
}
func (m *FindCommitsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCommitsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FindCommitsRequest proto.InternalMessageInfo

func (m *FindCommitsRequest) GetStart() *Commit {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *FindCommitsRequest) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *FindCommitsRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type FindCommitsResponse struct {
	// Types that are valid to be assigned to Result:
	//
	//	*FindCommitsResponse_FoundCommit
	//	*FindCommitsResponse_LastSearchedCommit
	Result               isFindCommitsResponse_Result `protobuf_oneof:"result"`
	CommitsSearched      uint32                       `protobuf:"varint,3,opt,name=commits_searched,json=commitsSearched,proto3" json:"commits_searched,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *FindCommitsResponse) Reset()         { *m = FindCommitsResponse{} }
func (m *FindCommitsResponse) String() string { return proto.CompactTextString(m) }
func (*FindCommitsResponse) ProtoMessage()    {}
func (*FindCommitsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{33}
}
func (m *FindCommitsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindCommitsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindCommitsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindCommitsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindCommitsResponse.Merge(m, src)
}
func (m *FindCommitsResponse) XXX_Size() int {
	return m.Size()
}
func (m *FindCommitsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FindCommitsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FindCommitsResponse proto.InternalMessageInfo

type isFindCommitsResponse_Result interface {
	isFindCommitsResponse_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FindCommitsResponse_FoundCommit struct {
	FoundCommit *Commit `protobuf:"bytes,1,opt,name=found_commit,json=foundCommit,proto3,oneof" json:"found_commit,omitempty"`
}
type FindCommitsResponse_LastSearchedCommit struct {
	LastSearchedCommit *Commit `protobuf:"bytes,2,opt,name=last_searched_commit,json=lastSearchedCommit,proto3,oneof" json:"last_searched_commit,omitempty"`
}

func (*FindCommitsResponse_FoundCommit) isFindCommitsResponse_Result()        {}
func (*FindCommitsResponse_LastSearchedCommit) isFindCommitsResponse_Result() {}

func (m *FindCommitsResponse) GetResult() isFindCommitsResponse_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *FindCommitsResponse) GetFoundCommit() *Commit {
	if x, ok := m.GetResult().(*FindCommitsResponse_FoundCommit); ok {
		return x.FoundCommit
	}
	return nil
}

func (m *FindCommitsResponse) GetLastSearchedCommit() *Commit {
	if x, ok := m.GetResult().(*FindCommitsResponse_LastSearchedCommit); ok {
		return x.LastSearchedCommit
	}
	return nil
}

func (m *FindCommitsResponse) GetCommitsSearched() uint32 {
	if m != nil {
		return m.CommitsSearched
	}
	return 0
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FindCommitsResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FindCommitsResponse_FoundCommit)(nil),
		(*FindCommitsResponse_LastSearchedCommit)(nil),
	}
}

type InspectBranchRequest struct {
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectBranchRequest) Reset()         { *m = InspectBranchRequest{} }
func (m *InspectBranchRequest) String() string { return proto.CompactTextString(m) }
func (*InspectBranchRequest) ProtoMessage()    {}
func (*InspectBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{34}
}
func (m *InspectBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectBranchRequest.Merge(m, src)
}
func (m *InspectBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectBranchRequest proto.InternalMessageInfo

func (m *InspectBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

type ListBranchRequest struct {
	Repo                 *Repo    `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	Reverse              bool     `protobuf:"varint,2,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListBranchRequest) Reset()         { *m = ListBranchRequest{} }
func (m *ListBranchRequest) String() string { return proto.CompactTextString(m) }
func (*ListBranchRequest) ProtoMessage()    {}
func (*ListBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{35}
}
func (m *ListBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListBranchRequest.Merge(m, src)
}
func (m *ListBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListBranchRequest proto.InternalMessageInfo

func (m *ListBranchRequest) GetRepo() *Repo {
	if m != nil {
		return m.Repo
	}
	return nil
}

func (m *ListBranchRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type DeleteBranchRequest struct {
	Branch               *Branch  `protobuf:"bytes,1,opt,name=branch,proto3" json:"branch,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteBranchRequest) Reset()         { *m = DeleteBranchRequest{} }
func (m *DeleteBranchRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteBranchRequest) ProtoMessage()    {}
func (*DeleteBranchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{36}
}
func (m *DeleteBranchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteBranchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteBranchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteBranchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteBranchRequest.Merge(m, src)
}
func (m *DeleteBranchRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteBranchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteBranchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteBranchRequest proto.InternalMessageInfo

func (m *DeleteBranchRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *DeleteBranchRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type CreateProjectRequest struct {
	Project              *Project `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Description          string   `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	Update               bool     `protobuf:"varint,3,opt,name=update,proto3" json:"update,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateProjectRequest) Reset()         { *m = CreateProjectRequest{} }
func (m *CreateProjectRequest) String() string { return proto.CompactTextString(m) }
func (*CreateProjectRequest) ProtoMessage()    {}
func (*CreateProjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{37}
}
func (m *CreateProjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateProjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateProjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateProjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateProjectRequest.Merge(m, src)
}
func (m *CreateProjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *CreateProjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateProjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CreateProjectRequest proto.InternalMessageInfo

func (m *CreateProjectRequest) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

func (m *CreateProjectRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *CreateProjectRequest) GetUpdate() bool {
	if m != nil {
		return m.Update
	}
	return false
}

type InspectProjectRequest struct {
	Project              *Project `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectProjectRequest) Reset()         { *m = InspectProjectRequest{} }
func (m *InspectProjectRequest) String() string { return proto.CompactTextString(m) }
func (*InspectProjectRequest) ProtoMessage()    {}
func (*InspectProjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{38}
}
func (m *InspectProjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectProjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectProjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectProjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectProjectRequest.Merge(m, src)
}
func (m *InspectProjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectProjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectProjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectProjectRequest proto.InternalMessageInfo

func (m *InspectProjectRequest) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

type ListProjectRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListProjectRequest) Reset()         { *m = ListProjectRequest{} }
func (m *ListProjectRequest) String() string { return proto.CompactTextString(m) }
func (*ListProjectRequest) ProtoMessage()    {}
func (*ListProjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{39}
}
func (m *ListProjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListProjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListProjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListProjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListProjectRequest.Merge(m, src)
}
func (m *ListProjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListProjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListProjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListProjectRequest proto.InternalMessageInfo

type DeleteProjectRequest struct {
	Project              *Project `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
	Force                bool     `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteProjectRequest) Reset()         { *m = DeleteProjectRequest{} }
func (m *DeleteProjectRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteProjectRequest) ProtoMessage()    {}
func (*DeleteProjectRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{40}
}
func (m *DeleteProjectRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteProjectRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteProjectRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteProjectRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteProjectRequest.Merge(m, src)
}
func (m *DeleteProjectRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteProjectRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteProjectRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteProjectRequest proto.InternalMessageInfo

func (m *DeleteProjectRequest) GetProject() *Project {
	if m != nil {
		return m.Project
	}
	return nil
}

func (m *DeleteProjectRequest) GetForce() bool {
	if m != nil {
		return m.Force
	}
	return false
}

type AddFile struct {
	Path  string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Datum string `protobuf:"bytes,2,opt,name=datum,proto3" json:"datum,omitempty"`
	// Types that are valid to be assigned to Source:
	//
	//	*AddFile_Raw
	//	*AddFile_Url
	Source               isAddFile_Source `protobuf_oneof:"source"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *AddFile) Reset()         { *m = AddFile{} }
func (m *AddFile) String() string { return proto.CompactTextString(m) }
func (*AddFile) ProtoMessage()    {}
func (*AddFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{41}
}
func (m *AddFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFile.Merge(m, src)
}
func (m *AddFile) XXX_Size() int {
	return m.Size()
}
func (m *AddFile) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFile.DiscardUnknown(m)
}

var xxx_messageInfo_AddFile proto.InternalMessageInfo

type isAddFile_Source interface {
	isAddFile_Source()
	MarshalTo([]byte) (int, error)
	Size() int
}

type AddFile_Raw struct {
	Raw *types.BytesValue `protobuf:"bytes,3,opt,name=raw,proto3,oneof" json:"raw,omitempty"`
}
type AddFile_Url struct {
	Url *AddFile_URLSource `protobuf:"bytes,4,opt,name=url,proto3,oneof" json:"url,omitempty"`
}

func (*AddFile_Raw) isAddFile_Source() {}
func (*AddFile_Url) isAddFile_Source() {}

func (m *AddFile) GetSource() isAddFile_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *AddFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *AddFile) GetDatum() string {
	if m != nil {
		return m.Datum
	}
	return ""
}

func (m *AddFile) GetRaw() *types.BytesValue {
	if x, ok := m.GetSource().(*AddFile_Raw); ok {
		return x.Raw
	}
	return nil
}

func (m *AddFile) GetUrl() *AddFile_URLSource {
	if x, ok := m.GetSource().(*AddFile_Url); ok {
		return x.Url
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*AddFile) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*AddFile_Raw)(nil),
		(*AddFile_Url)(nil),
	}
}

type AddFile_URLSource struct {
	URL                  string   `protobuf:"bytes,1,opt,name=URL,proto3" json:"URL,omitempty"`
	Recursive            bool     `protobuf:"varint,2,opt,name=recursive,proto3" json:"recursive,omitempty"`
	Concurrency          uint32   `protobuf:"varint,3,opt,name=concurrency,proto3" json:"concurrency,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFile_URLSource) Reset()         { *m = AddFile_URLSource{} }
func (m *AddFile_URLSource) String() string { return proto.CompactTextString(m) }
func (*AddFile_URLSource) ProtoMessage()    {}
func (*AddFile_URLSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{41, 0}
}
func (m *AddFile_URLSource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFile_URLSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFile_URLSource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFile_URLSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFile_URLSource.Merge(m, src)
}
func (m *AddFile_URLSource) XXX_Size() int {
	return m.Size()
}
func (m *AddFile_URLSource) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFile_URLSource.DiscardUnknown(m)
}

var xxx_messageInfo_AddFile_URLSource proto.InternalMessageInfo

func (m *AddFile_URLSource) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *AddFile_URLSource) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

func (m *AddFile_URLSource) GetConcurrency() uint32 {
	if m != nil {
		return m.Concurrency
	}
	return 0
}

type DeleteFile struct {
	Path                 string   `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Datum                string   `protobuf:"bytes,2,opt,name=datum,proto3" json:"datum,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteFile) Reset()         { *m = DeleteFile{} }
func (m *DeleteFile) String() string { return proto.CompactTextString(m) }
func (*DeleteFile) ProtoMessage()    {}
func (*DeleteFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{42}
}
func (m *DeleteFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteFile.Merge(m, src)
}
func (m *DeleteFile) XXX_Size() int {
	return m.Size()
}
func (m *DeleteFile) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteFile.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteFile proto.InternalMessageInfo

func (m *DeleteFile) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *DeleteFile) GetDatum() string {
	if m != nil {
		return m.Datum
	}
	return ""
}

type CopyFile struct {
	Dst                  string   `protobuf:"bytes,1,opt,name=dst,proto3" json:"dst,omitempty"`
	Datum                string   `protobuf:"bytes,2,opt,name=datum,proto3" json:"datum,omitempty"`
	Src                  *File    `protobuf:"bytes,3,opt,name=src,proto3" json:"src,omitempty"`
	Append               bool     `protobuf:"varint,4,opt,name=append,proto3" json:"append,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CopyFile) Reset()         { *m = CopyFile{} }
func (m *CopyFile) String() string { return proto.CompactTextString(m) }
func (*CopyFile) ProtoMessage()    {}
func (*CopyFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{43}
}
func (m *CopyFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyFile.Merge(m, src)
}
func (m *CopyFile) XXX_Size() int {
	return m.Size()
}
func (m *CopyFile) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyFile.DiscardUnknown(m)
}

var xxx_messageInfo_CopyFile proto.InternalMessageInfo

func (m *CopyFile) GetDst() string {
	if m != nil {
		return m.Dst
	}
	return ""
}

func (m *CopyFile) GetDatum() string {
	if m != nil {
		return m.Datum
	}
	return ""
}

func (m *CopyFile) GetSrc() *File {
	if m != nil {
		return m.Src
	}
	return nil
}

func (m *CopyFile) GetAppend() bool {
	if m != nil {
		return m.Append
	}
	return false
}

type ModifyFileRequest struct {
	// Types that are valid to be assigned to Body:
	//
	//	*ModifyFileRequest_SetCommit
	//	*ModifyFileRequest_AddFile
	//	*ModifyFileRequest_DeleteFile
	//	*ModifyFileRequest_CopyFile
	Body                 isModifyFileRequest_Body `protobuf_oneof:"body"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *ModifyFileRequest) Reset()         { *m = ModifyFileRequest{} }
func (m *ModifyFileRequest) String() string { return proto.CompactTextString(m) }
func (*ModifyFileRequest) ProtoMessage()    {}
func (*ModifyFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{44}
}
func (m *ModifyFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModifyFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModifyFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModifyFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModifyFileRequest.Merge(m, src)
}
func (m *ModifyFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ModifyFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ModifyFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ModifyFileRequest proto.InternalMessageInfo

type isModifyFileRequest_Body interface {
	isModifyFileRequest_Body()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ModifyFileRequest_SetCommit struct {
	SetCommit *Commit `protobuf:"bytes,1,opt,name=set_commit,json=setCommit,proto3,oneof" json:"set_commit,omitempty"`
}
type ModifyFileRequest_AddFile struct {
	AddFile *AddFile `protobuf:"bytes,2,opt,name=add_file,json=addFile,proto3,oneof" json:"add_file,omitempty"`
}
type ModifyFileRequest_DeleteFile struct {
	DeleteFile *DeleteFile `protobuf:"bytes,3,opt,name=delete_file,json=deleteFile,proto3,oneof" json:"delete_file,omitempty"`
}
type ModifyFileRequest_CopyFile struct {
	CopyFile *CopyFile `protobuf:"bytes,4,opt,name=copy_file,json=copyFile,proto3,oneof" json:"copy_file,omitempty"`
}

func (*ModifyFileRequest_SetCommit) isModifyFileRequest_Body()  {}
func (*ModifyFileRequest_AddFile) isModifyFileRequest_Body()    {}
func (*ModifyFileRequest_DeleteFile) isModifyFileRequest_Body() {}
func (*ModifyFileRequest_CopyFile) isModifyFileRequest_Body()   {}

func (m *ModifyFileRequest) GetBody() isModifyFileRequest_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *ModifyFileRequest) GetSetCommit() *Commit {
	if x, ok := m.GetBody().(*ModifyFileRequest_SetCommit); ok {
		return x.SetCommit
	}
	return nil
}

func (m *ModifyFileRequest) GetAddFile() *AddFile {
	if x, ok := m.GetBody().(*ModifyFileRequest_AddFile); ok {
		return x.AddFile
	}
	return nil
}

func (m *ModifyFileRequest) GetDeleteFile() *DeleteFile {
	if x, ok := m.GetBody().(*ModifyFileRequest_DeleteFile); ok {
		return x.DeleteFile
	}
	return nil
}

func (m *ModifyFileRequest) GetCopyFile() *CopyFile {
	if x, ok := m.GetBody().(*ModifyFileRequest_CopyFile); ok {
		return x.CopyFile
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModifyFileRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModifyFileRequest_SetCommit)(nil),
		(*ModifyFileRequest_AddFile)(nil),
		(*ModifyFileRequest_DeleteFile)(nil),
		(*ModifyFileRequest_CopyFile)(nil),
	}
}

type GetFileRequest struct {
	File                 *File      `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	URL                  string     `protobuf:"bytes,2,opt,name=URL,proto3" json:"URL,omitempty"`
	Offset               int64      `protobuf:"varint,3,opt,name=offset,proto3" json:"offset,omitempty"`
	PathRange            *PathRange `protobuf:"bytes,4,opt,name=path_range,json=pathRange,proto3" json:"path_range,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetFileRequest) Reset()         { *m = GetFileRequest{} }
func (m *GetFileRequest) String() string { return proto.CompactTextString(m) }
func (*GetFileRequest) ProtoMessage()    {}
func (*GetFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{45}
}
func (m *GetFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileRequest.Merge(m, src)
}
func (m *GetFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileRequest proto.InternalMessageInfo

func (m *GetFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetFileRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *GetFileRequest) GetOffset() int64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetFileRequest) GetPathRange() *PathRange {
	if m != nil {
		return m.PathRange
	}
	return nil
}

type InspectFileRequest struct {
	File                 *File    `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InspectFileRequest) Reset()         { *m = InspectFileRequest{} }
func (m *InspectFileRequest) String() string { return proto.CompactTextString(m) }
func (*InspectFileRequest) ProtoMessage()    {}
func (*InspectFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{46}
}
func (m *InspectFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InspectFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InspectFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InspectFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InspectFileRequest.Merge(m, src)
}
func (m *InspectFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *InspectFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InspectFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InspectFileRequest proto.InternalMessageInfo

func (m *InspectFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type ListFileRequest struct {
	// File is the parent directory of the files we want to list. This sets the
	// repo, the commit/branch, and path prefix of files we're interested in
	// If the "path" field is omitted, a list of files at the top level of the repo
	// is returned
	File *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// Marker for pagination. If set, the files that come after the marker in
	// lexicographical order will be returned. If reverse is also set, the files
	// that come before the marker in lexicographical order will be returned.
	PaginationMarker *File `protobuf:"bytes,3,opt,name=paginationMarker,proto3" json:"paginationMarker,omitempty"`
	// Number of files to return
	Number int64 `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
	// If true, return files in reverse order
	Reverse              bool     `protobuf:"varint,5,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListFileRequest) Reset()         { *m = ListFileRequest{} }
func (m *ListFileRequest) String() string { return proto.CompactTextString(m) }
func (*ListFileRequest) ProtoMessage()    {}
func (*ListFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{47}
}
func (m *ListFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ListFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ListFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ListFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListFileRequest.Merge(m, src)
}
func (m *ListFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *ListFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListFileRequest proto.InternalMessageInfo

func (m *ListFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *ListFileRequest) GetPaginationMarker() *File {
	if m != nil {
		return m.PaginationMarker
	}
	return nil
}

func (m *ListFileRequest) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *ListFileRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type WalkFileRequest struct {
	File *File `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
	// Marker for pagination. If set, the files that come after the marker in
	// lexicographical order will be returned. If reverse is also set, the files
	// that come before the marker in lexicographical order will be returned.
	PaginationMarker *File `protobuf:"bytes,2,opt,name=paginationMarker,proto3" json:"paginationMarker,omitempty"`
	// Number of files to return
	Number int64 `protobuf:"varint,3,opt,name=number,proto3" json:"number,omitempty"`
	// If true, return files in reverse order
	Reverse              bool     `protobuf:"varint,4,opt,name=reverse,proto3" json:"reverse,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *WalkFileRequest) Reset()         { *m = WalkFileRequest{} }
func (m *WalkFileRequest) String() string { return proto.CompactTextString(m) }
func (*WalkFileRequest) ProtoMessage()    {}
func (*WalkFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{48}
}
func (m *WalkFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalkFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalkFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalkFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalkFileRequest.Merge(m, src)
}
func (m *WalkFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *WalkFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_WalkFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_WalkFileRequest proto.InternalMessageInfo

func (m *WalkFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *WalkFileRequest) GetPaginationMarker() *File {
	if m != nil {
		return m.PaginationMarker
	}
	return nil
}

func (m *WalkFileRequest) GetNumber() int64 {
	if m != nil {
		return m.Number
	}
	return 0
}

func (m *WalkFileRequest) GetReverse() bool {
	if m != nil {
		return m.Reverse
	}
	return false
}

type GlobFileRequest struct {
	Commit               *Commit    `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	Pattern              string     `protobuf:"bytes,2,opt,name=pattern,proto3" json:"pattern,omitempty"`
	PathRange            *PathRange `protobuf:"bytes,3,opt,name=path_range,json=pathRange,proto3" json:"path_range,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GlobFileRequest) Reset()         { *m = GlobFileRequest{} }
func (m *GlobFileRequest) String() string { return proto.CompactTextString(m) }
func (*GlobFileRequest) ProtoMessage()    {}
func (*GlobFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{49}
}
func (m *GlobFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobFileRequest.Merge(m, src)
}
func (m *GlobFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *GlobFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GlobFileRequest proto.InternalMessageInfo

func (m *GlobFileRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *GlobFileRequest) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

func (m *GlobFileRequest) GetPathRange() *PathRange {
	if m != nil {
		return m.PathRange
	}
	return nil
}

type DiffFileRequest struct {
	NewFile *File `protobuf:"bytes,1,opt,name=new_file,json=newFile,proto3" json:"new_file,omitempty"`
	// OldFile may be left nil in which case the same path in the parent of
	// NewFile's commit will be used.
	OldFile              *File    `protobuf:"bytes,2,opt,name=old_file,json=oldFile,proto3" json:"old_file,omitempty"`
	Shallow              bool     `protobuf:"varint,3,opt,name=shallow,proto3" json:"shallow,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DiffFileRequest) Reset()         { *m = DiffFileRequest{} }
func (m *DiffFileRequest) String() string { return proto.CompactTextString(m) }
func (*DiffFileRequest) ProtoMessage()    {}
func (*DiffFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{50}
}
func (m *DiffFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiffFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiffFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiffFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiffFileRequest.Merge(m, src)
}
func (m *DiffFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *DiffFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DiffFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DiffFileRequest proto.InternalMessageInfo

func (m *DiffFileRequest) GetNewFile() *File {
	if m != nil {
		return m.NewFile
	}
	return nil
}

func (m *DiffFileRequest) GetOldFile() *File {
	if m != nil {
		return m.OldFile
	}
	return nil
}

func (m *DiffFileRequest) GetShallow() bool {
	if m != nil {
		return m.Shallow
	}
	return false
}

type DiffFileResponse struct {
	NewFile              *FileInfo `protobuf:"bytes,1,opt,name=new_file,json=newFile,proto3" json:"new_file,omitempty"`
	OldFile              *FileInfo `protobuf:"bytes,2,opt,name=old_file,json=oldFile,proto3" json:"old_file,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *DiffFileResponse) Reset()         { *m = DiffFileResponse{} }
func (m *DiffFileResponse) String() string { return proto.CompactTextString(m) }
func (*DiffFileResponse) ProtoMessage()    {}
func (*DiffFileResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{51}
}
func (m *DiffFileResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DiffFileResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DiffFileResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DiffFileResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DiffFileResponse.Merge(m, src)
}
func (m *DiffFileResponse) XXX_Size() int {
	return m.Size()
}
func (m *DiffFileResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DiffFileResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DiffFileResponse proto.InternalMessageInfo

func (m *DiffFileResponse) GetNewFile() *FileInfo {
	if m != nil {
		return m.NewFile
	}
	return nil
}

func (m *DiffFileResponse) GetOldFile() *FileInfo {
	if m != nil {
		return m.OldFile
	}
	return nil
}

type FsckRequest struct {
	Fix bool `protobuf:"varint,1,opt,name=fix,proto3" json:"fix,omitempty"`
	// Types that are valid to be assigned to ZombieCheck:
	//
	//	*FsckRequest_ZombieTarget
	//	*FsckRequest_ZombieAll
	ZombieCheck          isFsckRequest_ZombieCheck `protobuf_oneof:"zombie_check"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *FsckRequest) Reset()         { *m = FsckRequest{} }
func (m *FsckRequest) String() string { return proto.CompactTextString(m) }
func (*FsckRequest) ProtoMessage()    {}
func (*FsckRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{52}
}
func (m *FsckRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FsckRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FsckRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FsckRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsckRequest.Merge(m, src)
}
func (m *FsckRequest) XXX_Size() int {
	return m.Size()
}
func (m *FsckRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FsckRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FsckRequest proto.InternalMessageInfo

type isFsckRequest_ZombieCheck interface {
	isFsckRequest_ZombieCheck()
	MarshalTo([]byte) (int, error)
	Size() int
}

type FsckRequest_ZombieTarget struct {
	ZombieTarget *Commit `protobuf:"bytes,2,opt,name=zombie_target,json=zombieTarget,proto3,oneof" json:"zombie_target,omitempty"`
}
type FsckRequest_ZombieAll struct {
	ZombieAll bool `protobuf:"varint,3,opt,name=zombie_all,json=zombieAll,proto3,oneof" json:"zombie_all,omitempty"`
}

func (*FsckRequest_ZombieTarget) isFsckRequest_ZombieCheck() {}
func (*FsckRequest_ZombieAll) isFsckRequest_ZombieCheck()    {}

func (m *FsckRequest) GetZombieCheck() isFsckRequest_ZombieCheck {
	if m != nil {
		return m.ZombieCheck
	}
	return nil
}

func (m *FsckRequest) GetFix() bool {
	if m != nil {
		return m.Fix
	}
	return false
}

func (m *FsckRequest) GetZombieTarget() *Commit {
	if x, ok := m.GetZombieCheck().(*FsckRequest_ZombieTarget); ok {
		return x.ZombieTarget
	}
	return nil
}

func (m *FsckRequest) GetZombieAll() bool {
	if x, ok := m.GetZombieCheck().(*FsckRequest_ZombieAll); ok {
		return x.ZombieAll
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*FsckRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*FsckRequest_ZombieTarget)(nil),
		(*FsckRequest_ZombieAll)(nil),
	}
}

type FsckResponse struct {
	Fix                  string   `protobuf:"bytes,1,opt,name=fix,proto3" json:"fix,omitempty"`
	Error                string   `protobuf:"bytes,2,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FsckResponse) Reset()         { *m = FsckResponse{} }
func (m *FsckResponse) String() string { return proto.CompactTextString(m) }
func (*FsckResponse) ProtoMessage()    {}
func (*FsckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{53}
}
func (m *FsckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FsckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FsckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FsckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FsckResponse.Merge(m, src)
}
func (m *FsckResponse) XXX_Size() int {
	return m.Size()
}
func (m *FsckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_FsckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_FsckResponse proto.InternalMessageInfo

func (m *FsckResponse) GetFix() string {
	if m != nil {
		return m.Fix
	}
	return ""
}

func (m *FsckResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CreateFileSetResponse struct {
	FileSetId            string   `protobuf:"bytes,1,opt,name=file_set_id,json=fileSetId,proto3" json:"file_set_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateFileSetResponse) Reset()         { *m = CreateFileSetResponse{} }
func (m *CreateFileSetResponse) String() string { return proto.CompactTextString(m) }
func (*CreateFileSetResponse) ProtoMessage()    {}
func (*CreateFileSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{54}
}
func (m *CreateFileSetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateFileSetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateFileSetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateFileSetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateFileSetResponse.Merge(m, src)
}
func (m *CreateFileSetResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateFileSetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateFileSetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateFileSetResponse proto.InternalMessageInfo

func (m *CreateFileSetResponse) GetFileSetId() string {
	if m != nil {
		return m.FileSetId
	}
	return ""
}

type GetFileSetRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetFileSetRequest) Reset()         { *m = GetFileSetRequest{} }
func (m *GetFileSetRequest) String() string { return proto.CompactTextString(m) }
func (*GetFileSetRequest) ProtoMessage()    {}
func (*GetFileSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{55}
}
func (m *GetFileSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetFileSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetFileSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetFileSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFileSetRequest.Merge(m, src)
}
func (m *GetFileSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetFileSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFileSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFileSetRequest proto.InternalMessageInfo

func (m *GetFileSetRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

type AddFileSetRequest struct {
	Commit               *Commit  `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	FileSetId            string   `protobuf:"bytes,2,opt,name=file_set_id,json=fileSetId,proto3" json:"file_set_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddFileSetRequest) Reset()         { *m = AddFileSetRequest{} }
func (m *AddFileSetRequest) String() string { return proto.CompactTextString(m) }
func (*AddFileSetRequest) ProtoMessage()    {}
func (*AddFileSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{56}
}
func (m *AddFileSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddFileSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddFileSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddFileSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddFileSetRequest.Merge(m, src)
}
func (m *AddFileSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *AddFileSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AddFileSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AddFileSetRequest proto.InternalMessageInfo

func (m *AddFileSetRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *AddFileSetRequest) GetFileSetId() string {
	if m != nil {
		return m.FileSetId
	}
	return ""
}

type RenewFileSetRequest struct {
	FileSetId            string   `protobuf:"bytes,1,opt,name=file_set_id,json=fileSetId,proto3" json:"file_set_id,omitempty"`
	TtlSeconds           int64    `protobuf:"varint,2,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RenewFileSetRequest) Reset()         { *m = RenewFileSetRequest{} }
func (m *RenewFileSetRequest) String() string { return proto.CompactTextString(m) }
func (*RenewFileSetRequest) ProtoMessage()    {}
func (*RenewFileSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{57}
}
func (m *RenewFileSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RenewFileSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RenewFileSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RenewFileSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RenewFileSetRequest.Merge(m, src)
}
func (m *RenewFileSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *RenewFileSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RenewFileSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RenewFileSetRequest proto.InternalMessageInfo

func (m *RenewFileSetRequest) GetFileSetId() string {
	if m != nil {
		return m.FileSetId
	}
	return ""
}

func (m *RenewFileSetRequest) GetTtlSeconds() int64 {
	if m != nil {
		return m.TtlSeconds
	}
	return 0
}

type ComposeFileSetRequest struct {
	FileSetIds           []string `protobuf:"bytes,1,rep,name=file_set_ids,json=fileSetIds,proto3" json:"file_set_ids,omitempty"`
	TtlSeconds           int64    `protobuf:"varint,2,opt,name=ttl_seconds,json=ttlSeconds,proto3" json:"ttl_seconds,omitempty"`
	Compact              bool     `protobuf:"varint,3,opt,name=compact,proto3" json:"compact,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ComposeFileSetRequest) Reset()         { *m = ComposeFileSetRequest{} }
func (m *ComposeFileSetRequest) String() string { return proto.CompactTextString(m) }
func (*ComposeFileSetRequest) ProtoMessage()    {}
func (*ComposeFileSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{58}
}
func (m *ComposeFileSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComposeFileSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComposeFileSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComposeFileSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComposeFileSetRequest.Merge(m, src)
}
func (m *ComposeFileSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ComposeFileSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ComposeFileSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ComposeFileSetRequest proto.InternalMessageInfo

func (m *ComposeFileSetRequest) GetFileSetIds() []string {
	if m != nil {
		return m.FileSetIds
	}
	return nil
}

func (m *ComposeFileSetRequest) GetTtlSeconds() int64 {
	if m != nil {
		return m.TtlSeconds
	}
	return 0
}

func (m *ComposeFileSetRequest) GetCompact() bool {
	if m != nil {
		return m.Compact
	}
	return false
}

type ShardFileSetRequest struct {
	FileSetId            string   `protobuf:"bytes,1,opt,name=file_set_id,json=fileSetId,proto3" json:"file_set_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardFileSetRequest) Reset()         { *m = ShardFileSetRequest{} }
func (m *ShardFileSetRequest) String() string { return proto.CompactTextString(m) }
func (*ShardFileSetRequest) ProtoMessage()    {}
func (*ShardFileSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{59}
}
func (m *ShardFileSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardFileSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardFileSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardFileSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardFileSetRequest.Merge(m, src)
}
func (m *ShardFileSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ShardFileSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardFileSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ShardFileSetRequest proto.InternalMessageInfo

func (m *ShardFileSetRequest) GetFileSetId() string {
	if m != nil {
		return m.FileSetId
	}
	return ""
}

type PathRange struct {
	Lower                string   `protobuf:"bytes,1,opt,name=lower,proto3" json:"lower,omitempty"`
	Upper                string   `protobuf:"bytes,2,opt,name=upper,proto3" json:"upper,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PathRange) Reset()         { *m = PathRange{} }
func (m *PathRange) String() string { return proto.CompactTextString(m) }
func (*PathRange) ProtoMessage()    {}
func (*PathRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{60}
}
func (m *PathRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PathRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PathRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PathRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PathRange.Merge(m, src)
}
func (m *PathRange) XXX_Size() int {
	return m.Size()
}
func (m *PathRange) XXX_DiscardUnknown() {
	xxx_messageInfo_PathRange.DiscardUnknown(m)
}

var xxx_messageInfo_PathRange proto.InternalMessageInfo

func (m *PathRange) GetLower() string {
	if m != nil {
		return m.Lower
	}
	return ""
}

func (m *PathRange) GetUpper() string {
	if m != nil {
		return m.Upper
	}
	return ""
}

type ShardFileSetResponse struct {
	Shards               []*PathRange `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ShardFileSetResponse) Reset()         { *m = ShardFileSetResponse{} }
func (m *ShardFileSetResponse) String() string { return proto.CompactTextString(m) }
func (*ShardFileSetResponse) ProtoMessage()    {}
func (*ShardFileSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{61}
}
func (m *ShardFileSetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardFileSetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardFileSetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardFileSetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardFileSetResponse.Merge(m, src)
}
func (m *ShardFileSetResponse) XXX_Size() int {
	return m.Size()
}
func (m *ShardFileSetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardFileSetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ShardFileSetResponse proto.InternalMessageInfo

func (m *ShardFileSetResponse) GetShards() []*PathRange {
	if m != nil {
		return m.Shards
	}
	return nil
}

type CheckStorageRequest struct {
	ReadChunkData        bool     `protobuf:"varint,1,opt,name=read_chunk_data,json=readChunkData,proto3" json:"read_chunk_data,omitempty"`
	ChunkBegin           []byte   `protobuf:"bytes,2,opt,name=chunk_begin,json=chunkBegin,proto3" json:"chunk_begin,omitempty"`
	ChunkEnd             []byte   `protobuf:"bytes,3,opt,name=chunk_end,json=chunkEnd,proto3" json:"chunk_end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckStorageRequest) Reset()         { *m = CheckStorageRequest{} }
func (m *CheckStorageRequest) String() string { return proto.CompactTextString(m) }
func (*CheckStorageRequest) ProtoMessage()    {}
func (*CheckStorageRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{62}
}
func (m *CheckStorageRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckStorageRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckStorageRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckStorageRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckStorageRequest.Merge(m, src)
}
func (m *CheckStorageRequest) XXX_Size() int {
	return m.Size()
}
func (m *CheckStorageRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckStorageRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CheckStorageRequest proto.InternalMessageInfo

func (m *CheckStorageRequest) GetReadChunkData() bool {
	if m != nil {
		return m.ReadChunkData
	}
	return false
}

func (m *CheckStorageRequest) GetChunkBegin() []byte {
	if m != nil {
		return m.ChunkBegin
	}
	return nil
}

func (m *CheckStorageRequest) GetChunkEnd() []byte {
	if m != nil {
		return m.ChunkEnd
	}
	return nil
}

type CheckStorageResponse struct {
	ChunkObjectCount     int64    `protobuf:"varint,1,opt,name=chunk_object_count,json=chunkObjectCount,proto3" json:"chunk_object_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckStorageResponse) Reset()         { *m = CheckStorageResponse{} }
func (m *CheckStorageResponse) String() string { return proto.CompactTextString(m) }
func (*CheckStorageResponse) ProtoMessage()    {}
func (*CheckStorageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{63}
}
func (m *CheckStorageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckStorageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckStorageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckStorageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckStorageResponse.Merge(m, src)
}
func (m *CheckStorageResponse) XXX_Size() int {
	return m.Size()
}
func (m *CheckStorageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckStorageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CheckStorageResponse proto.InternalMessageInfo

func (m *CheckStorageResponse) GetChunkObjectCount() int64 {
	if m != nil {
		return m.ChunkObjectCount
	}
	return 0
}

type PutCacheRequest struct {
	Key                  string     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                *types.Any `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	FileSetIds           []string   `protobuf:"bytes,3,rep,name=file_set_ids,json=fileSetIds,proto3" json:"file_set_ids,omitempty"`
	Tag                  string     `protobuf:"bytes,4,opt,name=tag,proto3" json:"tag,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *PutCacheRequest) Reset()         { *m = PutCacheRequest{} }
func (m *PutCacheRequest) String() string { return proto.CompactTextString(m) }
func (*PutCacheRequest) ProtoMessage()    {}
func (*PutCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{64}
}
func (m *PutCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutCacheRequest.Merge(m, src)
}
func (m *PutCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *PutCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PutCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PutCacheRequest proto.InternalMessageInfo

func (m *PutCacheRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *PutCacheRequest) GetValue() *types.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *PutCacheRequest) GetFileSetIds() []string {
	if m != nil {
		return m.FileSetIds
	}
	return nil
}

func (m *PutCacheRequest) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

type GetCacheRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetCacheRequest) Reset()         { *m = GetCacheRequest{} }
func (m *GetCacheRequest) String() string { return proto.CompactTextString(m) }
func (*GetCacheRequest) ProtoMessage()    {}
func (*GetCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{65}
}
func (m *GetCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCacheRequest.Merge(m, src)
}
func (m *GetCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetCacheRequest proto.InternalMessageInfo

func (m *GetCacheRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type GetCacheResponse struct {
	Value                *types.Any `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *GetCacheResponse) Reset()         { *m = GetCacheResponse{} }
func (m *GetCacheResponse) String() string { return proto.CompactTextString(m) }
func (*GetCacheResponse) ProtoMessage()    {}
func (*GetCacheResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{66}
}
func (m *GetCacheResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetCacheResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetCacheResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetCacheResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetCacheResponse.Merge(m, src)
}
func (m *GetCacheResponse) XXX_Size() int {
	return m.Size()
}
func (m *GetCacheResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_GetCacheResponse.DiscardUnknown(m)
}

var xxx_messageInfo_GetCacheResponse proto.InternalMessageInfo

func (m *GetCacheResponse) GetValue() *types.Any {
	if m != nil {
		return m.Value
	}
	return nil
}

type ClearCacheRequest struct {
	TagPrefix            string   `protobuf:"bytes,1,opt,name=tag_prefix,json=tagPrefix,proto3" json:"tag_prefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClearCacheRequest) Reset()         { *m = ClearCacheRequest{} }
func (m *ClearCacheRequest) String() string { return proto.CompactTextString(m) }
func (*ClearCacheRequest) ProtoMessage()    {}
func (*ClearCacheRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{67}
}
func (m *ClearCacheRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClearCacheRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClearCacheRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClearCacheRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClearCacheRequest.Merge(m, src)
}
func (m *ClearCacheRequest) XXX_Size() int {
	return m.Size()
}
func (m *ClearCacheRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClearCacheRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClearCacheRequest proto.InternalMessageInfo

func (m *ClearCacheRequest) GetTagPrefix() string {
	if m != nil {
		return m.TagPrefix
	}
	return ""
}

type ActivateAuthRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthRequest) Reset()         { *m = ActivateAuthRequest{} }
func (m *ActivateAuthRequest) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthRequest) ProtoMessage()    {}
func (*ActivateAuthRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{68}
}
func (m *ActivateAuthRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthRequest.Merge(m, src)
}
func (m *ActivateAuthRequest) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthRequest proto.InternalMessageInfo

type ActivateAuthResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivateAuthResponse) Reset()         { *m = ActivateAuthResponse{} }
func (m *ActivateAuthResponse) String() string { return proto.CompactTextString(m) }
func (*ActivateAuthResponse) ProtoMessage()    {}
func (*ActivateAuthResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{69}
}
func (m *ActivateAuthResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivateAuthResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivateAuthResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivateAuthResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivateAuthResponse.Merge(m, src)
}
func (m *ActivateAuthResponse) XXX_Size() int {
	return m.Size()
}
func (m *ActivateAuthResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivateAuthResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ActivateAuthResponse proto.InternalMessageInfo

type RunLoadTestRequest struct {
	Spec                 string   `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Branch               *Branch  `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Seed                 int64    `protobuf:"varint,3,opt,name=seed,proto3" json:"seed,omitempty"`
	StateId              string   `protobuf:"bytes,4,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RunLoadTestRequest) Reset()         { *m = RunLoadTestRequest{} }
func (m *RunLoadTestRequest) String() string { return proto.CompactTextString(m) }
func (*RunLoadTestRequest) ProtoMessage()    {}
func (*RunLoadTestRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{70}
}
func (m *RunLoadTestRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunLoadTestRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunLoadTestRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunLoadTestRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLoadTestRequest.Merge(m, src)
}
func (m *RunLoadTestRequest) XXX_Size() int {
	return m.Size()
}
func (m *RunLoadTestRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLoadTestRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RunLoadTestRequest proto.InternalMessageInfo

func (m *RunLoadTestRequest) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *RunLoadTestRequest) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *RunLoadTestRequest) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *RunLoadTestRequest) GetStateId() string {
	if m != nil {
		return m.StateId
	}
	return ""
}

type RunLoadTestResponse struct {
	Spec                 string          `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
	Branch               *Branch         `protobuf:"bytes,2,opt,name=branch,proto3" json:"branch,omitempty"`
	Seed                 int64           `protobuf:"varint,3,opt,name=seed,proto3" json:"seed,omitempty"`
	Error                string          `protobuf:"bytes,4,opt,name=error,proto3" json:"error,omitempty"`
	Duration             *types.Duration `protobuf:"bytes,5,opt,name=duration,proto3" json:"duration,omitempty"`
	StateId              string          `protobuf:"bytes,6,opt,name=state_id,json=stateId,proto3" json:"state_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RunLoadTestResponse) Reset()         { *m = RunLoadTestResponse{} }
func (m *RunLoadTestResponse) String() string { return proto.CompactTextString(m) }
func (*RunLoadTestResponse) ProtoMessage()    {}
func (*RunLoadTestResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{71}
}
func (m *RunLoadTestResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RunLoadTestResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RunLoadTestResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RunLoadTestResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RunLoadTestResponse.Merge(m, src)
}
func (m *RunLoadTestResponse) XXX_Size() int {
	return m.Size()
}
func (m *RunLoadTestResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RunLoadTestResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RunLoadTestResponse proto.InternalMessageInfo

func (m *RunLoadTestResponse) GetSpec() string {
	if m != nil {
		return m.Spec
	}
	return ""
}

func (m *RunLoadTestResponse) GetBranch() *Branch {
	if m != nil {
		return m.Branch
	}
	return nil
}

func (m *RunLoadTestResponse) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *RunLoadTestResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *RunLoadTestResponse) GetDuration() *types.Duration {
	if m != nil {
		return m.Duration
	}
	return nil
}

func (m *RunLoadTestResponse) GetStateId() string {
	if m != nil {
		return m.StateId
	}
	return ""
}

type ObjectStorageEgress struct {
	Url                  string   `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ObjectStorageEgress) Reset()         { *m = ObjectStorageEgress{} }
func (m *ObjectStorageEgress) String() string { return proto.CompactTextString(m) }
func (*ObjectStorageEgress) ProtoMessage()    {}
func (*ObjectStorageEgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{72}
}
func (m *ObjectStorageEgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectStorageEgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectStorageEgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectStorageEgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectStorageEgress.Merge(m, src)
}
func (m *ObjectStorageEgress) XXX_Size() int {
	return m.Size()
}
func (m *ObjectStorageEgress) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectStorageEgress.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectStorageEgress proto.InternalMessageInfo

func (m *ObjectStorageEgress) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

type SQLDatabaseEgress struct {
	Url                  string                        `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	FileFormat           *SQLDatabaseEgress_FileFormat `protobuf:"bytes,2,opt,name=file_format,json=fileFormat,proto3" json:"file_format,omitempty"`
	Secret               *SQLDatabaseEgress_Secret     `protobuf:"bytes,3,opt,name=secret,proto3" json:"secret,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *SQLDatabaseEgress) Reset()         { *m = SQLDatabaseEgress{} }
func (m *SQLDatabaseEgress) String() string { return proto.CompactTextString(m) }
func (*SQLDatabaseEgress) ProtoMessage()    {}
func (*SQLDatabaseEgress) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{73}
}
func (m *SQLDatabaseEgress) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLDatabaseEgress) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SQLDatabaseEgress.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SQLDatabaseEgress) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLDatabaseEgress.Merge(m, src)
}
func (m *SQLDatabaseEgress) XXX_Size() int {
	return m.Size()
}
func (m *SQLDatabaseEgress) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLDatabaseEgress.DiscardUnknown(m)
}

var xxx_messageInfo_SQLDatabaseEgress proto.InternalMessageInfo

func (m *SQLDatabaseEgress) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *SQLDatabaseEgress) GetFileFormat() *SQLDatabaseEgress_FileFormat {
	if m != nil {
		return m.FileFormat
	}
	return nil
}

func (m *SQLDatabaseEgress) GetSecret() *SQLDatabaseEgress_Secret {
	if m != nil {
		return m.Secret
	}
	return nil
}

type SQLDatabaseEgress_FileFormat struct {
	Type                 SQLDatabaseEgress_FileFormat_Type `protobuf:"varint,1,opt,name=type,proto3,enum=pfs_v2.SQLDatabaseEgress_FileFormat_Type" json:"type,omitempty"`
	Columns              []string                          `protobuf:"bytes,2,rep,name=columns,proto3" json:"columns,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                          `json:"-"`
	XXX_unrecognized     []byte                            `json:"-"`
	XXX_sizecache        int32                             `json:"-"`
}

func (m *SQLDatabaseEgress_FileFormat) Reset()         { *m = SQLDatabaseEgress_FileFormat{} }
func (m *SQLDatabaseEgress_FileFormat) String() string { return proto.CompactTextString(m) }
func (*SQLDatabaseEgress_FileFormat) ProtoMessage()    {}
func (*SQLDatabaseEgress_FileFormat) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{73, 0}
}
func (m *SQLDatabaseEgress_FileFormat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLDatabaseEgress_FileFormat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SQLDatabaseEgress_FileFormat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SQLDatabaseEgress_FileFormat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLDatabaseEgress_FileFormat.Merge(m, src)
}
func (m *SQLDatabaseEgress_FileFormat) XXX_Size() int {
	return m.Size()
}
func (m *SQLDatabaseEgress_FileFormat) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLDatabaseEgress_FileFormat.DiscardUnknown(m)
}

var xxx_messageInfo_SQLDatabaseEgress_FileFormat proto.InternalMessageInfo

func (m *SQLDatabaseEgress_FileFormat) GetType() SQLDatabaseEgress_FileFormat_Type {
	if m != nil {
		return m.Type
	}
	return SQLDatabaseEgress_FileFormat_UNKNOWN
}

func (m *SQLDatabaseEgress_FileFormat) GetColumns() []string {
	if m != nil {
		return m.Columns
	}
	return nil
}

type SQLDatabaseEgress_Secret struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Key                  string   `protobuf:"bytes,2,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SQLDatabaseEgress_Secret) Reset()         { *m = SQLDatabaseEgress_Secret{} }
func (m *SQLDatabaseEgress_Secret) String() string { return proto.CompactTextString(m) }
func (*SQLDatabaseEgress_Secret) ProtoMessage()    {}
func (*SQLDatabaseEgress_Secret) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{73, 1}
}
func (m *SQLDatabaseEgress_Secret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SQLDatabaseEgress_Secret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SQLDatabaseEgress_Secret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SQLDatabaseEgress_Secret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SQLDatabaseEgress_Secret.Merge(m, src)
}
func (m *SQLDatabaseEgress_Secret) XXX_Size() int {
	return m.Size()
}
func (m *SQLDatabaseEgress_Secret) XXX_DiscardUnknown() {
	xxx_messageInfo_SQLDatabaseEgress_Secret.DiscardUnknown(m)
}

var xxx_messageInfo_SQLDatabaseEgress_Secret proto.InternalMessageInfo

func (m *SQLDatabaseEgress_Secret) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SQLDatabaseEgress_Secret) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type EgressRequest struct {
	Commit *Commit `protobuf:"bytes,1,opt,name=commit,proto3" json:"commit,omitempty"`
	// Types that are valid to be assigned to Target:
	//
	//	*EgressRequest_ObjectStorage
	//	*EgressRequest_SqlDatabase
	Target               isEgressRequest_Target `protobuf_oneof:"target"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *EgressRequest) Reset()         { *m = EgressRequest{} }
func (m *EgressRequest) String() string { return proto.CompactTextString(m) }
func (*EgressRequest) ProtoMessage()    {}
func (*EgressRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{74}
}
func (m *EgressRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressRequest.Merge(m, src)
}
func (m *EgressRequest) XXX_Size() int {
	return m.Size()
}
func (m *EgressRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EgressRequest proto.InternalMessageInfo

type isEgressRequest_Target interface {
	isEgressRequest_Target()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EgressRequest_ObjectStorage struct {
	ObjectStorage *ObjectStorageEgress `protobuf:"bytes,2,opt,name=object_storage,json=objectStorage,proto3,oneof" json:"object_storage,omitempty"`
}
type EgressRequest_SqlDatabase struct {
	SqlDatabase *SQLDatabaseEgress `protobuf:"bytes,3,opt,name=sql_database,json=sqlDatabase,proto3,oneof" json:"sql_database,omitempty"`
}

func (*EgressRequest_ObjectStorage) isEgressRequest_Target() {}
func (*EgressRequest_SqlDatabase) isEgressRequest_Target()   {}

func (m *EgressRequest) GetTarget() isEgressRequest_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *EgressRequest) GetCommit() *Commit {
	if m != nil {
		return m.Commit
	}
	return nil
}

func (m *EgressRequest) GetObjectStorage() *ObjectStorageEgress {
	if x, ok := m.GetTarget().(*EgressRequest_ObjectStorage); ok {
		return x.ObjectStorage
	}
	return nil
}

func (m *EgressRequest) GetSqlDatabase() *SQLDatabaseEgress {
	if x, ok := m.GetTarget().(*EgressRequest_SqlDatabase); ok {
		return x.SqlDatabase
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EgressRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EgressRequest_ObjectStorage)(nil),
		(*EgressRequest_SqlDatabase)(nil),
	}
}

type EgressResponse struct {
	// Types that are valid to be assigned to Result:
	//
	//	*EgressResponse_ObjectStorage
	//	*EgressResponse_SqlDatabase
	Result               isEgressResponse_Result `protobuf_oneof:"result"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *EgressResponse) Reset()         { *m = EgressResponse{} }
func (m *EgressResponse) String() string { return proto.CompactTextString(m) }
func (*EgressResponse) ProtoMessage()    {}
func (*EgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{75}
}
func (m *EgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressResponse.Merge(m, src)
}
func (m *EgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *EgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EgressResponse proto.InternalMessageInfo

type isEgressResponse_Result interface {
	isEgressResponse_Result()
	MarshalTo([]byte) (int, error)
	Size() int
}

type EgressResponse_ObjectStorage struct {
	ObjectStorage *EgressResponse_ObjectStorageResult `protobuf:"bytes,1,opt,name=object_storage,json=objectStorage,proto3,oneof" json:"object_storage,omitempty"`
}
type EgressResponse_SqlDatabase struct {
	SqlDatabase *EgressResponse_SQLDatabaseResult `protobuf:"bytes,2,opt,name=sql_database,json=sqlDatabase,proto3,oneof" json:"sql_database,omitempty"`
}

func (*EgressResponse_ObjectStorage) isEgressResponse_Result() {}
func (*EgressResponse_SqlDatabase) isEgressResponse_Result()   {}

func (m *EgressResponse) GetResult() isEgressResponse_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *EgressResponse) GetObjectStorage() *EgressResponse_ObjectStorageResult {
	if x, ok := m.GetResult().(*EgressResponse_ObjectStorage); ok {
		return x.ObjectStorage
	}
	return nil
}

func (m *EgressResponse) GetSqlDatabase() *EgressResponse_SQLDatabaseResult {
	if x, ok := m.GetResult().(*EgressResponse_SqlDatabase); ok {
		return x.SqlDatabase
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*EgressResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*EgressResponse_ObjectStorage)(nil),
		(*EgressResponse_SqlDatabase)(nil),
	}
}

type EgressResponse_ObjectStorageResult struct {
	BytesWritten         int64    `protobuf:"varint,1,opt,name=bytes_written,json=bytesWritten,proto3" json:"bytes_written,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EgressResponse_ObjectStorageResult) Reset()         { *m = EgressResponse_ObjectStorageResult{} }
func (m *EgressResponse_ObjectStorageResult) String() string { return proto.CompactTextString(m) }
func (*EgressResponse_ObjectStorageResult) ProtoMessage()    {}
func (*EgressResponse_ObjectStorageResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{75, 0}
}
func (m *EgressResponse_ObjectStorageResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressResponse_ObjectStorageResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressResponse_ObjectStorageResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressResponse_ObjectStorageResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressResponse_ObjectStorageResult.Merge(m, src)
}
func (m *EgressResponse_ObjectStorageResult) XXX_Size() int {
	return m.Size()
}
func (m *EgressResponse_ObjectStorageResult) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressResponse_ObjectStorageResult.DiscardUnknown(m)
}

var xxx_messageInfo_EgressResponse_ObjectStorageResult proto.InternalMessageInfo

func (m *EgressResponse_ObjectStorageResult) GetBytesWritten() int64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

type EgressResponse_SQLDatabaseResult struct {
	RowsWritten          map[string]int64 `protobuf:"bytes,1,rep,name=rows_written,json=rowsWritten,proto3" json:"rows_written,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *EgressResponse_SQLDatabaseResult) Reset()         { *m = EgressResponse_SQLDatabaseResult{} }
func (m *EgressResponse_SQLDatabaseResult) String() string { return proto.CompactTextString(m) }
func (*EgressResponse_SQLDatabaseResult) ProtoMessage()    {}
func (*EgressResponse_SQLDatabaseResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_21a7b2476cbc6216, []int{75, 1}
}
func (m *EgressResponse_SQLDatabaseResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EgressResponse_SQLDatabaseResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EgressResponse_SQLDatabaseResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EgressResponse_SQLDatabaseResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EgressResponse_SQLDatabaseResult.Merge(m, src)
}
func (m *EgressResponse_SQLDatabaseResult) XXX_Size() int {
	return m.Size()
}
func (m *EgressResponse_SQLDatabaseResult) XXX_DiscardUnknown() {
	xxx_messageInfo_EgressResponse_SQLDatabaseResult.DiscardUnknown(m)
}

var xxx_messageInfo_EgressResponse_SQLDatabaseResult proto.InternalMessageInfo

func (m *EgressResponse_SQLDatabaseResult) GetRowsWritten() map[string]int64 {
	if m != nil {
		return m.RowsWritten
	}
	return nil
}

func init() {
	proto.RegisterEnum("pfs_v2.OriginKind", OriginKind_name, OriginKind_value)
	proto.RegisterEnum("pfs_v2.FileType", FileType_name, FileType_value)
	proto.RegisterEnum("pfs_v2.CommitState", CommitState_name, CommitState_value)
	proto.RegisterEnum("pfs_v2.Delimiter", Delimiter_name, Delimiter_value)
	proto.RegisterEnum("pfs_v2.SQLDatabaseEgress_FileFormat_Type", SQLDatabaseEgress_FileFormat_Type_name, SQLDatabaseEgress_FileFormat_Type_value)
	proto.RegisterType((*Repo)(nil), "pfs_v2.Repo")
	proto.RegisterType((*Branch)(nil), "pfs_v2.Branch")
	proto.RegisterType((*File)(nil), "pfs_v2.File")
	proto.RegisterType((*RepoInfo)(nil), "pfs_v2.RepoInfo")
	proto.RegisterType((*RepoInfo_Details)(nil), "pfs_v2.RepoInfo.Details")
	proto.RegisterType((*AuthInfo)(nil), "pfs_v2.AuthInfo")
	proto.RegisterType((*BranchInfo)(nil), "pfs_v2.BranchInfo")
	proto.RegisterType((*Trigger)(nil), "pfs_v2.Trigger")
	proto.RegisterType((*CommitOrigin)(nil), "pfs_v2.CommitOrigin")
	proto.RegisterType((*Commit)(nil), "pfs_v2.Commit")
	proto.RegisterType((*CommitInfo)(nil), "pfs_v2.CommitInfo")
	proto.RegisterType((*CommitInfo_Details)(nil), "pfs_v2.CommitInfo.Details")
	proto.RegisterType((*CommitSet)(nil), "pfs_v2.CommitSet")
	proto.RegisterType((*CommitSetInfo)(nil), "pfs_v2.CommitSetInfo")
	proto.RegisterType((*FileInfo)(nil), "pfs_v2.FileInfo")
	proto.RegisterType((*Project)(nil), "pfs_v2.Project")
	proto.RegisterType((*ProjectInfo)(nil), "pfs_v2.ProjectInfo")
	proto.RegisterType((*CreateRepoRequest)(nil), "pfs_v2.CreateRepoRequest")
	proto.RegisterType((*InspectRepoRequest)(nil), "pfs_v2.InspectRepoRequest")
	proto.RegisterType((*ListRepoRequest)(nil), "pfs_v2.ListRepoRequest")
	proto.RegisterType((*DeleteRepoRequest)(nil), "pfs_v2.DeleteRepoRequest")
	proto.RegisterType((*DeleteReposRequest)(nil), "pfs_v2.DeleteReposRequest")
	proto.RegisterType((*DeleteReposResponse)(nil), "pfs_v2.DeleteReposResponse")
	proto.RegisterType((*StartCommitRequest)(nil), "pfs_v2.StartCommitRequest")
	proto.RegisterType((*FinishCommitRequest)(nil), "pfs_v2.FinishCommitRequest")
	proto.RegisterType((*InspectCommitRequest)(nil), "pfs_v2.InspectCommitRequest")
	proto.RegisterType((*ListCommitRequest)(nil), "pfs_v2.ListCommitRequest")
	proto.RegisterType((*InspectCommitSetRequest)(nil), "pfs_v2.InspectCommitSetRequest")
	proto.RegisterType((*ListCommitSetRequest)(nil), "pfs_v2.ListCommitSetRequest")
	proto.RegisterType((*SquashCommitSetRequest)(nil), "pfs_v2.SquashCommitSetRequest")
	proto.RegisterType((*DropCommitSetRequest)(nil), "pfs_v2.DropCommitSetRequest")
	proto.RegisterType((*SubscribeCommitRequest)(nil), "pfs_v2.SubscribeCommitRequest")
	proto.RegisterType((*ClearCommitRequest)(nil), "pfs_v2.ClearCommitRequest")
	proto.RegisterType((*CreateBranchRequest)(nil), "pfs_v2.CreateBranchRequest")
	proto.RegisterType((*FindCommitsRequest)(nil), "pfs_v2.FindCommitsRequest")
	proto.RegisterType((*FindCommitsResponse)(nil), "pfs_v2.FindCommitsResponse")
	proto.RegisterType((*InspectBranchRequest)(nil), "pfs_v2.InspectBranchRequest")
	proto.RegisterType((*ListBranchRequest)(nil), "pfs_v2.ListBranchRequest")
	proto.RegisterType((*DeleteBranchRequest)(nil), "pfs_v2.DeleteBranchRequest")
	proto.RegisterType((*CreateProjectRequest)(nil), "pfs_v2.CreateProjectRequest")
	proto.RegisterType((*InspectProjectRequest)(nil), "pfs_v2.InspectProjectRequest")
	proto.RegisterType((*ListProjectRequest)(nil), "pfs_v2.ListProjectRequest")
	proto.RegisterType((*DeleteProjectRequest)(nil), "pfs_v2.DeleteProjectRequest")
	proto.RegisterType((*AddFile)(nil), "pfs_v2.AddFile")
	proto.RegisterType((*AddFile_URLSource)(nil), "pfs_v2.AddFile.URLSource")
	proto.RegisterType((*DeleteFile)(nil), "pfs_v2.DeleteFile")
	proto.RegisterType((*CopyFile)(nil), "pfs_v2.CopyFile")
	proto.RegisterType((*ModifyFileRequest)(nil), "pfs_v2.ModifyFileRequest")
	proto.RegisterType((*GetFileRequest)(nil), "pfs_v2.GetFileRequest")
	proto.RegisterType((*InspectFileRequest)(nil), "pfs_v2.InspectFileRequest")
	proto.RegisterType((*ListFileRequest)(nil), "pfs_v2.ListFileRequest")
	proto.RegisterType((*WalkFileRequest)(nil), "pfs_v2.WalkFileRequest")
	proto.RegisterType((*GlobFileRequest)(nil), "pfs_v2.GlobFileRequest")
	proto.RegisterType((*DiffFileRequest)(nil), "pfs_v2.DiffFileRequest")
	proto.RegisterType((*DiffFileResponse)(nil), "pfs_v2.DiffFileResponse")
	proto.RegisterType((*FsckRequest)(nil), "pfs_v2.FsckRequest")
	proto.RegisterType((*FsckResponse)(nil), "pfs_v2.FsckResponse")
	proto.RegisterType((*CreateFileSetResponse)(nil), "pfs_v2.CreateFileSetResponse")
	proto.RegisterType((*GetFileSetRequest)(nil), "pfs_v2.GetFileSetRequest")
	proto.RegisterType((*AddFileSetRequest)(nil), "pfs_v2.AddFileSetRequest")
	proto.RegisterType((*RenewFileSetRequest)(nil), "pfs_v2.RenewFileSetRequest")
	proto.RegisterType((*ComposeFileSetRequest)(nil), "pfs_v2.ComposeFileSetRequest")
	proto.RegisterType((*ShardFileSetRequest)(nil), "pfs_v2.ShardFileSetRequest")
	proto.RegisterType((*PathRange)(nil), "pfs_v2.PathRange")
	proto.RegisterType((*ShardFileSetResponse)(nil), "pfs_v2.ShardFileSetResponse")
	proto.RegisterType((*CheckStorageRequest)(nil), "pfs_v2.CheckStorageRequest")
	proto.RegisterType((*CheckStorageResponse)(nil), "pfs_v2.CheckStorageResponse")
	proto.RegisterType((*PutCacheRequest)(nil), "pfs_v2.PutCacheRequest")
	proto.RegisterType((*GetCacheRequest)(nil), "pfs_v2.GetCacheRequest")
	proto.RegisterType((*GetCacheResponse)(nil), "pfs_v2.GetCacheResponse")
	proto.RegisterType((*ClearCacheRequest)(nil), "pfs_v2.ClearCacheRequest")
	proto.RegisterType((*ActivateAuthRequest)(nil), "pfs_v2.ActivateAuthRequest")
	proto.RegisterType((*ActivateAuthResponse)(nil), "pfs_v2.ActivateAuthResponse")
	proto.RegisterType((*RunLoadTestRequest)(nil), "pfs_v2.RunLoadTestRequest")
	proto.RegisterType((*RunLoadTestResponse)(nil), "pfs_v2.RunLoadTestResponse")
	proto.RegisterType((*ObjectStorageEgress)(nil), "pfs_v2.ObjectStorageEgress")
	proto.RegisterType((*SQLDatabaseEgress)(nil), "pfs_v2.SQLDatabaseEgress")
	proto.RegisterType((*SQLDatabaseEgress_FileFormat)(nil), "pfs_v2.SQLDatabaseEgress.FileFormat")
	proto.RegisterType((*SQLDatabaseEgress_Secret)(nil), "pfs_v2.SQLDatabaseEgress.Secret")
	proto.RegisterType((*EgressRequest)(nil), "pfs_v2.EgressRequest")
	proto.RegisterType((*EgressResponse)(nil), "pfs_v2.EgressResponse")
	proto.RegisterType((*EgressResponse_ObjectStorageResult)(nil), "pfs_v2.EgressResponse.ObjectStorageResult")
	proto.RegisterType((*EgressResponse_SQLDatabaseResult)(nil), "pfs_v2.EgressResponse.SQLDatabaseResult")
	proto.RegisterMapType((map[string]int64)(nil), "pfs_v2.EgressResponse.SQLDatabaseResult.RowsWrittenEntry")
}

func init() { proto.RegisterFile("pfs/pfs.proto", fileDescriptor_21a7b2476cbc6216) }

var fileDescriptor_21a7b2476cbc6216 = []byte{
	// 4026 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x3a, 0x4d, 0x73, 0xdc, 0x46,
	0x76, 0xc4, 0x60, 0x34, 0x1f, 0x6f, 0x86, 0xe4, 0xb0, 0x49, 0xd1, 0xe3, 0x91, 0x25, 0xab, 0xb0,
	0x2e, 0x59, 0x92, 0xbd, 0xa4, 0x8a, 0x5a, 0xc9, 0xf6, 0x2a, 0xd6, 0xd6, 0x90, 0x1c, 0x8a, 0xd4,
	0x07, 0x29, 0x63, 0x28, 0x2b, 0x9b, 0x6c, 0x6a, 0x0a, 0x04, 0x7a, 0x48, 0x2c, 0x31, 0x00, 0x0c,
	0x60, 0xc4, 0x70, 0xb7, 0x92, 0x1c, 0x52, 0x49, 0x0e, 0xa9, 0xe4, 0x07, 0xe4, 0x92, 0x5c, 0x72,
	0x4d, 0x65, 0xcf, 0x39, 0x26, 0x55, 0xd9, 0x4b, 0xaa, 0xf2, 0x13, 0x52, 0x3e, 0xe5, 0x9c, 0x5c,
	0x73, 0x48, 0xf5, 0x17, 0xd0, 0xf8, 0x98, 0x0f, 0xca, 0x7b, 0x21, 0xd1, 0xdd, 0xaf, 0x5f, 0xbf,
	0x7e, 0xfd, 0xbe, 0xdf, 0xc0, 0xa2, 0x3f, 0x0c, 0x37, 0xfd, 0x61, 0xb8, 0xe1, 0x07, 0x5e, 0xe4,
	0xa1, 0x8a, 0x3f, 0x0c, 0x07, 0xef, 0xb6, 0x3a, 0x37, 0x4e, 0x3d, 0xef, 0xd4, 0xc1, 0x9b, 0x74,
	0xf6, 0x64, 0x3c, 0xdc, 0xc4, 0x23, 0x3f, 0xba, 0x64, 0x40, 0x9d, 0x8f, 0xb3, 0x8b, 0x91, 0x3d,
	0xc2, 0x61, 0x64, 0x8c, 0x7c, 0x0e, 0x70, 0x2b, 0x0b, 0x70, 0x11, 0x18, 0xbe, 0x8f, 0x83, 0x70,
	0xd2, 0xba, 0x35, 0x0e, 0x8c, 0xc8, 0xf6, 0x5c, 0xbe, 0xfe, 0x61, 0x76, 0xdd, 0x70, 0xc5, 0xd9,
	0xcb, 0xc6, 0x38, 0x3a, 0xdb, 0x24, 0x7f, 0xc4, 0x44, 0x64, 0x84, 0xe7, 0x9b, 0xe4, 0x0f, 0x9b,
	0xd0, 0x7e, 0x0e, 0x65, 0x1d, 0xfb, 0x1e, 0x42, 0x50, 0x76, 0x8d, 0x11, 0x6e, 0x2b, 0xb7, 0x95,
	0xbb, 0x75, 0x9d, 0x7e, 0x93, 0xb9, 0xe8, 0xd2, 0xc7, 0xed, 0x12, 0x9b, 0x23, 0xdf, 0xe8, 0x1e,
	0x54, 0xfd, 0xc0, 0xfb, 0x25, 0x36, 0xa3, 0xb6, 0x7a, 0x5b, 0xb9, 0xdb, 0xd8, 0x5a, 0xde, 0x60,
	0x4c, 0xd8, 0x78, 0xcd, 0xa6, 0x75, 0xb1, 0xae, 0x3d, 0x85, 0xca, 0x76, 0x60, 0xb8, 0xe6, 0x19,
	0xba, 0x0d, 0xe5, 0x00, 0xfb, 0x1e, 0x45, 0xde, 0xd8, 0x6a, 0x8a, 0x1d, 0xe4, 0x60, 0x9d, 0xae,
	0xc4, 0xc7, 0x97, 0x92, 0xe3, 0xb5, 0xdf, 0x87, 0xf2, 0x9e, 0xed, 0x60, 0x74, 0x07, 0x2a, 0xa6,
	0x37, 0x1a, 0xd9, 0x11, 0xdf, 0xbf, 0x24, 0xf6, 0xef, 0xd0, 0x59, 0x9d, 0xaf, 0x12, 0x1c, 0xbe,
	0x11, 0x9d, 0x09, 0x1c, 0xe4, 0x1b, 0xad, 0xc1, 0x35, 0xcb, 0x88, 0xc6, 0x23, 0x4a, 0x6c, 0x5d,
	0x67, 0x03, 0xed, 0x7f, 0x4a, 0x50, 0x23, 0x87, 0x1f, 0xb8, 0x43, 0x6f, 0x0e, 0xe2, 0x7e, 0x02,
	0x55, 0x33, 0xc0, 0x46, 0x84, 0x2d, 0x8a, 0xbb, 0xb1, 0xd5, 0xd9, 0x60, 0x2c, 0xdf, 0x10, 0x2c,
	0xdf, 0x38, 0x16, 0x6f, 0xaa, 0x0b, 0x50, 0xf4, 0x10, 0xd6, 0x43, 0xfb, 0x57, 0x78, 0x70, 0x72,
	0x19, 0xe1, 0x70, 0x30, 0x26, 0x2f, 0x3a, 0x38, 0xf1, 0xc6, 0xae, 0x45, 0x69, 0x51, 0xf5, 0x55,
	0xb2, 0xba, 0x4d, 0x16, 0xdf, 0x90, 0xb5, 0x6d, 0xb2, 0x84, 0x6e, 0x43, 0xc3, 0xc2, 0xa1, 0x19,
	0xd8, 0x3e, 0x79, 0xe0, 0x76, 0x99, 0x52, 0x2d, 0x4f, 0xa1, 0xfb, 0x50, 0x3b, 0xa1, 0x5c, 0xc5,
	0x61, 0xfb, 0xda, 0x6d, 0x55, 0xe6, 0x07, 0xe3, 0xb6, 0x1e, 0xaf, 0xa3, 0x1f, 0x43, 0x9d, 0xbc,
	0xfd, 0xc0, 0x76, 0x87, 0x5e, 0xbb, 0x42, 0x49, 0x6f, 0x09, 0xe0, 0xee, 0x38, 0x3a, 0x23, 0xf7,
	0xd7, 0x6b, 0x06, 0xff, 0x42, 0x5b, 0x50, 0xb5, 0x70, 0x64, 0xd8, 0x4e, 0xd8, 0xae, 0x52, 0xe0,
	0xb6, 0xcc, 0x0c, 0x02, 0xb2, 0xb1, 0xcb, 0xd6, 0x75, 0x01, 0xd8, 0xb9, 0x0b, 0x55, 0x3e, 0x87,
	0x6e, 0x02, 0x24, 0x17, 0xa6, 0xec, 0x54, 0xf5, 0x7a, 0x7c, 0x49, 0xed, 0x2d, 0xd4, 0xc4, 0x99,
	0xe8, 0x11, 0x34, 0x7c, 0x1c, 0x8c, 0xec, 0x30, 0xb4, 0x3d, 0x97, 0xc0, 0xaa, 0x77, 0x97, 0xb6,
	0x56, 0x37, 0x28, 0xb1, 0x44, 0x94, 0xe2, 0x35, 0x5d, 0x86, 0x23, 0xaf, 0x19, 0x78, 0x0e, 0x0e,
	0xdb, 0xa5, 0xdb, 0x2a, 0x79, 0x4d, 0x3a, 0xd0, 0xfe, 0xa1, 0x04, 0xc0, 0xae, 0x4e, 0x71, 0xdf,
	0x81, 0x0a, 0x63, 0x40, 0x56, 0x5c, 0x38, 0x7b, 0xf8, 0x2a, 0xd2, 0xa0, 0x7c, 0x86, 0x0d, 0xf1,
	0xa4, 0x59, 0xa1, 0xa2, 0x6b, 0x68, 0x03, 0xc0, 0x0f, 0xbc, 0x77, 0xd8, 0x35, 0x5c, 0x13, 0xb7,
	0xd5, 0x42, 0x76, 0x4b, 0x10, 0x04, 0x3e, 0x1c, 0x9f, 0x08, 0xf8, 0x72, 0x31, 0x7c, 0x02, 0x81,
	0x9e, 0xc0, 0x8a, 0x65, 0x07, 0xd8, 0x8c, 0x06, 0xd2, 0x31, 0xc5, 0xaf, 0xda, 0x62, 0x80, 0xaf,
	0x93, 0xc3, 0xee, 0x41, 0x35, 0x0a, 0xec, 0xd3, 0x53, 0x1c, 0xf0, 0xb7, 0x8d, 0x55, 0xf1, 0x98,
	0x4d, 0xeb, 0x62, 0x5d, 0xfb, 0x53, 0xa8, 0xf2, 0x39, 0xb4, 0x9e, 0x62, 0x4f, 0x3d, 0x66, 0x47,
	0x0b, 0x54, 0xc3, 0x71, 0x28, 0x37, 0x6a, 0x3a, 0xf9, 0x44, 0x37, 0xa0, 0x6e, 0x06, 0x9e, 0x3b,
	0x08, 0x7d, 0x6c, 0x72, 0xfd, 0xa9, 0x91, 0x89, 0xbe, 0x8f, 0x4d, 0xa2, 0x6c, 0xe4, 0x69, 0xb9,
	0x84, 0xd2, 0x6f, 0xd4, 0x86, 0x2a, 0x53, 0x45, 0x22, 0x99, 0xe4, 0xf5, 0xc5, 0x50, 0x7b, 0x0c,
	0x4d, 0xc6, 0xd7, 0xa3, 0xc0, 0x3e, 0xb5, 0x5d, 0x74, 0x07, 0xca, 0xe7, 0xb6, 0x6b, 0x51, 0x12,
	0x96, 0xb6, 0x90, 0xa0, 0x9b, 0xad, 0xbe, 0xb0, 0x5d, 0x4b, 0xa7, 0xeb, 0xda, 0x09, 0x54, 0xd8,
	0xbe, 0x58, 0x4b, 0xd5, 0x89, 0x5a, 0xba, 0x04, 0x25, 0xdb, 0xe2, 0xca, 0x5f, 0xb2, 0xad, 0x79,
	0xe5, 0x40, 0xfb, 0x9b, 0x0a, 0x00, 0x3b, 0x44, 0x88, 0xcf, 0x5c, 0xd6, 0xe6, 0x73, 0xa8, 0x78,
	0x94, 0x5c, 0x2e, 0x40, 0x6b, 0x69, 0x38, 0x76, 0x15, 0x9d, 0xc3, 0x64, 0xf5, 0x5a, 0xcd, 0xeb,
	0xf5, 0x43, 0x58, 0xf4, 0x8d, 0x00, 0xbb, 0xd1, 0x80, 0x1f, 0x5f, 0x2e, 0x3c, 0xbe, 0xc9, 0x80,
	0x38, 0x57, 0x1e, 0xc2, 0xa2, 0x79, 0x66, 0x3b, 0xd6, 0x20, 0xe1, 0xbb, 0x5a, 0xb4, 0x89, 0x02,
	0xb1, 0x41, 0x48, 0xcc, 0x59, 0x18, 0x19, 0x01, 0x31, 0x67, 0x95, 0xd9, 0xe6, 0x8c, 0x83, 0xa2,
	0x2f, 0xa1, 0x3e, 0xb4, 0x5d, 0x3b, 0x3c, 0xb3, 0xdd, 0x53, 0x6e, 0x1e, 0xa6, 0xed, 0x4b, 0x80,
	0xd1, 0x63, 0xa8, 0xb1, 0x01, 0xb6, 0xda, 0xb5, 0x99, 0x1b, 0x63, 0xd8, 0x62, 0xe5, 0x58, 0x2c,
	0xbc, 0x60, 0x5e, 0x39, 0xd6, 0xe0, 0x1a, 0x0e, 0x02, 0x2f, 0x68, 0x03, 0x33, 0xfc, 0x74, 0x30,
	0xc5, 0x26, 0x37, 0x26, 0xdb, 0xe4, 0x9f, 0x24, 0x66, 0xb1, 0xc9, 0xc9, 0x4f, 0x9d, 0x5e, 0x6c,
	0x18, 0xff, 0x59, 0x99, 0xd7, 0x32, 0xa2, 0x6d, 0x58, 0x36, 0xbd, 0x91, 0x6f, 0x98, 0x91, 0xed,
	0x9e, 0x0e, 0x48, 0x78, 0xc0, 0x65, 0xea, 0xc3, 0x1c, 0x9f, 0x76, 0xb9, 0xeb, 0xd7, 0x97, 0x92,
	0x1d, 0x84, 0x77, 0x04, 0xc7, 0x3b, 0xc3, 0xb1, 0x2d, 0x23, 0xc1, 0xa1, 0xce, 0xc4, 0x91, 0xec,
	0x20, 0x38, 0x9e, 0x97, 0x6b, 0xf5, 0x16, 0x68, 0x37, 0xa0, 0xce, 0xee, 0xd5, 0xc7, 0x11, 0x57,
	0x2a, 0x45, 0x28, 0x95, 0xe6, 0xc1, 0x62, 0xbc, 0x48, 0xd5, 0xe5, 0x01, 0x00, 0x93, 0xbd, 0x41,
	0x88, 0x85, 0xca, 0xac, 0xa4, 0xf9, 0xd3, 0xc7, 0x91, 0x5e, 0x37, 0x63, 0x94, 0x9f, 0x27, 0x56,
	0xa2, 0x44, 0x1f, 0x13, 0xe5, 0xd9, 0x99, 0x58, 0x8e, 0xdf, 0x2a, 0x50, 0x23, 0x51, 0x80, 0x70,
	0xd5, 0x43, 0xdb, 0xc1, 0x59, 0x57, 0x4d, 0xd6, 0x75, 0xba, 0x42, 0x3c, 0x1e, 0xf9, 0x3f, 0x88,
	0xe3, 0x96, 0xa5, 0xc4, 0xe3, 0x11, 0xb0, 0xe3, 0x4b, 0x1f, 0x13, 0x11, 0x63, 0x5f, 0x44, 0xa8,
	0xd9, 0x41, 0x44, 0x19, 0xd4, 0xd9, 0x42, 0x1d, 0x03, 0x67, 0x9e, 0xb4, 0x9c, 0x7d, 0x52, 0x04,
	0xe5, 0x33, 0x23, 0x3c, 0xa3, 0x76, 0xb0, 0xa9, 0xd3, 0x6f, 0xed, 0x26, 0x54, 0x79, 0x8c, 0x54,
	0x14, 0x6d, 0x69, 0xff, 0xa6, 0x40, 0x83, 0xaf, 0xd3, 0xcb, 0x4a, 0x91, 0x96, 0x32, 0x3d, 0xd2,
	0xca, 0x5a, 0x97, 0x52, 0xde, 0xba, 0xa4, 0x22, 0x01, 0x75, 0x66, 0x24, 0xf0, 0x15, 0x00, 0x0f,
	0x63, 0x06, 0x86, 0xb0, 0x44, 0xd3, 0x19, 0xc3, 0xa0, 0xbb, 0x91, 0xe6, 0xc1, 0xca, 0x0e, 0x1d,
	0x50, 0xd3, 0x8c, 0xbf, 0x1b, 0xe3, 0x30, 0x9a, 0x23, 0xc6, 0x9a, 0x7d, 0x85, 0x75, 0xa8, 0x8c,
	0x7d, 0xcb, 0x88, 0x98, 0x60, 0xd7, 0x74, 0x3e, 0xd2, 0x1e, 0x03, 0x3a, 0x70, 0x89, 0x8f, 0x8a,
	0xae, 0x74, 0xa2, 0xa6, 0xc3, 0xf2, 0x4b, 0x3b, 0x4c, 0x6d, 0x12, 0x01, 0xaf, 0x22, 0x05, 0xbc,
	0x9f, 0x41, 0x8d, 0xb3, 0x59, 0xc8, 0x6b, 0xee, 0x1d, 0x62, 0x00, 0xed, 0x05, 0xac, 0xec, 0x62,
	0x07, 0x5f, 0xf5, 0xf2, 0x6b, 0x70, 0x6d, 0xe8, 0x05, 0x26, 0xe6, 0xde, 0x97, 0x0d, 0x34, 0x1b,
	0x50, 0x82, 0x2c, 0x14, 0xd8, 0x64, 0x7a, 0x94, 0x19, 0xf4, 0x14, 0x23, 0x16, 0xae, 0x5e, 0x8d,
	0x5d, 0xbd, 0xf6, 0x15, 0xac, 0xa6, 0x8e, 0x0a, 0x7d, 0xcf, 0x0d, 0x31, 0xd2, 0xe0, 0x1a, 0xa1,
	0x4f, 0x1c, 0x94, 0x26, 0x9d, 0x2d, 0x69, 0x7f, 0xa9, 0x00, 0xea, 0x13, 0x1f, 0xc1, 0x4d, 0x31,
	0x27, 0xf3, 0x0e, 0x54, 0x98, 0xa7, 0x9a, 0xe4, 0x46, 0xd9, 0xea, 0x1c, 0xef, 0x9e, 0xf8, 0x71,
	0x75, 0xaa, 0x1f, 0xff, 0x6b, 0x05, 0x56, 0xf7, 0xa8, 0xef, 0xc8, 0x51, 0x32, 0x97, 0x43, 0x9f,
	0x4d, 0x49, 0xec, 0x53, 0x54, 0xd9, 0xa7, 0xc4, 0x3c, 0x2e, 0xcb, 0x8f, 0x77, 0x0a, 0x6b, 0x5c,
	0x2a, 0xdf, 0x8f, 0x9a, 0x4f, 0xa1, 0x7c, 0x61, 0xd8, 0x11, 0xb7, 0x61, 0xab, 0x19, 0x8b, 0x1a,
	0x11, 0xfd, 0xa2, 0x00, 0xda, 0x6f, 0x4a, 0xb0, 0x42, 0xe4, 0x38, 0x7d, 0xcc, 0x6c, 0x99, 0xd3,
	0xa0, 0x3c, 0x0c, 0xbc, 0xd1, 0xa4, 0xf0, 0x97, 0xac, 0xa1, 0x5b, 0x50, 0x8a, 0xbc, 0x2c, 0xdb,
	0x39, 0x44, 0x29, 0xf2, 0x88, 0x4a, 0xba, 0xe3, 0xd1, 0x09, 0x0e, 0xb8, 0x01, 0xe4, 0x23, 0x12,
	0x08, 0x06, 0xf8, 0x1d, 0x0e, 0x42, 0x4c, 0x0d, 0x60, 0x4d, 0x17, 0x43, 0x21, 0x7a, 0x95, 0x24,
	0xca, 0x7c, 0x08, 0x0d, 0x16, 0x23, 0x0d, 0x68, 0x44, 0x58, 0x9d, 0x18, 0x11, 0x82, 0x17, 0x7f,
	0xa3, 0xaf, 0xa1, 0xc9, 0xe3, 0x12, 0xe6, 0xea, 0x66, 0x87, 0x15, 0x0d, 0x0e, 0x4f, 0x66, 0xb4,
	0x01, 0x7c, 0x90, 0x7a, 0x1c, 0xe2, 0xa1, 0x38, 0xe3, 0xae, 0xee, 0xcf, 0x90, 0xf4, 0x52, 0x35,
	0xfe, 0x28, 0x5d, 0x58, 0x4b, 0xde, 0x44, 0xc2, 0x3e, 0xbf, 0x4d, 0xd7, 0x9e, 0xc3, 0x7a, 0xff,
	0xbb, 0xb1, 0x21, 0xa4, 0xf9, 0x87, 0x90, 0xa8, 0xed, 0xc3, 0xda, 0x6e, 0xe0, 0xf9, 0xbf, 0x03,
	0x4c, 0xff, 0xad, 0xc0, 0x7a, 0x7f, 0x7c, 0x42, 0x74, 0xe2, 0x04, 0x5f, 0x55, 0xe4, 0x92, 0xd4,
	0xa3, 0x94, 0x4a, 0x3d, 0x84, 0x28, 0xaa, 0x53, 0x44, 0xf1, 0x1e, 0x5c, 0x0b, 0x89, 0xd4, 0x53,
	0x49, 0x9b, 0xa0, 0x10, 0x0c, 0x42, 0xc8, 0xd8, 0xb5, 0x89, 0x32, 0x56, 0x99, 0x47, 0xc6, 0xb4,
	0xdf, 0x03, 0xb4, 0xe3, 0x60, 0x23, 0x78, 0x2f, 0xfd, 0xd5, 0xbe, 0x57, 0x60, 0x95, 0xf9, 0x41,
	0x6e, 0xa6, 0xf8, 0x7e, 0x91, 0x75, 0x2a, 0x53, 0xb2, 0xce, 0x3b, 0x29, 0x3e, 0x4d, 0xce, 0x60,
	0xaf, 0x9a, 0x9d, 0x4a, 0x09, 0x63, 0x79, 0x7a, 0xc2, 0x88, 0x3e, 0x81, 0x25, 0x17, 0x5f, 0x0c,
	0x24, 0xe9, 0x60, 0xec, 0x6c, 0xba, 0xf8, 0x22, 0x16, 0x0c, 0x6d, 0x04, 0x68, 0xcf, 0x76, 0x45,
	0x62, 0x21, 0xae, 0xf8, 0x09, 0x7d, 0xaa, 0x60, 0x12, 0x87, 0xd8, 0x22, 0xc9, 0x2e, 0x69, 0xa4,
	0x26, 0x95, 0x6c, 0x68, 0x5c, 0xf6, 0x9a, 0x97, 0x6d, 0x1c, 0x9b, 0x30, 0x99, 0x88, 0xc4, 0xa2,
	0xce, 0x06, 0xda, 0xbf, 0x32, 0x0b, 0x9f, 0x9c, 0xc7, 0xdd, 0xd4, 0x43, 0x68, 0x0e, 0x49, 0xa4,
	0x3e, 0x98, 0xf6, 0x32, 0xfb, 0x0b, 0x7a, 0x83, 0x42, 0xf1, 0xd4, 0x69, 0x1b, 0xd6, 0x1c, 0x23,
	0x24, 0x77, 0x33, 0x02, 0xf3, 0x0c, 0xc7, 0x9b, 0x4b, 0x13, 0x36, 0x23, 0x02, 0xdd, 0xe7, 0xc0,
	0x1c, 0xc7, 0x3d, 0x68, 0xf1, 0x38, 0x35, 0x46, 0xc3, 0x29, 0x5e, 0xe6, 0xf3, 0x62, 0xc3, 0x76,
	0x0d, 0x2a, 0x01, 0x0e, 0xc7, 0x4e, 0xa4, 0x3d, 0x8d, 0x3d, 0x43, 0x5a, 0x32, 0xe6, 0xcd, 0x57,
	0x8f, 0x98, 0xbd, 0x4f, 0x6f, 0x9e, 0xad, 0x7c, 0x92, 0x4d, 0x2e, 0xa5, 0x6c, 0xb2, 0xd6, 0x17,
	0xce, 0xff, 0xbd, 0xe8, 0x99, 0x10, 0xbc, 0xfc, 0x1a, 0xd6, 0x98, 0xf8, 0x0b, 0xc3, 0x76, 0x65,
	0x0b, 0xf8, 0x03, 0x42, 0xc2, 0x6d, 0xb8, 0xce, 0x59, 0xfc, 0xde, 0xa7, 0x6b, 0x6b, 0x80, 0x08,
	0x9b, 0xd3, 0x08, 0xb4, 0xb7, 0xb0, 0xc6, 0x78, 0xf5, 0xfe, 0xd7, 0x2a, 0xe6, 0xd7, 0xff, 0x29,
	0x50, 0xed, 0x5a, 0x16, 0x2d, 0x78, 0x8a, 0x42, 0xa6, 0x52, 0x54, 0xc8, 0x2c, 0x49, 0x85, 0x4c,
	0xb4, 0x09, 0x6a, 0x60, 0x5c, 0x70, 0xc3, 0x79, 0x23, 0xe7, 0xfe, 0x68, 0x2e, 0xf2, 0xad, 0xe1,
	0x8c, 0xf1, 0xfe, 0x82, 0x4e, 0x20, 0xd1, 0x8f, 0x41, 0x1d, 0x07, 0x0e, 0x57, 0xff, 0x0f, 0xe3,
	0x0c, 0x80, 0x1d, 0xbc, 0xf1, 0x46, 0x7f, 0xd9, 0xf7, 0xc6, 0x81, 0x49, 0xc1, 0xc7, 0x81, 0xd3,
	0xf9, 0x23, 0xa8, 0xc7, 0x73, 0xc4, 0xae, 0xbe, 0xd1, 0x5f, 0x72, 0xaa, 0xc8, 0x27, 0xfa, 0x08,
	0xea, 0x01, 0x36, 0xc7, 0x41, 0x68, 0xbf, 0x13, 0xd7, 0x49, 0x26, 0xc8, 0xfb, 0x99, 0x9e, 0x6b,
	0x8e, 0x83, 0x00, 0xbb, 0xe6, 0x25, 0x57, 0x0c, 0x79, 0x8a, 0x28, 0x45, 0x48, 0x71, 0x6b, 0x8f,
	0x01, 0x18, 0x5f, 0xaf, 0xc6, 0x00, 0xed, 0x97, 0x50, 0xdb, 0xf1, 0xfc, 0x4b, 0xba, 0xab, 0x05,
	0xaa, 0x15, 0x46, 0x82, 0x3e, 0x2b, 0x8c, 0x26, 0x30, 0xed, 0x16, 0xa8, 0x61, 0x60, 0x66, 0x2b,
	0x49, 0x34, 0x89, 0x24, 0x0b, 0x44, 0xaa, 0x0c, 0xdf, 0xc7, 0xae, 0xc5, 0x23, 0x3a, 0x3e, 0x22,
	0x26, 0x7d, 0xe5, 0x95, 0x67, 0xd9, 0x43, 0x7a, 0x9c, 0x78, 0xf9, 0x4d, 0x80, 0x10, 0x47, 0xb3,
	0x4c, 0x4f, 0x3d, 0xc4, 0xa2, 0x66, 0xf3, 0x39, 0xd4, 0x0c, 0xcb, 0x1a, 0xd0, 0x44, 0xb6, 0x94,
	0x96, 0x15, 0xfe, 0x0e, 0xfb, 0x0b, 0x7a, 0xd5, 0xe0, 0xb2, 0xf0, 0x88, 0x28, 0x01, 0x61, 0x0c,
	0xdb, 0xc0, 0x88, 0x8e, 0x5d, 0x57, 0xc2, 0xb3, 0xfd, 0x05, 0x1d, 0xac, 0x84, 0x83, 0x9b, 0x24,
	0xb1, 0xf5, 0x2f, 0xd9, 0xa6, 0x72, 0x3a, 0xdf, 0x13, 0x0c, 0xdb, 0x5f, 0xd0, 0x6b, 0x26, 0xff,
	0xde, 0xae, 0x40, 0xf9, 0xc4, 0xb3, 0x2e, 0xb5, 0xbf, 0x55, 0x60, 0xe9, 0x19, 0x8e, 0xe4, 0x1b,
	0xce, 0xce, 0xba, 0xb9, 0x64, 0x94, 0x12, 0xc9, 0x58, 0x87, 0x8a, 0x37, 0x1c, 0x12, 0xbf, 0xc1,
	0x8a, 0xdd, 0x7c, 0x44, 0x22, 0x0e, 0xf2, 0x9a, 0x83, 0xc0, 0x70, 0x4f, 0x05, 0x61, 0x71, 0xc4,
	0x41, 0x4c, 0xbf, 0x4e, 0x16, 0xf4, 0xba, 0x2f, 0x3e, 0xa5, 0xf4, 0xee, 0x4a, 0x34, 0x69, 0xff,
	0xa8, 0xb0, 0xfc, 0xee, 0x6a, 0x37, 0xf9, 0x12, 0x5a, 0xbe, 0x71, 0x6a, 0xbb, 0xb4, 0x40, 0xf2,
	0xca, 0x08, 0xce, 0x71, 0x50, 0x28, 0x28, 0x39, 0xa8, 0xab, 0xc7, 0xc2, 0xcf, 0xcb, 0xb5, 0x52,
	0x4b, 0xd5, 0xfe, 0x5e, 0x81, 0xe5, 0xb7, 0x86, 0x73, 0xfe, 0xc3, 0xe9, 0x2c, 0x5d, 0x91, 0x4e,
	0x75, 0x12, 0x9d, 0xe5, 0xb4, 0x7f, 0xf8, 0x0b, 0x05, 0x96, 0x9f, 0x39, 0xde, 0x89, 0x4c, 0xe1,
	0xbc, 0x69, 0x4c, 0x1b, 0xaa, 0xbe, 0x11, 0x45, 0x38, 0x10, 0xf6, 0x5b, 0x0c, 0x33, 0x92, 0xa0,
	0xce, 0x21, 0x09, 0x7f, 0x02, 0xcb, 0xbb, 0xf6, 0x70, 0x28, 0x93, 0xf1, 0x29, 0xd4, 0x48, 0x98,
	0x32, 0x91, 0x59, 0x55, 0x17, 0x5f, 0x50, 0x7d, 0xf8, 0x14, 0x6a, 0x9e, 0x93, 0x52, 0xba, 0x0c,
	0xa0, 0xe7, 0x30, 0x7d, 0x6b, 0x43, 0x35, 0x3c, 0x33, 0x1c, 0xc7, 0xbb, 0xe0, 0x3e, 0x45, 0x0c,
	0x35, 0x07, 0x5a, 0xc9, 0xf1, 0x3c, 0xf2, 0xf8, 0x2c, 0x77, 0x7e, 0xaa, 0xda, 0xc4, 0x4a, 0x59,
	0x82, 0x86, 0xcf, 0x72, 0x34, 0x14, 0x00, 0x73, 0x3a, 0xb4, 0xbf, 0x52, 0xa0, 0xb1, 0x17, 0x9a,
	0xe7, 0xe2, 0xa6, 0x2d, 0x50, 0x87, 0xf6, 0x1f, 0xd3, 0x43, 0x6a, 0x3a, 0xf9, 0x44, 0x8f, 0x60,
	0xf1, 0x57, 0xde, 0xe8, 0xc4, 0xc6, 0x83, 0xc8, 0x08, 0x4e, 0xf1, 0xe4, 0xc8, 0xa5, 0xc9, 0xc0,
	0x8e, 0x29, 0x14, 0xfa, 0x18, 0x80, 0x6f, 0x8b, 0x6b, 0x00, 0xc4, 0x3e, 0xb1, 0xb9, 0xae, 0xe3,
	0x6c, 0x2f, 0x01, 0xdf, 0x30, 0x30, 0xcf, 0xb0, 0x79, 0xae, 0x3d, 0x86, 0x26, 0x23, 0x84, 0xdf,
	0x59, 0xa2, 0xa4, 0xce, 0x28, 0x89, 0xf3, 0xe2, 0x92, 0x94, 0x17, 0x6b, 0x5f, 0xc0, 0x75, 0x16,
	0x01, 0x90, 0xfb, 0xd0, 0xa4, 0x83, 0x23, 0xb8, 0x05, 0x0d, 0x1a, 0xf9, 0x11, 0xb3, 0x19, 0x17,
	0x17, 0x69, 0x30, 0xd8, 0xc7, 0xd1, 0x81, 0xa5, 0x3d, 0x81, 0x15, 0x6e, 0x81, 0xa4, 0x54, 0x65,
	0xde, 0xb8, 0xfb, 0x0f, 0x61, 0x85, 0x5b, 0xd1, 0xab, 0x6f, 0xce, 0x52, 0x56, 0xca, 0x52, 0xf6,
	0x2d, 0xac, 0xea, 0x98, 0x3f, 0xa7, 0x84, 0x7e, 0xc6, 0x85, 0xd0, 0xc7, 0xd0, 0x88, 0x22, 0x67,
	0x10, 0x62, 0xd3, 0x73, 0xad, 0x90, 0xa2, 0x55, 0x75, 0x88, 0x22, 0xa7, 0xcf, 0x66, 0xb4, 0x08,
	0xae, 0xef, 0x78, 0x23, 0xdf, 0x0b, 0x71, 0x06, 0xf3, 0x6d, 0x68, 0x4a, 0x98, 0x59, 0x1d, 0xa6,
	0xae, 0x43, 0x8c, 0x3a, 0x9c, 0x89, 0x9b, 0x37, 0x65, 0x7c, 0x83, 0x37, 0x6c, 0x6b, 0xba, 0x18,
	0x6a, 0x8f, 0x60, 0xb5, 0x7f, 0x66, 0x04, 0xd6, 0xd5, 0x6e, 0xa3, 0x7d, 0x01, 0xf5, 0x58, 0x3d,
	0x69, 0xa0, 0xee, 0x5d, 0xe0, 0x80, 0x83, 0xb1, 0x01, 0x99, 0xa5, 0xb5, 0x75, 0x21, 0x10, 0x74,
	0x40, 0x92, 0xe2, 0xf4, 0x79, 0x5c, 0x1e, 0xee, 0x41, 0x25, 0x24, 0xf3, 0xa2, 0xcc, 0x54, 0x60,
	0x05, 0x38, 0x80, 0xf6, 0x6b, 0x58, 0xdd, 0x21, 0x42, 0xd9, 0x8f, 0xbc, 0xc0, 0x38, 0x95, 0xac,
	0xd1, 0x72, 0x80, 0x0d, 0x6b, 0x60, 0x9e, 0x8d, 0xdd, 0xf3, 0x81, 0x65, 0x44, 0x06, 0x57, 0x94,
	0x45, 0x32, 0xbd, 0x43, 0x66, 0x77, 0x8d, 0xc8, 0x20, 0xcc, 0x62, 0x20, 0x27, 0x58, 0x34, 0x6e,
	0x9a, 0x3a, 0xd0, 0xa9, 0x6d, 0x32, 0x43, 0x5b, 0x5e, 0x14, 0x00, 0xf3, 0x36, 0x6d, 0x53, 0xaf,
	0xd1, 0x89, 0x9e, 0x6b, 0x69, 0xbb, 0xb0, 0x96, 0x3e, 0x9c, 0xd3, 0xff, 0x39, 0x20, 0xb6, 0xc9,
	0x3b, 0x21, 0x01, 0xde, 0xc0, 0xf4, 0xc6, 0xbc, 0xec, 0xa5, 0xea, 0x2d, 0xba, 0x72, 0x44, 0x17,
	0x76, 0xc8, 0xbc, 0xf6, 0xe7, 0x0a, 0x2c, 0xbf, 0x1e, 0x47, 0x3b, 0x86, 0x79, 0x86, 0x25, 0xe5,
	0x3e, 0xc7, 0x97, 0x42, 0xa5, 0xce, 0xf1, 0x25, 0xba, 0x0f, 0xd7, 0xde, 0x91, 0xb8, 0x2d, 0x6e,
	0x2e, 0x65, 0x43, 0xbb, 0xae, 0x7b, 0xa9, 0x33, 0x90, 0x9c, 0x90, 0xa8, 0x39, 0x21, 0x69, 0x81,
	0x1a, 0x19, 0xa7, 0xbc, 0x57, 0x47, 0x3e, 0xb5, 0x1f, 0xc1, 0xf2, 0x33, 0x3c, 0x83, 0x08, 0xed,
	0x29, 0xb4, 0x12, 0x20, 0x7e, 0xd9, 0x98, 0x30, 0x65, 0x26, 0x61, 0xda, 0x16, 0xac, 0xb0, 0x0c,
	0x5a, 0x3e, 0xe6, 0x26, 0x40, 0x64, 0x9c, 0x0e, 0xfc, 0x00, 0x27, 0x56, 0xa4, 0x1e, 0x19, 0xa7,
	0xaf, 0xe9, 0x84, 0x76, 0x1d, 0x56, 0xbb, 0x66, 0x64, 0xbf, 0x33, 0x22, 0xdc, 0x1d, 0x47, 0x22,
	0x19, 0xd1, 0xd6, 0x61, 0x2d, 0x3d, 0xcd, 0xc8, 0xd1, 0xfe, 0x0c, 0x90, 0x3e, 0x76, 0x5f, 0x7a,
	0x86, 0x75, 0x8c, 0xc3, 0x48, 0xaa, 0xe3, 0xd2, 0xa6, 0x25, 0x8f, 0x1f, 0xc9, 0xf7, 0xdc, 0x49,
	0x35, 0xd9, 0x8b, 0xb1, 0x68, 0xd2, 0xd3, 0x6f, 0xf4, 0x21, 0xd4, 0x68, 0x69, 0x81, 0xe8, 0x03,
	0x63, 0x62, 0x95, 0x8e, 0x0f, 0x2c, 0xed, 0x3f, 0x14, 0x58, 0x4d, 0x51, 0xc0, 0xf9, 0xf4, 0xbb,
	0x26, 0x21, 0xb6, 0xb1, 0x65, 0xb9, 0xf6, 0xf8, 0x08, 0x6a, 0xe2, 0xc7, 0x20, 0x34, 0xba, 0x98,
	0xda, 0xee, 0x89, 0x41, 0x53, 0xf7, 0xa9, 0xa4, 0xef, 0xf3, 0x29, 0xac, 0x32, 0x69, 0xe5, 0x52,
	0xde, 0x3b, 0x0d, 0x70, 0x48, 0x25, 0x88, 0xe4, 0x0d, 0x5c, 0x38, 0xc6, 0x81, 0xa3, 0xfd, 0x6f,
	0x09, 0x56, 0xfa, 0xdf, 0xbc, 0x24, 0x7a, 0x75, 0x62, 0x84, 0x13, 0xe1, 0x50, 0x8f, 0x9b, 0x93,
	0xa1, 0x17, 0x8c, 0x0c, 0xe1, 0xa4, 0x3e, 0x11, 0x37, 0xcf, 0x61, 0xa0, 0xae, 0x70, 0x8f, 0xc2,
	0x32, 0x11, 0x66, 0xdf, 0xe8, 0x4b, 0xa8, 0x84, 0xd8, 0x0c, 0xb0, 0xf8, 0xd9, 0xc9, 0xed, 0xc9,
	0x18, 0xfa, 0x14, 0x4e, 0xe7, 0xf0, 0x9d, 0xbf, 0x53, 0x00, 0x12, 0xa4, 0xe8, 0x6b, 0xa9, 0xc6,
	0xbf, 0xb4, 0x75, 0x6f, 0x1e, 0x42, 0x36, 0x68, 0xd7, 0x88, 0xb5, 0x03, 0xa8, 0x39, 0x75, 0xc6,
	0x23, 0x57, 0xfc, 0x08, 0x41, 0x0c, 0xb5, 0x87, 0x50, 0xa6, 0x3d, 0xa5, 0x06, 0x54, 0xdf, 0x1c,
	0xbe, 0x38, 0x3c, 0x7a, 0x7b, 0xd8, 0x5a, 0x40, 0x55, 0x50, 0x77, 0xfa, 0xdf, 0xb6, 0x14, 0x54,
	0x83, 0xf2, 0xf3, 0xfe, 0xd1, 0x61, 0xab, 0x44, 0xd6, 0x5f, 0x77, 0xf5, 0x6f, 0xde, 0xf4, 0x8e,
	0x5b, 0x6a, 0x67, 0x03, 0x2a, 0x8c, 0xdc, 0xc2, 0x1f, 0xe0, 0x70, 0x95, 0x2c, 0x25, 0x2a, 0xf9,
	0xef, 0x0a, 0x2c, 0x32, 0xfa, 0xae, 0xea, 0xdb, 0x76, 0x61, 0x89, 0xdb, 0xa7, 0x90, 0xbd, 0x2c,
	0x7f, 0x8a, 0x1b, 0x71, 0x19, 0x2c, 0xff, 0xec, 0xfb, 0x0b, 0xfa, 0xa2, 0x27, 0x4f, 0xa3, 0xa7,
	0xd0, 0x0c, 0xbf, 0x73, 0xa8, 0x89, 0x25, 0xac, 0x8a, 0x7b, 0x8c, 0x93, 0xb8, 0xb8, 0xbf, 0xa0,
	0x37, 0xc2, 0xef, 0x1c, 0x31, 0x49, 0x32, 0x3e, 0x16, 0xad, 0x68, 0xff, 0xa4, 0xc2, 0x92, 0xb8,
	0x09, 0xd7, 0x99, 0x7e, 0x8e, 0x44, 0x76, 0xa5, 0xfb, 0x02, 0x7d, 0x1a, 0x3e, 0x4d, 0xb1, 0x4e,
	0xab, 0x2b, 0x79, 0x8a, 0x5f, 0x65, 0x28, 0x66, 0xb7, 0xbe, 0x3b, 0x01, 0xa5, 0x74, 0x81, 0x18,
	0xa1, 0x7c, 0x81, 0xce, 0x4f, 0x33, 0xfa, 0xc1, 0xa0, 0xd0, 0x8f, 0x60, 0x91, 0xf5, 0x94, 0x2f,
	0x02, 0x3b, 0x8a, 0xb0, 0xcb, 0xcd, 0x7f, 0x93, 0x4e, 0xbe, 0x65, 0x73, 0x9d, 0xdf, 0x28, 0x29,
	0x95, 0xe1, 0x5b, 0x7f, 0x01, 0xcd, 0xc0, 0xbb, 0x90, 0x77, 0x12, 0x27, 0xf8, 0xd5, 0xbc, 0x04,
	0x6e, 0xe8, 0xde, 0x85, 0x38, 0xa1, 0xe7, 0x46, 0xc1, 0xa5, 0xde, 0x08, 0x92, 0x99, 0xce, 0x53,
	0x68, 0x65, 0x01, 0x0a, 0xdc, 0xcd, 0x9a, 0xec, 0x6e, 0x54, 0x6e, 0xbf, 0x7f, 0x5a, 0xfa, 0x52,
	0x49, 0xea, 0x56, 0xf7, 0x77, 0x00, 0x92, 0x4a, 0x29, 0xfa, 0x00, 0x56, 0x8f, 0xf4, 0x83, 0x67,
	0x07, 0x87, 0x83, 0x17, 0x07, 0x87, 0xbb, 0x83, 0x44, 0xe2, 0x6b, 0x50, 0x7e, 0xd3, 0xef, 0xe9,
	0x4c, 0xe4, 0xbb, 0x6f, 0x8e, 0x8f, 0x5a, 0x25, 0xf2, 0xb5, 0xd7, 0xdf, 0x79, 0xd1, 0x52, 0xef,
	0x7f, 0xc6, 0xba, 0xb9, 0x54, 0x51, 0x9a, 0x50, 0xd3, 0x7b, 0xfd, 0x9e, 0xfe, 0x6d, 0x6f, 0x97,
	0xed, 0xdb, 0x3b, 0x78, 0xd9, 0x6b, 0x29, 0x44, 0x67, 0x76, 0x0f, 0xf4, 0x56, 0xe9, 0xfe, 0x2f,
	0xa0, 0x21, 0x95, 0x77, 0x51, 0x1b, 0xd6, 0x76, 0x8e, 0x5e, 0xbd, 0x3a, 0x38, 0x1e, 0xf4, 0x8f,
	0xbb, 0xc7, 0x3d, 0xe9, 0xcc, 0x06, 0x54, 0xfb, 0xc7, 0x5d, 0xfd, 0xb8, 0xb7, 0xdb, 0x52, 0x50,
	0x1d, 0xae, 0xe9, 0xbd, 0xee, 0xee, 0xcf, 0x5b, 0x25, 0xb4, 0x08, 0xf5, 0xbd, 0x83, 0xc3, 0x83,
	0xfe, 0xfe, 0xc1, 0xe1, 0xb3, 0x96, 0x4a, 0x0e, 0x64, 0xc3, 0xde, 0x6e, 0xab, 0x7c, 0xff, 0x09,
	0xd4, 0x77, 0x31, 0x2d, 0x2c, 0xe2, 0x80, 0x9c, 0x7e, 0x78, 0x74, 0xd8, 0x63, 0x74, 0x50, 0x45,
	0xa5, 0xf4, 0xbf, 0x3c, 0x38, 0xec, 0xb5, 0x4a, 0x84, 0xa2, 0xfe, 0x37, 0x2f, 0x5b, 0xaa, 0x50,
	0xe7, 0xf2, 0xd6, 0xbf, 0x74, 0x40, 0xed, 0xbe, 0x3e, 0x40, 0x5d, 0x80, 0xa4, 0xdb, 0x89, 0x62,
	0x3d, 0xc8, 0x75, 0x40, 0x3b, 0xeb, 0x39, 0xbb, 0xdc, 0x1b, 0xf9, 0xd1, 0xa5, 0xb6, 0x80, 0xbe,
	0x86, 0x86, 0xd4, 0xbf, 0x44, 0xf1, 0x8f, 0x0b, 0xf2, 0x4d, 0xcd, 0x4e, 0x2b, 0xfb, 0x7b, 0x2c,
	0x6d, 0x01, 0x7d, 0x05, 0x35, 0xd1, 0xc6, 0x44, 0x1f, 0x88, 0xf5, 0x4c, 0x63, 0xb3, 0x68, 0xe3,
	0x03, 0x85, 0x10, 0x9f, 0x74, 0xfd, 0x12, 0xe2, 0x73, 0x1d, 0xcc, 0x29, 0xc4, 0xef, 0x43, 0x43,
	0x6a, 0x1c, 0x26, 0xc4, 0xe7, 0x1b, 0x97, 0x9d, 0x1b, 0x85, 0x6b, 0xdc, 0x8f, 0x2f, 0xa0, 0x27,
	0xd0, 0x90, 0xda, 0x88, 0x09, 0xa6, 0x7c, 0x6f, 0xb1, 0x93, 0x31, 0x71, 0xda, 0x02, 0xea, 0x41,
	0x53, 0x6e, 0xfd, 0xa1, 0x1b, 0x49, 0x62, 0x95, 0x6b, 0x08, 0x4e, 0xb9, 0xcd, 0x0e, 0x34, 0xa4,
	0x92, 0x7f, 0x42, 0x43, 0xbe, 0x0f, 0x30, 0x15, 0xc9, 0x62, 0xaa, 0xb9, 0x84, 0x3e, 0xca, 0xbc,
	0x68, 0x1a, 0x51, 0xc1, 0xaf, 0x1f, 0xb4, 0x05, 0xf4, 0x33, 0x80, 0xa4, 0x81, 0x94, 0x3c, 0x4d,
	0xae, 0xd1, 0x57, 0xbc, 0xfd, 0x81, 0x82, 0x0e, 0x60, 0x39, 0xd3, 0xa7, 0x41, 0xb7, 0x62, 0x96,
	0x16, 0x36, 0x70, 0x26, 0xa2, 0x7a, 0x01, 0xad, 0x6c, 0xb7, 0x0c, 0x7d, 0x5c, 0x78, 0xa7, 0x24,
	0x8b, 0x98, 0x88, 0x6c, 0x1f, 0x16, 0x53, 0x9d, 0xb1, 0x84, 0x3b, 0x45, 0x0d, 0xb3, 0xce, 0xf5,
	0x5c, 0x37, 0x4a, 0x22, 0x6b, 0x39, 0xd3, 0x20, 0x93, 0x6e, 0x58, 0xd8, 0x39, 0x9b, 0xf2, 0x68,
	0xcf, 0x60, 0x31, 0xd5, 0x21, 0x4b, 0xc8, 0x2a, 0x6a, 0x9c, 0x4d, 0x41, 0xf4, 0x1c, 0x1a, 0x52,
	0x8b, 0x22, 0x11, 0xa1, 0x7c, 0x9f, 0xa4, 0x73, 0xa3, 0x70, 0x4d, 0x28, 0xc4, 0x03, 0x85, 0x48,
	0xb5, 0xdc, 0x42, 0x4a, 0xa4, 0xba, 0xa0, 0xb1, 0x34, 0x97, 0x40, 0x72, 0x3c, 0x59, 0x81, 0x4c,
	0x23, 0x42, 0xe9, 0xa8, 0x34, 0x2d, 0x90, 0x1c, 0x43, 0x4a, 0x20, 0xe7, 0xd8, 0xce, 0x2e, 0x23,
	0x77, 0x19, 0x50, 0xc6, 0x1c, 0xcc, 0x7f, 0x19, 0x48, 0x6a, 0xb0, 0x09, 0x1d, 0xb9, 0xba, 0xec,
	0x64, 0x14, 0x77, 0x15, 0xb4, 0x0d, 0x55, 0x5e, 0x61, 0x40, 0xeb, 0x02, 0x43, 0xba, 0xe8, 0xd9,
	0x99, 0x56, 0x4c, 0xe7, 0xf7, 0x01, 0xbe, 0xe5, 0xb8, 0xab, 0xbf, 0x3f, 0x9a, 0xc4, 0xfa, 0x53,
	0x72, 0xb2, 0xd6, 0x5f, 0xc6, 0x95, 0xab, 0x16, 0x25, 0xd6, 0x9f, 0xee, 0x4d, 0x59, 0xff, 0x19,
	0x1b, 0x1f, 0x28, 0x64, 0xab, 0xa8, 0x3b, 0x26, 0x5b, 0x33, 0x95, 0xc8, 0xc9, 0x5b, 0x45, 0x41,
	0x30, 0xd9, 0x9a, 0x29, 0x11, 0x4e, 0xd8, 0xda, 0x85, 0x9a, 0xa8, 0xa2, 0x25, 0x5b, 0x33, 0x65,
	0xbd, 0x4e, 0x3b, 0xbf, 0x20, 0xa9, 0xc5, 0x0b, 0x68, 0xca, 0xb9, 0x60, 0x22, 0x49, 0x05, 0x89,
	0x63, 0xe7, 0xa3, 0xe2, 0xc5, 0xd8, 0xed, 0x7c, 0x4d, 0xa3, 0x00, 0x1c, 0xe1, 0xae, 0xe3, 0xa0,
	0x09, 0x32, 0x33, 0x45, 0x1c, 0x1f, 0x41, 0x79, 0x2f, 0x34, 0xcf, 0x51, 0xdc, 0x8f, 0x96, 0x6a,
	0x76, 0x9d, 0xb5, 0xf4, 0xa4, 0x74, 0x85, 0x57, 0xb0, 0x98, 0xaa, 0x8d, 0x4d, 0x13, 0xe4, 0x9b,
	0x69, 0xad, 0xcf, 0x54, 0x4f, 0xa8, 0x3c, 0xef, 0xc7, 0xb2, 0x98, 0xc2, 0x95, 0xab, 0xa2, 0xcd,
	0xc4, 0x45, 0x42, 0x82, 0xa4, 0x7c, 0x86, 0xb2, 0x0d, 0xa2, 0xb9, 0x2c, 0x60, 0x0f, 0x9a, 0x72,
	0x91, 0x2c, 0x79, 0x9e, 0x82, 0xd2, 0xd9, 0x14, 0x34, 0xaf, 0x61, 0x29, 0x5d, 0x13, 0x43, 0x37,
	0x25, 0x5f, 0x90, 0xaf, 0x95, 0xcd, 0xbe, 0xdb, 0x0b, 0x68, 0xca, 0xf5, 0xa7, 0x84, 0xb0, 0x82,
	0x2a, 0x58, 0x22, 0x37, 0x45, 0x25, 0x2b, 0x86, 0x4c, 0x2e, 0x06, 0x49, 0xb6, 0x39, 0x5f, 0x9f,
	0x4a, 0x90, 0x15, 0xd5, 0x8f, 0xa8, 0x10, 0xd6, 0x44, 0x49, 0x28, 0x51, 0x8a, 0x4c, 0x91, 0x68,
	0x0a, 0xab, 0x7e, 0x06, 0x35, 0x51, 0xa7, 0x91, 0xd4, 0x31, 0x5d, 0xde, 0x49, 0x74, 0x2a, 0x5b,
	0xd2, 0x61, 0xaf, 0x9e, 0x14, 0x6a, 0xa4, 0x28, 0x36, 0x5b, 0xbc, 0x99, 0x1e, 0x08, 0x4a, 0x65,
	0x90, 0xc4, 0x8e, 0xe5, 0xab, 0x33, 0x89, 0xdf, 0x2b, 0xa8, 0x9b, 0x50, 0xce, 0xca, 0x25, 0x9d,
	0x5d, 0x3c, 0x34, 0x48, 0x96, 0x34, 0x49, 0x35, 0x67, 0x20, 0x7b, 0xc2, 0xec, 0xe3, 0xb1, 0x11,
	0x9e, 0xa3, 0xf6, 0x46, 0x64, 0x84, 0xe7, 0x86, 0x6f, 0x6f, 0x88, 0x29, 0x41, 0xd1, 0x4a, 0xbc,
	0x42, 0x66, 0x25, 0x33, 0x57, 0xe1, 0x65, 0x8d, 0xeb, 0xd9, 0x6c, 0x4c, 0xb0, 0xa3, 0x30, 0x49,
	0x63, 0xf1, 0x44, 0xaa, 0xfd, 0x9d, 0xf8, 0xdc, 0xa2, 0xae, 0xf8, 0x14, 0xbe, 0xee, 0xc1, 0x52,
	0xba, 0x95, 0x9d, 0xa8, 0x41, 0x61, 0x8b, 0xbb, 0xb3, 0x9a, 0x69, 0x3c, 0x73, 0x47, 0xb1, 0x0d,
	0x0d, 0xa9, 0x9d, 0x9d, 0xbc, 0x4f, 0xbe, 0xc7, 0x3d, 0x01, 0xc3, 0x03, 0x85, 0x06, 0x49, 0x72,
	0xf3, 0x5b, 0x0a, 0x92, 0x0a, 0x7a, 0xe2, 0x93, 0x2f, 0xb5, 0xfd, 0xc5, 0x6f, 0xbf, 0xbf, 0xa5,
	0xfc, 0xe7, 0xf7, 0xb7, 0x94, 0xff, 0xfa, 0xfe, 0x96, 0xf2, 0x07, 0xf7, 0x4e, 0xed, 0xe8, 0x6c,
	0x7c, 0xb2, 0x61, 0x7a, 0xa3, 0x4d, 0xdf, 0x30, 0xcf, 0x2e, 0x2d, 0x1c, 0xc8, 0x5f, 0xef, 0xb6,
	0x36, 0xc3, 0xc0, 0xdc, 0xf4, 0x87, 0xe1, 0x49, 0x85, 0xa2, 0x7a, 0xf8, 0xff, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xf3, 0x79, 0xcb, 0x9a, 0x88, 0x35, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// APIClient is the client API for API service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type APIClient interface {
	// CreateRepo creates a new repo.
	CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (API_ListRepoClient, error)
	// DeleteRepo deletes a repo.
	DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// DeleteRepos deletes more than one repo at once.  It attempts to
	// delete every repo matching the DeleteReposRequest.  When deleting
	// all repos matching a project, any repos not deletable by the
	// caller will remain, and the project will not be empty; this is
	// not an error.  The returned DeleteReposResponse will contain a
	// list of all actually-deleted repos.
	DeleteRepos(ctx context.Context, in *DeleteReposRequest, opts ...grpc.CallOption) (*DeleteReposResponse, error)
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// ClearCommit removes all data from the commit.
	ClearCommit(ctx context.Context, in *ClearCommitRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error)
	// ListCommit returns info about all commits.
	ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (API_ListCommitClient, error)
	// SubscribeCommit subscribes for new commits on a given branch.
	SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error)
	// InspectCommitSet returns the info about a CommitSet.
	InspectCommitSet(ctx context.Context, in *InspectCommitSetRequest, opts ...grpc.CallOption) (API_InspectCommitSetClient, error)
	// ListCommitSet returns info about all CommitSets.
	ListCommitSet(ctx context.Context, in *ListCommitSetRequest, opts ...grpc.CallOption) (API_ListCommitSetClient, error)
	// SquashCommitSet squashes the commits of a CommitSet into their children.
	SquashCommitSet(ctx context.Context, in *SquashCommitSetRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// DropCommitSet drops the commits of a CommitSet and all data included in the commits.
	DropCommitSet(ctx context.Context, in *DropCommitSetRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// FindCommits searches for commits that reference a supplied file being modified in a branch.
	FindCommits(ctx context.Context, in *FindCommitsRequest, opts ...grpc.CallOption) (API_FindCommitsClient, error)
	// CreateBranch creates a new branch.
	CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectBranch returns info about a branch.
	InspectBranch(ctx context.Context, in *InspectBranchRequest, opts ...grpc.CallOption) (*BranchInfo, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (API_ListBranchClient, error)
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// ModifyFile performs modifications on a set of files.
	ModifyFile(ctx context.Context, opts ...grpc.CallOption) (API_ModifyFileClient, error)
	// GetFile returns the contents of a single file
	GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error)
	// GetFileTAR returns a TAR stream of the contents matched by the request
	GetFileTAR(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileTARClient, error)
	// InspectFile returns info about a file.
	InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error)
	// ListFile returns info about all files.
	ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileClient, error)
	// WalkFile walks over all the files under a directory, including children of children.
	WalkFile(ctx context.Context, in *WalkFileRequest, opts ...grpc.CallOption) (API_WalkFileClient, error)
	// GlobFile returns info about all files.
	GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (API_GlobFileClient, error)
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (API_DiffFileClient, error)
	// ActivateAuth creates a role binding for all existing repos
	ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error)
	// DeleteAll deletes everything.
	DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error)
	// Fsck does a file system consistency check for pfs.
	Fsck(ctx context.Context, in *FsckRequest, opts ...grpc.CallOption) (API_FsckClient, error)
	// FileSet API
	// CreateFileSet creates a new file set.
	CreateFileSet(ctx context.Context, opts ...grpc.CallOption) (API_CreateFileSetClient, error)
	// GetFileSet returns a file set with the data from a commit
	GetFileSet(ctx context.Context, in *GetFileSetRequest, opts ...grpc.CallOption) (*CreateFileSetResponse, error)
	// AddFileSet associates a file set with a commit
	AddFileSet(ctx context.Context, in *AddFileSetRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// RenewFileSet prevents a file set from being deleted for a set amount of time.
	RenewFileSet(ctx context.Context, in *RenewFileSetRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// ComposeFileSet composes a file set from a list of file sets.
	ComposeFileSet(ctx context.Context, in *ComposeFileSetRequest, opts ...grpc.CallOption) (*CreateFileSetResponse, error)
	ShardFileSet(ctx context.Context, in *ShardFileSetRequest, opts ...grpc.CallOption) (*ShardFileSetResponse, error)
	// CheckStorage runs integrity checks for the storage layer.
	CheckStorage(ctx context.Context, in *CheckStorageRequest, opts ...grpc.CallOption) (*CheckStorageResponse, error)
	PutCache(ctx context.Context, in *PutCacheRequest, opts ...grpc.CallOption) (*types.Empty, error)
	GetCache(ctx context.Context, in *GetCacheRequest, opts ...grpc.CallOption) (*GetCacheResponse, error)
	ClearCache(ctx context.Context, in *ClearCacheRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// RunLoadTest runs a load test.
	RunLoadTest(ctx context.Context, in *RunLoadTestRequest, opts ...grpc.CallOption) (*RunLoadTestResponse, error)
	// RunLoadTestDefault runs the default load tests.
	RunLoadTestDefault(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*RunLoadTestResponse, error)
	// ListTask lists PFS tasks
	ListTask(ctx context.Context, in *task.ListTaskRequest, opts ...grpc.CallOption) (API_ListTaskClient, error)
	// Egress writes data from a commit to an external system
	Egress(ctx context.Context, in *EgressRequest, opts ...grpc.CallOption) (*EgressResponse, error)
	// Project API
	// CreateProject creates a new project.
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*types.Empty, error)
	// InspectProject returns info about a project.
	InspectProject(ctx context.Context, in *InspectProjectRequest, opts ...grpc.CallOption) (*ProjectInfo, error)
	// ListProject returns info about all projects.
	ListProject(ctx context.Context, in *ListProjectRequest, opts ...grpc.CallOption) (API_ListProjectClient, error)
	// DeleteProject deletes a project.
	DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*types.Empty, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) CreateRepo(ctx context.Context, in *CreateRepoRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/CreateRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectRepo(ctx context.Context, in *InspectRepoRequest, opts ...grpc.CallOption) (*RepoInfo, error) {
	out := new(RepoInfo)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/InspectRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListRepo(ctx context.Context, in *ListRepoRequest, opts ...grpc.CallOption) (API_ListRepoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[0], "/pfs_v2.API/ListRepo", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListRepoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListRepoClient interface {
	Recv() (*RepoInfo, error)
	grpc.ClientStream
}

type aPIListRepoClient struct {
	grpc.ClientStream
}

func (x *aPIListRepoClient) Recv() (*RepoInfo, error) {
	m := new(RepoInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteRepo(ctx context.Context, in *DeleteRepoRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/DeleteRepo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteRepos(ctx context.Context, in *DeleteReposRequest, opts ...grpc.CallOption) (*DeleteReposResponse, error) {
	out := new(DeleteReposResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/DeleteRepos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) StartCommit(ctx context.Context, in *StartCommitRequest, opts ...grpc.CallOption) (*Commit, error) {
	out := new(Commit)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/StartCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FinishCommit(ctx context.Context, in *FinishCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/FinishCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ClearCommit(ctx context.Context, in *ClearCommitRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/ClearCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectCommit(ctx context.Context, in *InspectCommitRequest, opts ...grpc.CallOption) (*CommitInfo, error) {
	out := new(CommitInfo)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/InspectCommit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListCommit(ctx context.Context, in *ListCommitRequest, opts ...grpc.CallOption) (API_ListCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[1], "/pfs_v2.API/ListCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIListCommitClient struct {
	grpc.ClientStream
}

func (x *aPIListCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SubscribeCommit(ctx context.Context, in *SubscribeCommitRequest, opts ...grpc.CallOption) (API_SubscribeCommitClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[2], "/pfs_v2.API/SubscribeCommit", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPISubscribeCommitClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_SubscribeCommitClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPISubscribeCommitClient struct {
	grpc.ClientStream
}

func (x *aPISubscribeCommitClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectCommitSet(ctx context.Context, in *InspectCommitSetRequest, opts ...grpc.CallOption) (API_InspectCommitSetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[3], "/pfs_v2.API/InspectCommitSet", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIInspectCommitSetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_InspectCommitSetClient interface {
	Recv() (*CommitInfo, error)
	grpc.ClientStream
}

type aPIInspectCommitSetClient struct {
	grpc.ClientStream
}

func (x *aPIInspectCommitSetClient) Recv() (*CommitInfo, error) {
	m := new(CommitInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ListCommitSet(ctx context.Context, in *ListCommitSetRequest, opts ...grpc.CallOption) (API_ListCommitSetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[4], "/pfs_v2.API/ListCommitSet", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListCommitSetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListCommitSetClient interface {
	Recv() (*CommitSetInfo, error)
	grpc.ClientStream
}

type aPIListCommitSetClient struct {
	grpc.ClientStream
}

func (x *aPIListCommitSetClient) Recv() (*CommitSetInfo, error) {
	m := new(CommitSetInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) SquashCommitSet(ctx context.Context, in *SquashCommitSetRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/SquashCommitSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DropCommitSet(ctx context.Context, in *DropCommitSetRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/DropCommitSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) FindCommits(ctx context.Context, in *FindCommitsRequest, opts ...grpc.CallOption) (API_FindCommitsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[5], "/pfs_v2.API/FindCommits", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFindCommitsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FindCommitsClient interface {
	Recv() (*FindCommitsResponse, error)
	grpc.ClientStream
}

type aPIFindCommitsClient struct {
	grpc.ClientStream
}

func (x *aPIFindCommitsClient) Recv() (*FindCommitsResponse, error) {
	m := new(FindCommitsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) CreateBranch(ctx context.Context, in *CreateBranchRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/CreateBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectBranch(ctx context.Context, in *InspectBranchRequest, opts ...grpc.CallOption) (*BranchInfo, error) {
	out := new(BranchInfo)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/InspectBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListBranch(ctx context.Context, in *ListBranchRequest, opts ...grpc.CallOption) (API_ListBranchClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[6], "/pfs_v2.API/ListBranch", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListBranchClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListBranchClient interface {
	Recv() (*BranchInfo, error)
	grpc.ClientStream
}

type aPIListBranchClient struct {
	grpc.ClientStream
}

func (x *aPIListBranchClient) Recv() (*BranchInfo, error) {
	m := new(BranchInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteBranch(ctx context.Context, in *DeleteBranchRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/DeleteBranch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ModifyFile(ctx context.Context, opts ...grpc.CallOption) (API_ModifyFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[7], "/pfs_v2.API/ModifyFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIModifyFileClient{stream}
	return x, nil
}

type API_ModifyFileClient interface {
	Send(*ModifyFileRequest) error
	CloseAndRecv() (*types.Empty, error)
	grpc.ClientStream
}

type aPIModifyFileClient struct {
	grpc.ClientStream
}

func (x *aPIModifyFileClient) Send(m *ModifyFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPIModifyFileClient) CloseAndRecv() (*types.Empty, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(types.Empty)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GetFile(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[8], "/pfs_v2.API/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetFileClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type aPIGetFileClient struct {
	grpc.ClientStream
}

func (x *aPIGetFileClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GetFileTAR(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (API_GetFileTARClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[9], "/pfs_v2.API/GetFileTAR", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetFileTARClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetFileTARClient interface {
	Recv() (*types.BytesValue, error)
	grpc.ClientStream
}

type aPIGetFileTARClient struct {
	grpc.ClientStream
}

func (x *aPIGetFileTARClient) Recv() (*types.BytesValue, error) {
	m := new(types.BytesValue)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) InspectFile(ctx context.Context, in *InspectFileRequest, opts ...grpc.CallOption) (*FileInfo, error) {
	out := new(FileInfo)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/InspectFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListFile(ctx context.Context, in *ListFileRequest, opts ...grpc.CallOption) (API_ListFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[10], "/pfs_v2.API/ListFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIListFileClient struct {
	grpc.ClientStream
}

func (x *aPIListFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) WalkFile(ctx context.Context, in *WalkFileRequest, opts ...grpc.CallOption) (API_WalkFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[11], "/pfs_v2.API/WalkFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIWalkFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_WalkFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIWalkFileClient struct {
	grpc.ClientStream
}

func (x *aPIWalkFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GlobFile(ctx context.Context, in *GlobFileRequest, opts ...grpc.CallOption) (API_GlobFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[12], "/pfs_v2.API/GlobFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGlobFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GlobFileClient interface {
	Recv() (*FileInfo, error)
	grpc.ClientStream
}

type aPIGlobFileClient struct {
	grpc.ClientStream
}

func (x *aPIGlobFileClient) Recv() (*FileInfo, error) {
	m := new(FileInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DiffFile(ctx context.Context, in *DiffFileRequest, opts ...grpc.CallOption) (API_DiffFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[13], "/pfs_v2.API/DiffFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIDiffFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_DiffFileClient interface {
	Recv() (*DiffFileResponse, error)
	grpc.ClientStream
}

type aPIDiffFileClient struct {
	grpc.ClientStream
}

func (x *aPIDiffFileClient) Recv() (*DiffFileResponse, error) {
	m := new(DiffFileResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ActivateAuth(ctx context.Context, in *ActivateAuthRequest, opts ...grpc.CallOption) (*ActivateAuthResponse, error) {
	out := new(ActivateAuthResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/ActivateAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) DeleteAll(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/DeleteAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) Fsck(ctx context.Context, in *FsckRequest, opts ...grpc.CallOption) (API_FsckClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[14], "/pfs_v2.API/Fsck", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIFsckClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_FsckClient interface {
	Recv() (*FsckResponse, error)
	grpc.ClientStream
}

type aPIFsckClient struct {
	grpc.ClientStream
}

func (x *aPIFsckClient) Recv() (*FsckResponse, error) {
	m := new(FsckResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) CreateFileSet(ctx context.Context, opts ...grpc.CallOption) (API_CreateFileSetClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[15], "/pfs_v2.API/CreateFileSet", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPICreateFileSetClient{stream}
	return x, nil
}

type API_CreateFileSetClient interface {
	Send(*ModifyFileRequest) error
	CloseAndRecv() (*CreateFileSetResponse, error)
	grpc.ClientStream
}

type aPICreateFileSetClient struct {
	grpc.ClientStream
}

func (x *aPICreateFileSetClient) Send(m *ModifyFileRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *aPICreateFileSetClient) CloseAndRecv() (*CreateFileSetResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(CreateFileSetResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) GetFileSet(ctx context.Context, in *GetFileSetRequest, opts ...grpc.CallOption) (*CreateFileSetResponse, error) {
	out := new(CreateFileSetResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/GetFileSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) AddFileSet(ctx context.Context, in *AddFileSetRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/AddFileSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RenewFileSet(ctx context.Context, in *RenewFileSetRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/RenewFileSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ComposeFileSet(ctx context.Context, in *ComposeFileSetRequest, opts ...grpc.CallOption) (*CreateFileSetResponse, error) {
	out := new(CreateFileSetResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/ComposeFileSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ShardFileSet(ctx context.Context, in *ShardFileSetRequest, opts ...grpc.CallOption) (*ShardFileSetResponse, error) {
	out := new(ShardFileSetResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/ShardFileSet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CheckStorage(ctx context.Context, in *CheckStorageRequest, opts ...grpc.CallOption) (*CheckStorageResponse, error) {
	out := new(CheckStorageResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/CheckStorage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) PutCache(ctx context.Context, in *PutCacheRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/PutCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetCache(ctx context.Context, in *GetCacheRequest, opts ...grpc.CallOption) (*GetCacheResponse, error) {
	out := new(GetCacheResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/GetCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ClearCache(ctx context.Context, in *ClearCacheRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/ClearCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunLoadTest(ctx context.Context, in *RunLoadTestRequest, opts ...grpc.CallOption) (*RunLoadTestResponse, error) {
	out := new(RunLoadTestResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/RunLoadTest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) RunLoadTestDefault(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*RunLoadTestResponse, error) {
	out := new(RunLoadTestResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/RunLoadTestDefault", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListTask(ctx context.Context, in *task.ListTaskRequest, opts ...grpc.CallOption) (API_ListTaskClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[16], "/pfs_v2.API/ListTask", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListTaskClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListTaskClient interface {
	Recv() (*task.TaskInfo, error)
	grpc.ClientStream
}

type aPIListTaskClient struct {
	grpc.ClientStream
}

func (x *aPIListTaskClient) Recv() (*task.TaskInfo, error) {
	m := new(task.TaskInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) Egress(ctx context.Context, in *EgressRequest, opts ...grpc.CallOption) (*EgressResponse, error) {
	out := new(EgressResponse)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/Egress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/CreateProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) InspectProject(ctx context.Context, in *InspectProjectRequest, opts ...grpc.CallOption) (*ProjectInfo, error) {
	out := new(ProjectInfo)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/InspectProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListProject(ctx context.Context, in *ListProjectRequest, opts ...grpc.CallOption) (API_ListProjectClient, error) {
	stream, err := c.cc.NewStream(ctx, &_API_serviceDesc.Streams[17], "/pfs_v2.API/ListProject", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIListProjectClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_ListProjectClient interface {
	Recv() (*ProjectInfo, error)
	grpc.ClientStream
}

type aPIListProjectClient struct {
	grpc.ClientStream
}

func (x *aPIListProjectClient) Recv() (*ProjectInfo, error) {
	m := new(ProjectInfo)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) DeleteProject(ctx context.Context, in *DeleteProjectRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/pfs_v2.API/DeleteProject", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// APIServer is the server API for API service.
type APIServer interface {
	// CreateRepo creates a new repo.
	CreateRepo(context.Context, *CreateRepoRequest) (*types.Empty, error)
	// InspectRepo returns info about a repo.
	InspectRepo(context.Context, *InspectRepoRequest) (*RepoInfo, error)
	// ListRepo returns info about all repos.
	ListRepo(*ListRepoRequest, API_ListRepoServer) error
	// DeleteRepo deletes a repo.
	DeleteRepo(context.Context, *DeleteRepoRequest) (*types.Empty, error)
	// DeleteRepos deletes more than one repo at once.  It attempts to
	// delete every repo matching the DeleteReposRequest.  When deleting
	// all repos matching a project, any repos not deletable by the
	// caller will remain, and the project will not be empty; this is
	// not an error.  The returned DeleteReposResponse will contain a
	// list of all actually-deleted repos.
	DeleteRepos(context.Context, *DeleteReposRequest) (*DeleteReposResponse, error)
	// StartCommit creates a new write commit from a parent commit.
	StartCommit(context.Context, *StartCommitRequest) (*Commit, error)
	// FinishCommit turns a write commit into a read commit.
	FinishCommit(context.Context, *FinishCommitRequest) (*types.Empty, error)
	// ClearCommit removes all data from the commit.
	ClearCommit(context.Context, *ClearCommitRequest) (*types.Empty, error)
	// InspectCommit returns the info about a commit.
	InspectCommit(context.Context, *InspectCommitRequest) (*CommitInfo, error)
	// ListCommit returns info about all commits.
	ListCommit(*ListCommitRequest, API_ListCommitServer) error
	// SubscribeCommit subscribes for new commits on a given branch.
	SubscribeCommit(*SubscribeCommitRequest, API_SubscribeCommitServer) error
	// InspectCommitSet returns the info about a CommitSet.
	InspectCommitSet(*InspectCommitSetRequest, API_InspectCommitSetServer) error
	// ListCommitSet returns info about all CommitSets.
	ListCommitSet(*ListCommitSetRequest, API_ListCommitSetServer) error
	// SquashCommitSet squashes the commits of a CommitSet into their children.
	SquashCommitSet(context.Context, *SquashCommitSetRequest) (*types.Empty, error)
	// DropCommitSet drops the commits of a CommitSet and all data included in the commits.
	DropCommitSet(context.Context, *DropCommitSetRequest) (*types.Empty, error)
	// FindCommits searches for commits that reference a supplied file being modified in a branch.
	FindCommits(*FindCommitsRequest, API_FindCommitsServer) error
	// CreateBranch creates a new branch.
	CreateBranch(context.Context, *CreateBranchRequest) (*types.Empty, error)
	// InspectBranch returns info about a branch.
	InspectBranch(context.Context, *InspectBranchRequest) (*BranchInfo, error)
	// ListBranch returns info about the heads of branches.
	ListBranch(*ListBranchRequest, API_ListBranchServer) error
	// DeleteBranch deletes a branch; note that the commits still exist.
	DeleteBranch(context.Context, *DeleteBranchRequest) (*types.Empty, error)
	// ModifyFile performs modifications on a set of files.
	ModifyFile(API_ModifyFileServer) error
	// GetFile returns the contents of a single file
	GetFile(*GetFileRequest, API_GetFileServer) error
	// GetFileTAR returns a TAR stream of the contents matched by the request
	GetFileTAR(*GetFileRequest, API_GetFileTARServer) error
	// InspectFile returns info about a file.
	InspectFile(context.Context, *InspectFileRequest) (*FileInfo, error)
	// ListFile returns info about all files.
	ListFile(*ListFileRequest, API_ListFileServer) error
	// WalkFile walks over all the files under a directory, including children of children.
	WalkFile(*WalkFileRequest, API_WalkFileServer) error
	// GlobFile returns info about all files.
	GlobFile(*GlobFileRequest, API_GlobFileServer) error
	// DiffFile returns the differences between 2 paths at 2 commits.
	DiffFile(*DiffFileRequest, API_DiffFileServer) error
	// ActivateAuth creates a role binding for all existing repos
	ActivateAuth(context.Context, *ActivateAuthRequest) (*ActivateAuthResponse, error)
	// DeleteAll deletes everything.
	DeleteAll(context.Context, *types.Empty) (*types.Empty, error)
	// Fsck does a file system consistency check for pfs.
	Fsck(*FsckRequest, API_FsckServer) error
	// FileSet API
	// CreateFileSet creates a new file set.
	CreateFileSet(API_CreateFileSetServer) error
	// GetFileSet returns a file set with the data from a commit
	GetFileSet(context.Context, *GetFileSetRequest) (*CreateFileSetResponse, error)
	// AddFileSet associates a file set with a commit
	AddFileSet(context.Context, *AddFileSetRequest) (*types.Empty, error)
	// RenewFileSet prevents a file set from being deleted for a set amount of time.
	RenewFileSet(context.Context, *RenewFileSetRequest) (*types.Empty, error)
	// ComposeFileSet composes a file set from a list of file sets.
	ComposeFileSet(context.Context, *ComposeFileSetRequest) (*CreateFileSetResponse, error)
	ShardFileSet(context.Context, *ShardFileSetRequest) (*ShardFileSetResponse, error)
	// CheckStorage runs integrity checks for the storage layer.
	CheckStorage(context.Context, *CheckStorageRequest) (*CheckStorageResponse, error)
	PutCache(context.Context, *PutCacheRequest) (*types.Empty, error)
	GetCache(context.Context, *GetCacheRequest) (*GetCacheResponse, error)
	ClearCache(context.Context, *ClearCacheRequest) (*types.Empty, error)
	// RunLoadTest runs a load test.
	RunLoadTest(context.Context, *RunLoadTestRequest) (*RunLoadTestResponse, error)
	// RunLoadTestDefault runs the default load tests.
	RunLoadTestDefault(context.Context, *types.Empty) (*RunLoadTestResponse, error)
	// ListTask lists PFS tasks
	ListTask(*task.ListTaskRequest, API_ListTaskServer) error
	// Egress writes data from a commit to an external system
	Egress(context.Context, *EgressRequest) (*EgressResponse, error)
	// Project API
	// CreateProject creates a new project.
	CreateProject(context.Context, *CreateProjectRequest) (*types.Empty, error)
	// InspectProject returns info about a project.
	InspectProject(context.Context, *InspectProjectRequest) (*ProjectInfo, error)
	// ListProject returns info about all projects.
	ListProject(*ListProjectRequest, API_ListProjectServer) error
	// DeleteProject deletes a project.
	DeleteProject(context.Context, *DeleteProjectRequest) (*types.Empty, error)
}

// UnimplementedAPIServer can be embedded to have forward compatible implementations.
type UnimplementedAPIServer struct {
}

func (*UnimplementedAPIServer) CreateRepo(ctx context.Context, req *CreateRepoRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRepo not implemented")
}
func (*UnimplementedAPIServer) InspectRepo(ctx context.Context, req *InspectRepoRequest) (*RepoInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectRepo not implemented")
}
func (*UnimplementedAPIServer) ListRepo(req *ListRepoRequest, srv API_ListRepoServer) error {
	return status.Errorf(codes.Unimplemented, "method ListRepo not implemented")
}
func (*UnimplementedAPIServer) DeleteRepo(ctx context.Context, req *DeleteRepoRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRepo not implemented")
}
func (*UnimplementedAPIServer) DeleteRepos(ctx context.Context, req *DeleteReposRequest) (*DeleteReposResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRepos not implemented")
}
func (*UnimplementedAPIServer) StartCommit(ctx context.Context, req *StartCommitRequest) (*Commit, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartCommit not implemented")
}
func (*UnimplementedAPIServer) FinishCommit(ctx context.Context, req *FinishCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FinishCommit not implemented")
}
func (*UnimplementedAPIServer) ClearCommit(ctx context.Context, req *ClearCommitRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearCommit not implemented")
}
func (*UnimplementedAPIServer) InspectCommit(ctx context.Context, req *InspectCommitRequest) (*CommitInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectCommit not implemented")
}
func (*UnimplementedAPIServer) ListCommit(req *ListCommitRequest, srv API_ListCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method ListCommit not implemented")
}
func (*UnimplementedAPIServer) SubscribeCommit(req *SubscribeCommitRequest, srv API_SubscribeCommitServer) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeCommit not implemented")
}
func (*UnimplementedAPIServer) InspectCommitSet(req *InspectCommitSetRequest, srv API_InspectCommitSetServer) error {
	return status.Errorf(codes.Unimplemented, "method InspectCommitSet not implemented")
}
func (*UnimplementedAPIServer) ListCommitSet(req *ListCommitSetRequest, srv API_ListCommitSetServer) error {
	return status.Errorf(codes.Unimplemented, "method ListCommitSet not implemented")
}
func (*UnimplementedAPIServer) SquashCommitSet(ctx context.Context, req *SquashCommitSetRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SquashCommitSet not implemented")
}
func (*UnimplementedAPIServer) DropCommitSet(ctx context.Context, req *DropCommitSetRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DropCommitSet not implemented")
}
func (*UnimplementedAPIServer) FindCommits(req *FindCommitsRequest, srv API_FindCommitsServer) error {
	return status.Errorf(codes.Unimplemented, "method FindCommits not implemented")
}
func (*UnimplementedAPIServer) CreateBranch(ctx context.Context, req *CreateBranchRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateBranch not implemented")
}
func (*UnimplementedAPIServer) InspectBranch(ctx context.Context, req *InspectBranchRequest) (*BranchInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectBranch not implemented")
}
func (*UnimplementedAPIServer) ListBranch(req *ListBranchRequest, srv API_ListBranchServer) error {
	return status.Errorf(codes.Unimplemented, "method ListBranch not implemented")
}
func (*UnimplementedAPIServer) DeleteBranch(ctx context.Context, req *DeleteBranchRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteBranch not implemented")
}
func (*UnimplementedAPIServer) ModifyFile(srv API_ModifyFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ModifyFile not implemented")
}
func (*UnimplementedAPIServer) GetFile(req *GetFileRequest, srv API_GetFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFile not implemented")
}
func (*UnimplementedAPIServer) GetFileTAR(req *GetFileRequest, srv API_GetFileTARServer) error {
	return status.Errorf(codes.Unimplemented, "method GetFileTAR not implemented")
}
func (*UnimplementedAPIServer) InspectFile(ctx context.Context, req *InspectFileRequest) (*FileInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectFile not implemented")
}
func (*UnimplementedAPIServer) ListFile(req *ListFileRequest, srv API_ListFileServer) error {
	return status.Errorf(codes.Unimplemented, "method ListFile not implemented")
}
func (*UnimplementedAPIServer) WalkFile(req *WalkFileRequest, srv API_WalkFileServer) error {
	return status.Errorf(codes.Unimplemented, "method WalkFile not implemented")
}
func (*UnimplementedAPIServer) GlobFile(req *GlobFileRequest, srv API_GlobFileServer) error {
	return status.Errorf(codes.Unimplemented, "method GlobFile not implemented")
}
func (*UnimplementedAPIServer) DiffFile(req *DiffFileRequest, srv API_DiffFileServer) error {
	return status.Errorf(codes.Unimplemented, "method DiffFile not implemented")
}
func (*UnimplementedAPIServer) ActivateAuth(ctx context.Context, req *ActivateAuthRequest) (*ActivateAuthResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateAuth not implemented")
}
func (*UnimplementedAPIServer) DeleteAll(ctx context.Context, req *types.Empty) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAll not implemented")
}
func (*UnimplementedAPIServer) Fsck(req *FsckRequest, srv API_FsckServer) error {
	return status.Errorf(codes.Unimplemented, "method Fsck not implemented")
}
func (*UnimplementedAPIServer) CreateFileSet(srv API_CreateFileSetServer) error {
	return status.Errorf(codes.Unimplemented, "method CreateFileSet not implemented")
}
func (*UnimplementedAPIServer) GetFileSet(ctx context.Context, req *GetFileSetRequest) (*CreateFileSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileSet not implemented")
}
func (*UnimplementedAPIServer) AddFileSet(ctx context.Context, req *AddFileSetRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddFileSet not implemented")
}
func (*UnimplementedAPIServer) RenewFileSet(ctx context.Context, req *RenewFileSetRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RenewFileSet not implemented")
}
func (*UnimplementedAPIServer) ComposeFileSet(ctx context.Context, req *ComposeFileSetRequest) (*CreateFileSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ComposeFileSet not implemented")
}
func (*UnimplementedAPIServer) ShardFileSet(ctx context.Context, req *ShardFileSetRequest) (*ShardFileSetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShardFileSet not implemented")
}
func (*UnimplementedAPIServer) CheckStorage(ctx context.Context, req *CheckStorageRequest) (*CheckStorageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckStorage not implemented")
}
func (*UnimplementedAPIServer) PutCache(ctx context.Context, req *PutCacheRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PutCache not implemented")
}
func (*UnimplementedAPIServer) GetCache(ctx context.Context, req *GetCacheRequest) (*GetCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCache not implemented")
}
func (*UnimplementedAPIServer) ClearCache(ctx context.Context, req *ClearCacheRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearCache not implemented")
}
func (*UnimplementedAPIServer) RunLoadTest(ctx context.Context, req *RunLoadTestRequest) (*RunLoadTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLoadTest not implemented")
}
func (*UnimplementedAPIServer) RunLoadTestDefault(ctx context.Context, req *types.Empty) (*RunLoadTestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLoadTestDefault not implemented")
}
func (*UnimplementedAPIServer) ListTask(req *task.ListTaskRequest, srv API_ListTaskServer) error {
	return status.Errorf(codes.Unimplemented, "method ListTask not implemented")
}
func (*UnimplementedAPIServer) Egress(ctx context.Context, req *EgressRequest) (*EgressResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Egress not implemented")
}
func (*UnimplementedAPIServer) CreateProject(ctx context.Context, req *CreateProjectRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (*UnimplementedAPIServer) InspectProject(ctx context.Context, req *InspectProjectRequest) (*ProjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InspectProject not implemented")
}
func (*UnimplementedAPIServer) ListProject(req *ListProjectRequest, srv API_ListProjectServer) error {
	return status.Errorf(codes.Unimplemented, "method ListProject not implemented")
}
func (*UnimplementedAPIServer) DeleteProject(ctx context.Context, req *DeleteProjectRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteProject not implemented")
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_CreateRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/CreateRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateRepo(ctx, req.(*CreateRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/InspectRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectRepo(ctx, req.(*InspectRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListRepo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListRepoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListRepo(m, &aPIListRepoServer{stream})
}

type API_ListRepoServer interface {
	Send(*RepoInfo) error
	grpc.ServerStream
}

type aPIListRepoServer struct {
	grpc.ServerStream
}

func (x *aPIListRepoServer) Send(m *RepoInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/DeleteRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteRepo(ctx, req.(*DeleteRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/DeleteRepos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteRepos(ctx, req.(*DeleteReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_StartCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).StartCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/StartCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).StartCommit(ctx, req.(*StartCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FinishCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinishCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).FinishCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/FinishCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).FinishCommit(ctx, req.(*FinishCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ClearCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ClearCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/ClearCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ClearCommit(ctx, req.(*ClearCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectCommit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectCommitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectCommit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/InspectCommit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectCommit(ctx, req.(*InspectCommitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListCommit(m, &aPIListCommitServer{stream})
}

type API_ListCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIListCommitServer struct {
	grpc.ServerStream
}

func (x *aPIListCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SubscribeCommit_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeCommitRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).SubscribeCommit(m, &aPISubscribeCommitServer{stream})
}

type API_SubscribeCommitServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPISubscribeCommitServer struct {
	grpc.ServerStream
}

func (x *aPISubscribeCommitServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectCommitSet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InspectCommitSetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).InspectCommitSet(m, &aPIInspectCommitSetServer{stream})
}

type API_InspectCommitSetServer interface {
	Send(*CommitInfo) error
	grpc.ServerStream
}

type aPIInspectCommitSetServer struct {
	grpc.ServerStream
}

func (x *aPIInspectCommitSetServer) Send(m *CommitInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ListCommitSet_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListCommitSetRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListCommitSet(m, &aPIListCommitSetServer{stream})
}

type API_ListCommitSetServer interface {
	Send(*CommitSetInfo) error
	grpc.ServerStream
}

type aPIListCommitSetServer struct {
	grpc.ServerStream
}

func (x *aPIListCommitSetServer) Send(m *CommitSetInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_SquashCommitSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SquashCommitSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).SquashCommitSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/SquashCommitSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).SquashCommitSet(ctx, req.(*SquashCommitSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DropCommitSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DropCommitSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DropCommitSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/DropCommitSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DropCommitSet(ctx, req.(*DropCommitSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_FindCommits_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FindCommitsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).FindCommits(m, &aPIFindCommitsServer{stream})
}

type API_FindCommitsServer interface {
	Send(*FindCommitsResponse) error
	grpc.ServerStream
}

type aPIFindCommitsServer struct {
	grpc.ServerStream
}

func (x *aPIFindCommitsServer) Send(m *FindCommitsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_CreateBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/CreateBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateBranch(ctx, req.(*CreateBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/InspectBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectBranch(ctx, req.(*InspectBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListBranch_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListBranchRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListBranch(m, &aPIListBranchServer{stream})
}

type API_ListBranchServer interface {
	Send(*BranchInfo) error
	grpc.ServerStream
}

type aPIListBranchServer struct {
	grpc.ServerStream
}

func (x *aPIListBranchServer) Send(m *BranchInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteBranch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBranchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteBranch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/DeleteBranch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteBranch(ctx, req.(*DeleteBranchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ModifyFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).ModifyFile(&aPIModifyFileServer{stream})
}

type API_ModifyFileServer interface {
	SendAndClose(*types.Empty) error
	Recv() (*ModifyFileRequest, error)
	grpc.ServerStream
}

type aPIModifyFileServer struct {
	grpc.ServerStream
}

func (x *aPIModifyFileServer) SendAndClose(m *types.Empty) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPIModifyFileServer) Recv() (*ModifyFileRequest, error) {
	m := new(ModifyFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetFile(m, &aPIGetFileServer{stream})
}

type API_GetFileServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type aPIGetFileServer struct {
	grpc.ServerStream
}

func (x *aPIGetFileServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GetFileTAR_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetFileTAR(m, &aPIGetFileTARServer{stream})
}

type API_GetFileTARServer interface {
	Send(*types.BytesValue) error
	grpc.ServerStream
}

type aPIGetFileTARServer struct {
	grpc.ServerStream
}

func (x *aPIGetFileTARServer) Send(m *types.BytesValue) error {
	return x.ServerStream.SendMsg(m)
}

func _API_InspectFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/InspectFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectFile(ctx, req.(*InspectFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListFile(m, &aPIListFileServer{stream})
}

type API_ListFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIListFileServer struct {
	grpc.ServerStream
}

func (x *aPIListFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_WalkFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WalkFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).WalkFile(m, &aPIWalkFileServer{stream})
}

type API_WalkFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIWalkFileServer struct {
	grpc.ServerStream
}

func (x *aPIWalkFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_GlobFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GlobFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GlobFile(m, &aPIGlobFileServer{stream})
}

type API_GlobFileServer interface {
	Send(*FileInfo) error
	grpc.ServerStream
}

type aPIGlobFileServer struct {
	grpc.ServerStream
}

func (x *aPIGlobFileServer) Send(m *FileInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DiffFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(DiffFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).DiffFile(m, &aPIDiffFileServer{stream})
}

type API_DiffFileServer interface {
	Send(*DiffFileResponse) error
	grpc.ServerStream
}

type aPIDiffFileServer struct {
	grpc.ServerStream
}

func (x *aPIDiffFileServer) Send(m *DiffFileResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ActivateAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivateAuthRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ActivateAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/ActivateAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ActivateAuth(ctx, req.(*ActivateAuthRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_DeleteAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/DeleteAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteAll(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_Fsck_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FsckRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).Fsck(m, &aPIFsckServer{stream})
}

type API_FsckServer interface {
	Send(*FsckResponse) error
	grpc.ServerStream
}

type aPIFsckServer struct {
	grpc.ServerStream
}

func (x *aPIFsckServer) Send(m *FsckResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _API_CreateFileSet_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(APIServer).CreateFileSet(&aPICreateFileSetServer{stream})
}

type API_CreateFileSetServer interface {
	SendAndClose(*CreateFileSetResponse) error
	Recv() (*ModifyFileRequest, error)
	grpc.ServerStream
}

type aPICreateFileSetServer struct {
	grpc.ServerStream
}

func (x *aPICreateFileSetServer) SendAndClose(m *CreateFileSetResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *aPICreateFileSetServer) Recv() (*ModifyFileRequest, error) {
	m := new(ModifyFileRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _API_GetFileSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetFileSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/GetFileSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetFileSet(ctx, req.(*GetFileSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_AddFileSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddFileSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).AddFileSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/AddFileSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).AddFileSet(ctx, req.(*AddFileSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RenewFileSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenewFileSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RenewFileSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/RenewFileSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RenewFileSet(ctx, req.(*RenewFileSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ComposeFileSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComposeFileSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ComposeFileSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/ComposeFileSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ComposeFileSet(ctx, req.(*ComposeFileSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ShardFileSet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShardFileSetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ShardFileSet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/ShardFileSet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ShardFileSet(ctx, req.(*ShardFileSetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CheckStorage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckStorageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CheckStorage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/CheckStorage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CheckStorage(ctx, req.(*CheckStorageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_PutCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PutCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).PutCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/PutCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).PutCache(ctx, req.(*PutCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/GetCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetCache(ctx, req.(*GetCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ClearCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ClearCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/ClearCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ClearCache(ctx, req.(*ClearCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunLoadTest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunLoadTestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunLoadTest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/RunLoadTest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunLoadTest(ctx, req.(*RunLoadTestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_RunLoadTestDefault_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).RunLoadTestDefault(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/RunLoadTestDefault",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).RunLoadTestDefault(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListTask_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(task.ListTaskRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListTask(m, &aPIListTaskServer{stream})
}

type API_ListTaskServer interface {
	Send(*task.TaskInfo) error
	grpc.ServerStream
}

type aPIListTaskServer struct {
	grpc.ServerStream
}

func (x *aPIListTaskServer) Send(m *task.TaskInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_Egress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).Egress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/Egress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).Egress(ctx, req.(*EgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/CreateProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_InspectProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InspectProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).InspectProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/InspectProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).InspectProject(ctx, req.(*InspectProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListProject_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListProjectRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).ListProject(m, &aPIListProjectServer{stream})
}

type API_ListProjectServer interface {
	Send(*ProjectInfo) error
	grpc.ServerStream
}

type aPIListProjectServer struct {
	grpc.ServerStream
}

func (x *aPIListProjectServer) Send(m *ProjectInfo) error {
	return x.ServerStream.SendMsg(m)
}

func _API_DeleteProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).DeleteProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pfs_v2.API/DeleteProject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).DeleteProject(ctx, req.(*DeleteProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pfs_v2.API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRepo",
			Handler:    _API_CreateRepo_Handler,
		},
		{
			MethodName: "InspectRepo",
			Handler:    _API_InspectRepo_Handler,
		},
		{
			MethodName: "DeleteRepo",
			Handler:    _API_DeleteRepo_Handler,
		},
		{
			MethodName: "DeleteRepos",
			Handler:    _API_DeleteRepos_Handler,
		},
		{
			MethodName: "StartCommit",
			Handler:    _API_StartCommit_Handler,
		},
		{
			MethodName: "FinishCommit",
			Handler:    _API_FinishCommit_Handler,
		},
		{
			MethodName: "ClearCommit",
			Handler:    _API_ClearCommit_Handler,
		},
		{
			MethodName: "InspectCommit",
			Handler:    _API_InspectCommit_Handler,
		},
		{
			MethodName: "SquashCommitSet",
			Handler:    _API_SquashCommitSet_Handler,
		},
		{
			MethodName: "DropCommitSet",
			Handler:    _API_DropCommitSet_Handler,
		},
		{
			MethodName: "CreateBranch",
			Handler:    _API_CreateBranch_Handler,
		},
		{
			MethodName: "InspectBranch",
			Handler:    _API_InspectBranch_Handler,
		},
		{
			MethodName: "DeleteBranch",
			Handler:    _API_DeleteBranch_Handler,
		},
		{
			MethodName: "InspectFile",
			Handler:    _API_InspectFile_Handler,
		},
		{
			MethodName: "ActivateAuth",
			Handler:    _API_ActivateAuth_Handler,
		},
		{
			MethodName: "DeleteAll",
			Handler:    _API_DeleteAll_Handler,
		},
		{
			MethodName: "GetFileSet",
			Handler:    _API_GetFileSet_Handler,
		},
		{
			MethodName: "AddFileSet",
			Handler:    _API_AddFileSet_Handler,
		},
		{
			MethodName: "RenewFileSet",
			Handler:    _API_RenewFileSet_Handler,
		},
		{
			MethodName: "ComposeFileSet",
			Handler:    _API_ComposeFileSet_Handler,
		},
		{
			MethodName: "ShardFileSet",
			Handler:    _API_ShardFileSet_Handler,
		},
		{
			MethodName: "CheckStorage",
			Handler:    _API_CheckStorage_Handler,
		},
		{
			MethodName: "PutCache",
			Handler:    _API_PutCache_Handler,
		},
		{
			MethodName: "GetCache",
			Handler:    _API_GetCache_Handler,
		},
		{
			MethodName: "ClearCache",
			Handler:    _API_ClearCache_Handler,
		},
		{
			MethodName: "RunLoadTest",
			Handler:    _API_RunLoadTest_Handler,
		},
		{
			MethodName: "RunLoadTestDefault",
			Handler:    _API_RunLoadTestDefault_Handler,
		},
		{
			MethodName: "Egress",
			Handler:    _API_Egress_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _API_CreateProject_Handler,
		},
		{
			MethodName: "InspectProject",
			Handler:    _API_InspectProject_Handler,
		},
		{
			MethodName: "DeleteProject",
			Handler:    _API_DeleteProject_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListRepo",
			Handler:       _API_ListRepo_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListCommit",
			Handler:       _API_ListCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeCommit",
			Handler:       _API_SubscribeCommit_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InspectCommitSet",
			Handler:       _API_InspectCommitSet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListCommitSet",
			Handler:       _API_ListCommitSet_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "FindCommits",
			Handler:       _API_FindCommits_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListBranch",
			Handler:       _API_ListBranch_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ModifyFile",
			Handler:       _API_ModifyFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _API_GetFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFileTAR",
			Handler:       _API_GetFileTAR_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListFile",
			Handler:       _API_ListFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WalkFile",
			Handler:       _API_WalkFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GlobFile",
			Handler:       _API_GlobFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "DiffFile",
			Handler:       _API_DiffFile_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Fsck",
			Handler:       _API_Fsck_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CreateFileSet",
			Handler:       _API_CreateFileSet_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "ListTask",
			Handler:       _API_ListTask_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListProject",
			Handler:       _API_ListProject_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pfs/pfs.proto",
}

func (m *Repo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Repo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Repo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Branch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Branch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Branch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *File) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datum) > 0 {
		i -= len(m.Datum)
		copy(dAtA[i:], m.Datum)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Datum)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.AuthInfo != nil {
		{
			size, err := m.AuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Branches) > 0 {
		for iNdEx := len(m.Branches) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Branches[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.SizeBytesUpperBound != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytesUpperBound))
		i--
		dAtA[i] = 0x18
	}
	if m.Created != nil {
		{
			size, err := m.Created.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RepoInfo_Details) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RepoInfo_Details) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RepoInfo_Details) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AuthInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Roles) > 0 {
		for iNdEx := len(m.Roles) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Roles[iNdEx])
			copy(dAtA[i:], m.Roles[iNdEx])
			i = encodeVarintPfs(dAtA, i, uint64(len(m.Roles[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Permissions) > 0 {
		dAtA9 := make([]byte, len(m.Permissions)*10)
		var j8 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintPfs(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BranchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BranchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BranchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.DirectProvenance) > 0 {
		for iNdEx := len(m.DirectProvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DirectProvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Subvenance) > 0 {
		for iNdEx := len(m.Subvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Subvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Trigger) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Trigger) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Trigger) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commits != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Commits))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Size_) > 0 {
		i -= len(m.Size_)
		copy(dAtA[i:], m.Size_)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Size_)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CronSpec) > 0 {
		i -= len(m.CronSpec)
		copy(dAtA[i:], m.CronSpec)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.CronSpec)))
		i--
		dAtA[i] = 0x1a
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitOrigin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitOrigin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitOrigin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Kind != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Kind))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DirectProvenance) > 0 {
		for iNdEx := len(m.DirectProvenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DirectProvenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if m.Details != nil {
		{
			size, err := m.Details.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.SizeBytesUpperBound != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytesUpperBound))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x52
	}
	if m.Finished != nil {
		{
			size, err := m.Finished.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Finishing != nil {
		{
			size, err := m.Finishing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Started != nil {
		{
			size, err := m.Started.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.ChildCommits) > 0 {
		for iNdEx := len(m.ChildCommits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChildCommits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.ParentCommit != nil {
		{
			size, err := m.ParentCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Origin != nil {
		{
			size, err := m.Origin.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitInfo_Details) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitInfo_Details) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitInfo_Details) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ValidatingTime != nil {
		{
			size, err := m.ValidatingTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.CompactingTime != nil {
		{
			size, err := m.CompactingTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommitSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitSetInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitSetInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitSetInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Commits) > 0 {
		for iNdEx := len(m.Commits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CommitSet != nil {
		{
			size, err := m.CommitSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SizeBytes != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.Committed != nil {
		{
			size, err := m.Committed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FileType != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.FileType))
		i--
		dAtA[i] = 0x10
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Project) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Project) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Project) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProjectInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProjectInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProjectInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthInfo != nil {
		{
			size, err := m.AuthInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Update {
		i--
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Projects) > 0 {
		for iNdEx := len(m.Projects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteRepoRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteRepoRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteRepoRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteReposRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReposRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReposRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Projects) > 0 {
		for iNdEx := len(m.Projects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Projects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DeleteReposResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteReposResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteReposResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Repos) > 0 {
		for iNdEx := len(m.Repos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Repos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *StartCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StartCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StartCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Parent != nil {
		{
			size, err := m.Parent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FinishCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FinishCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FinishCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Wait != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Wait))
		i--
		dAtA[i] = 0x10
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StartedTime != nil {
		{
			size, err := m.StartedTime.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.OriginKind != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.OriginKind))
		i--
		dAtA[i] = 0x38
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Number != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x20
	}
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectCommitSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectCommitSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectCommitSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Wait {
		i--
		if m.Wait {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CommitSet != nil {
		{
			size, err := m.CommitSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListCommitSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListCommitSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListCommitSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SquashCommitSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SquashCommitSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SquashCommitSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitSet != nil {
		{
			size, err := m.CommitSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DropCommitSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DropCommitSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DropCommitSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitSet != nil {
		{
			size, err := m.CommitSet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubscribeCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubscribeCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubscribeCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OriginKind != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.OriginKind))
		i--
		dAtA[i] = 0x30
	}
	if m.All {
		i--
		if m.All {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.State != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x20
	}
	if m.From != nil {
		{
			size, err := m.From.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Branch) > 0 {
		i -= len(m.Branch)
		copy(dAtA[i:], m.Branch)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Branch)))
		i--
		dAtA[i] = 0x12
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearCommitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearCommitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearCommitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NewCommitSet {
		i--
		if m.NewCommitSet {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Trigger != nil {
		{
			size, err := m.Trigger.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Provenance) > 0 {
		for iNdEx := len(m.Provenance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Provenance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Head != nil {
		{
			size, err := m.Head.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindCommitsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCommitsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCommitsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Limit != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x12
	}
	if m.Start != nil {
		{
			size, err := m.Start.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindCommitsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindCommitsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCommitsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CommitsSearched != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.CommitsSearched))
		i--
		dAtA[i] = 0x18
	}
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *FindCommitsResponse_FoundCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCommitsResponse_FoundCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.FoundCommit != nil {
		{
			size, err := m.FoundCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *FindCommitsResponse_LastSearchedCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindCommitsResponse_LastSearchedCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.LastSearchedCommit != nil {
		{
			size, err := m.LastSearchedCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *InspectBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Repo != nil {
		{
			size, err := m.Repo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteBranchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteBranchRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteBranchRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateProjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateProjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateProjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Update {
		i--
		if m.Update {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectProjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectProjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectProjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListProjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListProjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListProjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteProjectRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteProjectRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteProjectRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Force {
		i--
		if m.Force {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Project != nil {
		{
			size, err := m.Project.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Source != nil {
		{
			size := m.Source.Size()
			i -= size
			if _, err := m.Source.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Datum) > 0 {
		i -= len(m.Datum)
		copy(dAtA[i:], m.Datum)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Datum)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddFile_Raw) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddFile_Raw) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raw != nil {
		{
			size, err := m.Raw.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *AddFile_Url) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddFile_Url) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Url != nil {
		{
			size, err := m.Url.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *AddFile_URLSource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFile_URLSource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddFile_URLSource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Concurrency != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Concurrency))
		i--
		dAtA[i] = 0x18
	}
	if m.Recursive {
		i--
		if m.Recursive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datum) > 0 {
		i -= len(m.Datum)
		copy(dAtA[i:], m.Datum)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Datum)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Path) > 0 {
		i -= len(m.Path)
		copy(dAtA[i:], m.Path)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Path)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CopyFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Append {
		i--
		if m.Append {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Src != nil {
		{
			size, err := m.Src.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Datum) > 0 {
		i -= len(m.Datum)
		copy(dAtA[i:], m.Datum)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Datum)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Dst) > 0 {
		i -= len(m.Dst)
		copy(dAtA[i:], m.Dst)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Dst)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModifyFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModifyFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Body != nil {
		{
			size := m.Body.Size()
			i -= size
			if _, err := m.Body.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ModifyFileRequest_SetCommit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest_SetCommit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SetCommit != nil {
		{
			size, err := m.SetCommit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ModifyFileRequest_AddFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest_AddFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddFile != nil {
		{
			size, err := m.AddFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ModifyFileRequest_DeleteFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest_DeleteFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DeleteFile != nil {
		{
			size, err := m.DeleteFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ModifyFileRequest_CopyFile) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModifyFileRequest_CopyFile) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CopyFile != nil {
		{
			size, err := m.CopyFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *GetFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PathRange != nil {
		{
			size, err := m.PathRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Offset != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if len(m.URL) > 0 {
		i -= len(m.URL)
		copy(dAtA[i:], m.URL)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.URL)))
		i--
		dAtA[i] = 0x12
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InspectFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InspectFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InspectFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ListFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ListFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ListFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Number != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x20
	}
	if m.PaginationMarker != nil {
		{
			size, err := m.PaginationMarker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalkFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalkFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalkFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Reverse {
		i--
		if m.Reverse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Number != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x18
	}
	if m.PaginationMarker != nil {
		{
			size, err := m.PaginationMarker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GlobFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PathRange != nil {
		{
			size, err := m.PathRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Pattern) > 0 {
		i -= len(m.Pattern)
		copy(dAtA[i:], m.Pattern)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Pattern)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiffFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiffFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Shallow {
		i--
		if m.Shallow {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.OldFile != nil {
		{
			size, err := m.OldFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewFile != nil {
		{
			size, err := m.NewFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DiffFileResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DiffFileResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DiffFileResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OldFile != nil {
		{
			size, err := m.OldFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.NewFile != nil {
		{
			size, err := m.NewFile.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FsckRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsckRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ZombieCheck != nil {
		{
			size := m.ZombieCheck.Size()
			i -= size
			if _, err := m.ZombieCheck.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Fix {
		i--
		if m.Fix {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FsckRequest_ZombieTarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckRequest_ZombieTarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ZombieTarget != nil {
		{
			size, err := m.ZombieTarget.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *FsckRequest_ZombieAll) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckRequest_ZombieAll) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i--
	if m.ZombieAll {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *FsckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FsckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FsckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fix) > 0 {
		i -= len(m.Fix)
		copy(dAtA[i:], m.Fix)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Fix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateFileSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateFileSetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateFileSetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileSetId) > 0 {
		i -= len(m.FileSetId)
		copy(dAtA[i:], m.FileSetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FileSetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetFileSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetFileSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetFileSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddFileSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddFileSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddFileSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileSetId) > 0 {
		i -= len(m.FileSetId)
		copy(dAtA[i:], m.FileSetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FileSetId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RenewFileSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RenewFileSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RenewFileSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TtlSeconds != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TtlSeconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FileSetId) > 0 {
		i -= len(m.FileSetId)
		copy(dAtA[i:], m.FileSetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FileSetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComposeFileSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComposeFileSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComposeFileSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Compact {
		i--
		if m.Compact {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.TtlSeconds != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.TtlSeconds))
		i--
		dAtA[i] = 0x10
	}
	if len(m.FileSetIds) > 0 {
		for iNdEx := len(m.FileSetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileSetIds[iNdEx])
			copy(dAtA[i:], m.FileSetIds[iNdEx])
			i = encodeVarintPfs(dAtA, i, uint64(len(m.FileSetIds[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShardFileSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardFileSetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardFileSetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FileSetId) > 0 {
		i -= len(m.FileSetId)
		copy(dAtA[i:], m.FileSetId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.FileSetId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PathRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PathRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PathRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Upper) > 0 {
		i -= len(m.Upper)
		copy(dAtA[i:], m.Upper)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Upper)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Lower) > 0 {
		i -= len(m.Lower)
		copy(dAtA[i:], m.Lower)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Lower)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ShardFileSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardFileSetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardFileSetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPfs(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CheckStorageRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckStorageRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckStorageRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ChunkEnd) > 0 {
		i -= len(m.ChunkEnd)
		copy(dAtA[i:], m.ChunkEnd)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ChunkEnd)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChunkBegin) > 0 {
		i -= len(m.ChunkBegin)
		copy(dAtA[i:], m.ChunkBegin)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.ChunkBegin)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReadChunkData {
		i--
		if m.ReadChunkData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckStorageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckStorageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckStorageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChunkObjectCount != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.ChunkObjectCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PutCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FileSetIds) > 0 {
		for iNdEx := len(m.FileSetIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.FileSetIds[iNdEx])
			copy(dAtA[i:], m.FileSetIds[iNdEx])
			i = encodeVarintPfs(dAtA, i, uint64(len(m.FileSetIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetCacheResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetCacheResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetCacheResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Value != nil {
		{
			size, err := m.Value.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClearCacheRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClearCacheRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClearCacheRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TagPrefix) > 0 {
		i -= len(m.TagPrefix)
		copy(dAtA[i:], m.TagPrefix)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.TagPrefix)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ActivateAuthRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateAuthRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ActivateAuthResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivateAuthResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivateAuthResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RunLoadTestRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunLoadTestRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunLoadTestRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seed != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x18
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RunLoadTestResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RunLoadTestResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RunLoadTestResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StateId) > 0 {
		i -= len(m.StateId)
		copy(dAtA[i:], m.StateId)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.StateId)))
		i--
		dAtA[i] = 0x32
	}
	if m.Duration != nil {
		{
			size, err := m.Duration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x22
	}
	if m.Seed != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x18
	}
	if m.Branch != nil {
		{
			size, err := m.Branch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Spec) > 0 {
		i -= len(m.Spec)
		copy(dAtA[i:], m.Spec)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Spec)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ObjectStorageEgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectStorageEgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ObjectStorageEgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SQLDatabaseEgress) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLDatabaseEgress) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SQLDatabaseEgress) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Secret != nil {
		{
			size, err := m.Secret.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.FileFormat != nil {
		{
			size, err := m.FileFormat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SQLDatabaseEgress_FileFormat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLDatabaseEgress_FileFormat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SQLDatabaseEgress_FileFormat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Columns[iNdEx])
			copy(dAtA[i:], m.Columns[iNdEx])
			i = encodeVarintPfs(dAtA, i, uint64(len(m.Columns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Type != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SQLDatabaseEgress_Secret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SQLDatabaseEgress_Secret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SQLDatabaseEgress_Secret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPfs(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EgressRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Target != nil {
		{
			size := m.Target.Size()
			i -= size
			if _, err := m.Target.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EgressRequest_ObjectStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressRequest_ObjectStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectStorage != nil {
		{
			size, err := m.ObjectStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EgressRequest_SqlDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressRequest_SqlDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SqlDatabase != nil {
		{
			size, err := m.SqlDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *EgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != nil {
		{
			size := m.Result.Size()
			i -= size
			if _, err := m.Result.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *EgressResponse_ObjectStorage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressResponse_ObjectStorage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ObjectStorage != nil {
		{
			size, err := m.ObjectStorage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *EgressResponse_SqlDatabase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressResponse_SqlDatabase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SqlDatabase != nil {
		{
			size, err := m.SqlDatabase.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPfs(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *EgressResponse_ObjectStorageResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressResponse_ObjectStorageResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressResponse_ObjectStorageResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BytesWritten != 0 {
		i = encodeVarintPfs(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EgressResponse_SQLDatabaseResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EgressResponse_SQLDatabaseResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EgressResponse_SQLDatabaseResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RowsWritten) > 0 {
		for k := range m.RowsWritten {
			v := m.RowsWritten[k]
			baseI := i
			i = encodeVarintPfs(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPfs(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPfs(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintPfs(dAtA []byte, offset int, v uint64) int {
	offset -= sovPfs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Repo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Branch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Datum)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Created != nil {
		l = m.Created.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytesUpperBound != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytesUpperBound))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Branches) > 0 {
		for _, e := range m.Branches {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.AuthInfo != nil {
		l = m.AuthInfo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RepoInfo_Details) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovPfs(uint64(e))
		}
		n += 1 + sovPfs(uint64(l)) + l
	}
	if len(m.Roles) > 0 {
		for _, s := range m.Roles {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BranchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.Subvenance) > 0 {
		for _, e := range m.Subvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if len(m.DirectProvenance) > 0 {
		for _, e := range m.DirectProvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Trigger) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.All {
		n += 2
	}
	l = len(m.CronSpec)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Size_)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Commits != 0 {
		n += 1 + sovPfs(uint64(m.Commits))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitOrigin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovPfs(uint64(m.Kind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Origin != nil {
		l = m.Origin.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.ParentCommit != nil {
		l = m.ParentCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.ChildCommits) > 0 {
		for _, e := range m.ChildCommits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Started != nil {
		l = m.Started.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Finishing != nil {
		l = m.Finishing.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Finished != nil {
		l = m.Finished.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytesUpperBound != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytesUpperBound))
	}
	if m.Details != nil {
		l = m.Details.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.DirectProvenance) > 0 {
		for _, e := range m.DirectProvenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitInfo_Details) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	if m.CompactingTime != nil {
		l = m.CompactingTime.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.ValidatingTime != nil {
		l = m.ValidatingTime.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitSetInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitSet != nil {
		l = m.CommitSet.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Commits) > 0 {
		for _, e := range m.Commits {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.FileType != 0 {
		n += 1 + sovPfs(uint64(m.FileType))
	}
	if m.Committed != nil {
		l = m.Committed.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovPfs(uint64(m.SizeBytes))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Project) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProjectInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.AuthInfo != nil {
		l = m.AuthInfo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Projects) > 0 {
		for _, e := range m.Projects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteRepoRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteReposRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Projects) > 0 {
		for _, e := range m.Projects {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Force {
		n += 2
	}
	if m.All {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteReposResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Repos) > 0 {
		for _, e := range m.Repos {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StartCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Parent != nil {
		l = m.Parent.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FinishCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Wait != 0 {
		n += 1 + sovPfs(uint64(m.Wait))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPfs(uint64(m.Number))
	}
	if m.Reverse {
		n += 2
	}
	if m.All {
		n += 2
	}
	if m.OriginKind != 0 {
		n += 1 + sovPfs(uint64(m.OriginKind))
	}
	if m.StartedTime != nil {
		l = m.StartedTime.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectCommitSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitSet != nil {
		l = m.CommitSet.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Wait {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListCommitSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SquashCommitSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitSet != nil {
		l = m.CommitSet.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DropCommitSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommitSet != nil {
		l = m.CommitSet.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SubscribeCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Branch)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.From != nil {
		l = m.From.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovPfs(uint64(m.State))
	}
	if m.All {
		n += 2
	}
	if m.OriginKind != 0 {
		n += 1 + sovPfs(uint64(m.OriginKind))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearCommitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Head != nil {
		l = m.Head.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.Provenance) > 0 {
		for _, e := range m.Provenance {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.Trigger != nil {
		l = m.Trigger.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.NewCommitSet {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCommitsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovPfs(uint64(m.Limit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCommitsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	if m.CommitsSearched != 0 {
		n += 1 + sovPfs(uint64(m.CommitsSearched))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FindCommitsResponse_FoundCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FoundCommit != nil {
		l = m.FoundCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *FindCommitsResponse_LastSearchedCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastSearchedCommit != nil {
		l = m.LastSearchedCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *InspectBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Repo != nil {
		l = m.Repo.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteBranchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateProjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Update {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectProjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListProjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteProjectRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Project != nil {
		l = m.Project.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Force {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Datum)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Source != nil {
		n += m.Source.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFile_Raw) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raw != nil {
		l = m.Raw.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *AddFile_Url) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Url != nil {
		l = m.Url.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *AddFile_URLSource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Recursive {
		n += 2
	}
	if m.Concurrency != 0 {
		n += 1 + sovPfs(uint64(m.Concurrency))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Datum)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Dst)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Datum)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Src != nil {
		l = m.Src.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Append {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ModifyFileRequest_SetCommit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SetCommit != nil {
		l = m.SetCommit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *ModifyFileRequest_AddFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddFile != nil {
		l = m.AddFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *ModifyFileRequest_DeleteFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteFile != nil {
		l = m.DeleteFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *ModifyFileRequest_CopyFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CopyFile != nil {
		l = m.CopyFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *GetFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Offset != 0 {
		n += 1 + sovPfs(uint64(m.Offset))
	}
	if m.PathRange != nil {
		l = m.PathRange.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InspectFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ListFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.PaginationMarker != nil {
		l = m.PaginationMarker.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPfs(uint64(m.Number))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WalkFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.PaginationMarker != nil {
		l = m.PaginationMarker.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovPfs(uint64(m.Number))
	}
	if m.Reverse {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GlobFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Pattern)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.PathRange != nil {
		l = m.PathRange.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiffFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewFile != nil {
		l = m.NewFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OldFile != nil {
		l = m.OldFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Shallow {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DiffFileResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewFile != nil {
		l = m.NewFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.OldFile != nil {
		l = m.OldFile.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsckRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fix {
		n += 2
	}
	if m.ZombieCheck != nil {
		n += m.ZombieCheck.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FsckRequest_ZombieTarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ZombieTarget != nil {
		l = m.ZombieTarget.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *FsckRequest_ZombieAll) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 2
	return n
}
func (m *FsckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fix)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateFileSetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileSetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetFileSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddFileSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.FileSetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RenewFileSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileSetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.TtlSeconds != 0 {
		n += 1 + sovPfs(uint64(m.TtlSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ComposeFileSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FileSetIds) > 0 {
		for _, s := range m.FileSetIds {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.TtlSeconds != 0 {
		n += 1 + sovPfs(uint64(m.TtlSeconds))
	}
	if m.Compact {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardFileSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FileSetId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PathRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Lower)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Upper)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardFileSetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckStorageRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReadChunkData {
		n += 2
	}
	l = len(m.ChunkBegin)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.ChunkEnd)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckStorageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChunkObjectCount != 0 {
		n += 1 + sovPfs(uint64(m.ChunkObjectCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if len(m.FileSetIds) > 0 {
		for _, s := range m.FileSetIds {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetCacheResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Value != nil {
		l = m.Value.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ClearCacheRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TagPrefix)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivateAuthResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunLoadTestRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Seed != 0 {
		n += 1 + sovPfs(uint64(m.Seed))
	}
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RunLoadTestResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Spec)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Branch != nil {
		l = m.Branch.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Seed != 0 {
		n += 1 + sovPfs(uint64(m.Seed))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Duration != nil {
		l = m.Duration.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.StateId)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectStorageEgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SQLDatabaseEgress) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.FileFormat != nil {
		l = m.FileFormat.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Secret != nil {
		l = m.Secret.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SQLDatabaseEgress_FileFormat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovPfs(uint64(m.Type))
	}
	if len(m.Columns) > 0 {
		for _, s := range m.Columns {
			l = len(s)
			n += 1 + l + sovPfs(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SQLDatabaseEgress_Secret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	if m.Target != nil {
		n += m.Target.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressRequest_ObjectStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectStorage != nil {
		l = m.ObjectStorage.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *EgressRequest_SqlDatabase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlDatabase != nil {
		l = m.SqlDatabase.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *EgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != nil {
		n += m.Result.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressResponse_ObjectStorage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ObjectStorage != nil {
		l = m.ObjectStorage.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *EgressResponse_SqlDatabase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlDatabase != nil {
		l = m.SqlDatabase.Size()
		n += 1 + l + sovPfs(uint64(l))
	}
	return n
}
func (m *EgressResponse_ObjectStorageResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesWritten != 0 {
		n += 1 + sovPfs(uint64(m.BytesWritten))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EgressResponse_SQLDatabaseResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RowsWritten) > 0 {
		for k, v := range m.RowsWritten {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovPfs(uint64(len(k))) + 1 + sovPfs(uint64(v))
			n += mapEntrySize + 1 + sovPfs(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovPfs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPfs(x uint64) (n int) {
	return sovPfs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Repo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Repo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Repo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Branch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Branch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Branch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RepoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RepoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Created", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Created == nil {
				m.Created = &types.Timestamp{}
			}
			if err := m.Created.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytesUpperBound", wireType)
			}
			m.SizeBytesUpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytesUpperBound |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branches", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branches = append(m.Branches, &Branch{})
			if err := m.Branches[len(m.Branches)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthInfo == nil {
				m.AuthInfo = &AuthInfo{}
			}
			if err := m.AuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &RepoInfo_Details{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RepoInfo_Details) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v auth.Permission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= auth.Permission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthPfs
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthPfs
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]auth.Permission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v auth.Permission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= auth.Permission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Roles", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Roles = append(m.Roles, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BranchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BranchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BranchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Branch{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subvenance = append(m.Subvenance, &Branch{})
			if err := m.Subvenance[len(m.Subvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectProvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectProvenance = append(m.DirectProvenance, &Branch{})
			if err := m.DirectProvenance[len(m.DirectProvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &Trigger{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Trigger) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Trigger: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Trigger: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CronSpec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CronSpec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			m.Commits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitOrigin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitOrigin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitOrigin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Kind |= OriginKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Origin", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Origin == nil {
				m.Origin = &CommitOrigin{}
			}
			if err := m.Origin.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ParentCommit == nil {
				m.ParentCommit = &Commit{}
			}
			if err := m.ParentCommit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChildCommits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChildCommits = append(m.ChildCommits, &Commit{})
			if err := m.ChildCommits[len(m.ChildCommits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Started", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Started == nil {
				m.Started = &types.Timestamp{}
			}
			if err := m.Started.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finishing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finishing == nil {
				m.Finishing = &types.Timestamp{}
			}
			if err := m.Finishing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finished", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Finished == nil {
				m.Finished = &types.Timestamp{}
			}
			if err := m.Finished.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytesUpperBound", wireType)
			}
			m.SizeBytesUpperBound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytesUpperBound |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Details == nil {
				m.Details = &CommitInfo_Details{}
			}
			if err := m.Details.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectProvenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirectProvenance = append(m.DirectProvenance, &Commit{})
			if err := m.DirectProvenance[len(m.DirectProvenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitInfo_Details) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Details: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Details: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactingTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactingTime == nil {
				m.CompactingTime = &types.Duration{}
			}
			if err := m.CompactingTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatingTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatingTime == nil {
				m.ValidatingTime = &types.Duration{}
			}
			if err := m.ValidatingTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitSetInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitSetInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitSetInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitSet == nil {
				m.CommitSet = &CommitSet{}
			}
			if err := m.CommitSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commits = append(m.Commits, &CommitInfo{})
			if err := m.Commits[len(m.Commits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileType", wireType)
			}
			m.FileType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileType |= FileType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Committed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Committed == nil {
				m.Committed = &types.Timestamp{}
			}
			if err := m.Committed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Project) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Project: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Project: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProjectInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProjectInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProjectInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthInfo == nil {
				m.AuthInfo = &AuthInfo{}
			}
			if err := m.AuthInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projects = append(m.Projects, &Project{})
			if err := m.Projects[len(m.Projects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteRepoRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteRepoRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteRepoRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReposRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReposRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReposRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Projects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Projects = append(m.Projects, &Project{})
			if err := m.Projects[len(m.Projects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteReposResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteReposResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteReposResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Repos = append(m.Repos, &Repo{})
			if err := m.Repos[len(m.Repos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StartCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StartCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StartCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parent == nil {
				m.Parent = &Commit{}
			}
			if err := m.Parent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FinishCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FinishCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FinishCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			m.Wait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Wait |= CommitState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &Commit{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginKind", wireType)
			}
			m.OriginKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginKind |= OriginKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedTime == nil {
				m.StartedTime = &types.Timestamp{}
			}
			if err := m.StartedTime.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectCommitSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectCommitSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectCommitSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitSet == nil {
				m.CommitSet = &CommitSet{}
			}
			if err := m.CommitSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wait", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wait = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListCommitSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListCommitSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListCommitSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SquashCommitSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SquashCommitSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SquashCommitSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitSet == nil {
				m.CommitSet = &CommitSet{}
			}
			if err := m.CommitSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DropCommitSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DropCommitSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DropCommitSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitSet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitSet == nil {
				m.CommitSet = &CommitSet{}
			}
			if err := m.CommitSet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubscribeCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubscribeCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubscribeCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Branch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.From == nil {
				m.From = &Commit{}
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= CommitState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field All", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.All = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginKind", wireType)
			}
			m.OriginKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginKind |= OriginKind(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearCommitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearCommitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearCommitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Head", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Head == nil {
				m.Head = &Commit{}
			}
			if err := m.Head.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provenance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provenance = append(m.Provenance, &Branch{})
			if err := m.Provenance[len(m.Provenance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Trigger == nil {
				m.Trigger = &Trigger{}
			}
			if err := m.Trigger.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewCommitSet", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewCommitSet = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCommitsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCommitsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCommitsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Commit{}
			}
			if err := m.Start.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindCommitsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindCommitsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindCommitsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FoundCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &FindCommitsResponse_FoundCommit{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSearchedCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &FindCommitsResponse_LastSearchedCommit{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitsSearched", wireType)
			}
			m.CommitsSearched = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitsSearched |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Repo == nil {
				m.Repo = &Repo{}
			}
			if err := m.Repo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteBranchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteBranchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteBranchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateProjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateProjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateProjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectProjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectProjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectProjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListProjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListProjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListProjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteProjectRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteProjectRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteProjectRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Project", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Project == nil {
				m.Project = &Project{}
			}
			if err := m.Project.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Force", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Force = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raw", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &types.BytesValue{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &AddFile_Raw{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddFile_URLSource{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Source = &AddFile_Url{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFile_URLSource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: URLSource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: URLSource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recursive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Recursive = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concurrency", wireType)
			}
			m.Concurrency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Concurrency |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dst", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Dst = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Src", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Src == nil {
				m.Src = &File{}
			}
			if err := m.Src.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Append = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModifyFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModifyFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModifyFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SetCommit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ModifyFileRequest_SetCommit{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ModifyFileRequest_AddFile{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DeleteFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ModifyFileRequest_DeleteFile{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CopyFile{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &ModifyFileRequest_CopyFile{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PathRange == nil {
				m.PathRange = &PathRange{}
			}
			if err := m.PathRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InspectFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InspectFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InspectFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaginationMarker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaginationMarker == nil {
				m.PaginationMarker = &File{}
			}
			if err := m.PaginationMarker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalkFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalkFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalkFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaginationMarker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PaginationMarker == nil {
				m.PaginationMarker = &File{}
			}
			if err := m.PaginationMarker.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reverse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reverse = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pattern = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PathRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PathRange == nil {
				m.PathRange = &PathRange{}
			}
			if err := m.PathRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewFile == nil {
				m.NewFile = &File{}
			}
			if err := m.NewFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldFile == nil {
				m.OldFile = &File{}
			}
			if err := m.OldFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shallow", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Shallow = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DiffFileResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DiffFileResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DiffFileResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NewFile == nil {
				m.NewFile = &FileInfo{}
			}
			if err := m.NewFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldFile", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OldFile == nil {
				m.OldFile = &FileInfo{}
			}
			if err := m.OldFile.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsckRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsckRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsckRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fix = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZombieTarget", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ZombieCheck = &FsckRequest_ZombieTarget{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZombieAll", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ZombieCheck = &FsckRequest_ZombieAll{b}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FsckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FsckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FsckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateFileSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateFileSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateFileSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetFileSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetFileSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetFileSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddFileSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddFileSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddFileSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RenewFileSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RenewFileSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RenewFileSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSeconds", wireType)
			}
			m.TtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComposeFileSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComposeFileSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComposeFileSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSetIds = append(m.FileSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlSeconds", wireType)
			}
			m.TtlSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TtlSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compact", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compact = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardFileSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardFileSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardFileSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PathRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PathRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PathRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lower", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lower = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upper", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Upper = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardFileSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardFileSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardFileSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &PathRange{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckStorageRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckStorageRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckStorageRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadChunkData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ReadChunkData = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkBegin", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChunkBegin = append(m.ChunkBegin[:0], dAtA[iNdEx:postIndex]...)
			if m.ChunkBegin == nil {
				m.ChunkBegin = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkEnd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChunkEnd = append(m.ChunkEnd[:0], dAtA[iNdEx:postIndex]...)
			if m.ChunkEnd == nil {
				m.ChunkEnd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckStorageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckStorageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckStorageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkObjectCount", wireType)
			}
			m.ChunkObjectCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkObjectCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSetIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileSetIds = append(m.FileSetIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetCacheResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetCacheResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetCacheResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Value == nil {
				m.Value = &types.Any{}
			}
			if err := m.Value.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClearCacheRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClearCacheRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClearCacheRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TagPrefix = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivateAuthResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivateAuthResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivateAuthResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunLoadTestRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunLoadTestRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunLoadTestRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RunLoadTestResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RunLoadTestResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RunLoadTestResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Spec = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Branch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Branch == nil {
				m.Branch = &Branch{}
			}
			if err := m.Branch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Duration == nil {
				m.Duration = &types.Duration{}
			}
			if err := m.Duration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectStorageEgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectStorageEgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectStorageEgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLDatabaseEgress) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SQLDatabaseEgress: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SQLDatabaseEgress: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileFormat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileFormat == nil {
				m.FileFormat = &SQLDatabaseEgress_FileFormat{}
			}
			if err := m.FileFormat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Secret == nil {
				m.Secret = &SQLDatabaseEgress_Secret{}
			}
			if err := m.Secret.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLDatabaseEgress_FileFormat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileFormat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileFormat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= SQLDatabaseEgress_FileFormat_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SQLDatabaseEgress_Secret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Secret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Secret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Commit == nil {
				m.Commit = &Commit{}
			}
			if err := m.Commit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ObjectStorageEgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &EgressRequest_ObjectStorage{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SQLDatabaseEgress{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Target = &EgressRequest_SqlDatabase{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectStorage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EgressResponse_ObjectStorageResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &EgressResponse_ObjectStorage{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDatabase", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &EgressResponse_SQLDatabaseResult{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Result = &EgressResponse_SqlDatabase{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressResponse_ObjectStorageResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectStorageResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectStorageResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EgressResponse_SQLDatabaseResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SQLDatabaseResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SQLDatabaseResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RowsWritten", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPfs
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPfs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RowsWritten == nil {
				m.RowsWritten = make(map[string]int64)
			}
			var mapkey string
			var mapvalue int64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPfs
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPfs
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPfs
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPfs
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPfs(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPfs
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RowsWritten[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPfs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPfs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPfs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPfs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPfs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPfs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPfs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPfs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPfs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPfs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPfs = fmt.Errorf("proto: unexpected end of group")
)
