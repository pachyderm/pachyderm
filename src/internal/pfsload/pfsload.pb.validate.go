// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: internal/pfsload/pfsload.proto

package pfsload

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on CommitSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CommitSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CommitSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CommitSpecMultiError, or
// nil if none found.
func (m *CommitSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *CommitSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	for idx, item := range m.GetModifications() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitSpecValidationError{
						field:  fmt.Sprintf("Modifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitSpecValidationError{
						field:  fmt.Sprintf("Modifications[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitSpecValidationError{
					field:  fmt.Sprintf("Modifications[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetFileSources() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommitSpecValidationError{
						field:  fmt.Sprintf("FileSources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommitSpecValidationError{
						field:  fmt.Sprintf("FileSources[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommitSpecValidationError{
					field:  fmt.Sprintf("FileSources[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetValidator()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommitSpecValidationError{
					field:  "Validator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommitSpecValidationError{
					field:  "Validator",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValidator()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommitSpecValidationError{
				field:  "Validator",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CommitSpecMultiError(errors)
	}

	return nil
}

// CommitSpecMultiError is an error wrapping multiple validation errors
// returned by CommitSpec.ValidateAll() if the designated constraints aren't met.
type CommitSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommitSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommitSpecMultiError) AllErrors() []error { return m }

// CommitSpecValidationError is the validation error returned by
// CommitSpec.Validate if the designated constraints aren't met.
type CommitSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommitSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommitSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommitSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommitSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommitSpecValidationError) ErrorName() string { return "CommitSpecValidationError" }

// Error satisfies the builtin error interface
func (e CommitSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommitSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommitSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommitSpecValidationError{}

// Validate checks the field values on ModificationSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ModificationSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ModificationSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ModificationSpecMultiError, or nil if none found.
func (m *ModificationSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ModificationSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if all {
		switch v := interface{}(m.GetPutFile()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ModificationSpecValidationError{
					field:  "PutFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ModificationSpecValidationError{
					field:  "PutFile",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPutFile()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ModificationSpecValidationError{
				field:  "PutFile",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ModificationSpecMultiError(errors)
	}

	return nil
}

// ModificationSpecMultiError is an error wrapping multiple validation errors
// returned by ModificationSpec.ValidateAll() if the designated constraints
// aren't met.
type ModificationSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ModificationSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ModificationSpecMultiError) AllErrors() []error { return m }

// ModificationSpecValidationError is the validation error returned by
// ModificationSpec.Validate if the designated constraints aren't met.
type ModificationSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ModificationSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ModificationSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ModificationSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ModificationSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ModificationSpecValidationError) ErrorName() string { return "ModificationSpecValidationError" }

// Error satisfies the builtin error interface
func (e ModificationSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sModificationSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ModificationSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ModificationSpecValidationError{}

// Validate checks the field values on PutFileSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutFileSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutFileSpecMultiError, or
// nil if none found.
func (m *PutFileSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	// no validation rules for Source

	if len(errors) > 0 {
		return PutFileSpecMultiError(errors)
	}

	return nil
}

// PutFileSpecMultiError is an error wrapping multiple validation errors
// returned by PutFileSpec.ValidateAll() if the designated constraints aren't met.
type PutFileSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileSpecMultiError) AllErrors() []error { return m }

// PutFileSpecValidationError is the validation error returned by
// PutFileSpec.Validate if the designated constraints aren't met.
type PutFileSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileSpecValidationError) ErrorName() string { return "PutFileSpecValidationError" }

// Error satisfies the builtin error interface
func (e PutFileSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileSpecValidationError{}

// Validate checks the field values on PutFileTask with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PutFileTask) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileTask with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PutFileTaskMultiError, or
// nil if none found.
func (m *PutFileTask) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileTask) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	if all {
		switch v := interface{}(m.GetFileSource()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PutFileTaskValidationError{
					field:  "FileSource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PutFileTaskValidationError{
					field:  "FileSource",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFileSource()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PutFileTaskValidationError{
				field:  "FileSource",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Seed

	// no validation rules for AuthToken

	if len(errors) > 0 {
		return PutFileTaskMultiError(errors)
	}

	return nil
}

// PutFileTaskMultiError is an error wrapping multiple validation errors
// returned by PutFileTask.ValidateAll() if the designated constraints aren't met.
type PutFileTaskMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileTaskMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileTaskMultiError) AllErrors() []error { return m }

// PutFileTaskValidationError is the validation error returned by
// PutFileTask.Validate if the designated constraints aren't met.
type PutFileTaskValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileTaskValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileTaskValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileTaskValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileTaskValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileTaskValidationError) ErrorName() string { return "PutFileTaskValidationError" }

// Error satisfies the builtin error interface
func (e PutFileTaskValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileTask.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileTaskValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileTaskValidationError{}

// Validate checks the field values on PutFileTaskResult with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PutFileTaskResult) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PutFileTaskResult with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PutFileTaskResultMultiError, or nil if none found.
func (m *PutFileTaskResult) ValidateAll() error {
	return m.validate(true)
}

func (m *PutFileTaskResult) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for FileSetId

	// no validation rules for Hash

	if len(errors) > 0 {
		return PutFileTaskResultMultiError(errors)
	}

	return nil
}

// PutFileTaskResultMultiError is an error wrapping multiple validation errors
// returned by PutFileTaskResult.ValidateAll() if the designated constraints
// aren't met.
type PutFileTaskResultMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PutFileTaskResultMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PutFileTaskResultMultiError) AllErrors() []error { return m }

// PutFileTaskResultValidationError is the validation error returned by
// PutFileTaskResult.Validate if the designated constraints aren't met.
type PutFileTaskResultValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PutFileTaskResultValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PutFileTaskResultValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PutFileTaskResultValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PutFileTaskResultValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PutFileTaskResultValidationError) ErrorName() string {
	return "PutFileTaskResultValidationError"
}

// Error satisfies the builtin error interface
func (e PutFileTaskResultValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPutFileTaskResult.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PutFileTaskResultValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PutFileTaskResultValidationError{}

// Validate checks the field values on FileSourceSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FileSourceSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FileSourceSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FileSourceSpecMultiError,
// or nil if none found.
func (m *FileSourceSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *FileSourceSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetRandom()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, FileSourceSpecValidationError{
					field:  "Random",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, FileSourceSpecValidationError{
					field:  "Random",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRandom()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return FileSourceSpecValidationError{
				field:  "Random",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return FileSourceSpecMultiError(errors)
	}

	return nil
}

// FileSourceSpecMultiError is an error wrapping multiple validation errors
// returned by FileSourceSpec.ValidateAll() if the designated constraints
// aren't met.
type FileSourceSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FileSourceSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FileSourceSpecMultiError) AllErrors() []error { return m }

// FileSourceSpecValidationError is the validation error returned by
// FileSourceSpec.Validate if the designated constraints aren't met.
type FileSourceSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FileSourceSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FileSourceSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FileSourceSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FileSourceSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FileSourceSpecValidationError) ErrorName() string { return "FileSourceSpecValidationError" }

// Error satisfies the builtin error interface
func (e FileSourceSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFileSourceSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FileSourceSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FileSourceSpecValidationError{}

// Validate checks the field values on RandomFileSourceSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RandomFileSourceSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RandomFileSourceSpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RandomFileSourceSpecMultiError, or nil if none found.
func (m *RandomFileSourceSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *RandomFileSourceSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDirectory()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RandomFileSourceSpecValidationError{
					field:  "Directory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RandomFileSourceSpecValidationError{
					field:  "Directory",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDirectory()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RandomFileSourceSpecValidationError{
				field:  "Directory",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetSizes() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RandomFileSourceSpecValidationError{
						field:  fmt.Sprintf("Sizes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RandomFileSourceSpecValidationError{
						field:  fmt.Sprintf("Sizes[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RandomFileSourceSpecValidationError{
					field:  fmt.Sprintf("Sizes[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for IncrementPath

	if len(errors) > 0 {
		return RandomFileSourceSpecMultiError(errors)
	}

	return nil
}

// RandomFileSourceSpecMultiError is an error wrapping multiple validation
// errors returned by RandomFileSourceSpec.ValidateAll() if the designated
// constraints aren't met.
type RandomFileSourceSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RandomFileSourceSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RandomFileSourceSpecMultiError) AllErrors() []error { return m }

// RandomFileSourceSpecValidationError is the validation error returned by
// RandomFileSourceSpec.Validate if the designated constraints aren't met.
type RandomFileSourceSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RandomFileSourceSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RandomFileSourceSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RandomFileSourceSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RandomFileSourceSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RandomFileSourceSpecValidationError) ErrorName() string {
	return "RandomFileSourceSpecValidationError"
}

// Error satisfies the builtin error interface
func (e RandomFileSourceSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRandomFileSourceSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RandomFileSourceSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RandomFileSourceSpecValidationError{}

// Validate checks the field values on RandomDirectorySpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RandomDirectorySpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RandomDirectorySpec with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RandomDirectorySpecMultiError, or nil if none found.
func (m *RandomDirectorySpec) ValidateAll() error {
	return m.validate(true)
}

func (m *RandomDirectorySpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetDepth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RandomDirectorySpecValidationError{
					field:  "Depth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RandomDirectorySpecValidationError{
					field:  "Depth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDepth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RandomDirectorySpecValidationError{
				field:  "Depth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Run

	if len(errors) > 0 {
		return RandomDirectorySpecMultiError(errors)
	}

	return nil
}

// RandomDirectorySpecMultiError is an error wrapping multiple validation
// errors returned by RandomDirectorySpec.ValidateAll() if the designated
// constraints aren't met.
type RandomDirectorySpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RandomDirectorySpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RandomDirectorySpecMultiError) AllErrors() []error { return m }

// RandomDirectorySpecValidationError is the validation error returned by
// RandomDirectorySpec.Validate if the designated constraints aren't met.
type RandomDirectorySpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RandomDirectorySpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RandomDirectorySpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RandomDirectorySpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RandomDirectorySpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RandomDirectorySpecValidationError) ErrorName() string {
	return "RandomDirectorySpecValidationError"
}

// Error satisfies the builtin error interface
func (e RandomDirectorySpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRandomDirectorySpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RandomDirectorySpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RandomDirectorySpecValidationError{}

// Validate checks the field values on SizeSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SizeSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SizeSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SizeSpecMultiError, or nil
// if none found.
func (m *SizeSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *SizeSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinSize

	// no validation rules for MaxSize

	// no validation rules for Prob

	if len(errors) > 0 {
		return SizeSpecMultiError(errors)
	}

	return nil
}

// SizeSpecMultiError is an error wrapping multiple validation errors returned
// by SizeSpec.ValidateAll() if the designated constraints aren't met.
type SizeSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SizeSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SizeSpecMultiError) AllErrors() []error { return m }

// SizeSpecValidationError is the validation error returned by
// SizeSpec.Validate if the designated constraints aren't met.
type SizeSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SizeSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SizeSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SizeSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SizeSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SizeSpecValidationError) ErrorName() string { return "SizeSpecValidationError" }

// Error satisfies the builtin error interface
func (e SizeSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSizeSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SizeSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SizeSpecValidationError{}

// Validate checks the field values on ValidatorSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ValidatorSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ValidatorSpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ValidatorSpecMultiError, or
// nil if none found.
func (m *ValidatorSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ValidatorSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetFrequency()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ValidatorSpecValidationError{
					field:  "Frequency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ValidatorSpecValidationError{
					field:  "Frequency",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFrequency()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ValidatorSpecValidationError{
				field:  "Frequency",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ValidatorSpecMultiError(errors)
	}

	return nil
}

// ValidatorSpecMultiError is an error wrapping multiple validation errors
// returned by ValidatorSpec.ValidateAll() if the designated constraints
// aren't met.
type ValidatorSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidatorSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidatorSpecMultiError) AllErrors() []error { return m }

// ValidatorSpecValidationError is the validation error returned by
// ValidatorSpec.Validate if the designated constraints aren't met.
type ValidatorSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidatorSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidatorSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidatorSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidatorSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidatorSpecValidationError) ErrorName() string { return "ValidatorSpecValidationError" }

// Error satisfies the builtin error interface
func (e ValidatorSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidatorSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidatorSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidatorSpecValidationError{}

// Validate checks the field values on FrequencySpec with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FrequencySpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FrequencySpec with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FrequencySpecMultiError, or
// nil if none found.
func (m *FrequencySpec) ValidateAll() error {
	return m.validate(true)
}

func (m *FrequencySpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Count

	// no validation rules for Prob

	if len(errors) > 0 {
		return FrequencySpecMultiError(errors)
	}

	return nil
}

// FrequencySpecMultiError is an error wrapping multiple validation errors
// returned by FrequencySpec.ValidateAll() if the designated constraints
// aren't met.
type FrequencySpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FrequencySpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FrequencySpecMultiError) AllErrors() []error { return m }

// FrequencySpecValidationError is the validation error returned by
// FrequencySpec.Validate if the designated constraints aren't met.
type FrequencySpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FrequencySpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FrequencySpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FrequencySpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FrequencySpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FrequencySpecValidationError) ErrorName() string { return "FrequencySpecValidationError" }

// Error satisfies the builtin error interface
func (e FrequencySpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFrequencySpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FrequencySpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FrequencySpecValidationError{}

// Validate checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *State) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on State with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StateMultiError, or nil if none found.
func (m *State) ValidateAll() error {
	return m.validate(true)
}

func (m *State) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCommits() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, StateValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, StateValidationError{
						field:  fmt.Sprintf("Commits[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return StateValidationError{
					field:  fmt.Sprintf("Commits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return StateMultiError(errors)
	}

	return nil
}

// StateMultiError is an error wrapping multiple validation errors returned by
// State.ValidateAll() if the designated constraints aren't met.
type StateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateMultiError) AllErrors() []error { return m }

// StateValidationError is the validation error returned by State.Validate if
// the designated constraints aren't met.
type StateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateValidationError) ErrorName() string { return "StateValidationError" }

// Error satisfies the builtin error interface
func (e StateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sState.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateValidationError{}

// Validate checks the field values on State_Commit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *State_Commit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on State_Commit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in State_CommitMultiError, or
// nil if none found.
func (m *State_Commit) ValidateAll() error {
	return m.validate(true)
}

func (m *State_Commit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCommit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, State_CommitValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, State_CommitValidationError{
					field:  "Commit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCommit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return State_CommitValidationError{
				field:  "Commit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Hash

	if len(errors) > 0 {
		return State_CommitMultiError(errors)
	}

	return nil
}

// State_CommitMultiError is an error wrapping multiple validation errors
// returned by State_Commit.ValidateAll() if the designated constraints aren't met.
type State_CommitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m State_CommitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m State_CommitMultiError) AllErrors() []error { return m }

// State_CommitValidationError is the validation error returned by
// State_Commit.Validate if the designated constraints aren't met.
type State_CommitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e State_CommitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e State_CommitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e State_CommitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e State_CommitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e State_CommitValidationError) ErrorName() string { return "State_CommitValidationError" }

// Error satisfies the builtin error interface
func (e State_CommitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sState_Commit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = State_CommitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = State_CommitValidationError{}
