// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: internal/metrics/metrics.proto

package metrics

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Metrics struct {
	ClusterID            string   `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	PodID                string   `protobuf:"bytes,2,opt,name=pod_id,json=podId,proto3" json:"pod_id,omitempty"`
	Nodes                int64    `protobuf:"varint,3,opt,name=nodes,proto3" json:"nodes,omitempty"`
	Version              string   `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Repos                int64    `protobuf:"varint,5,opt,name=repos,proto3" json:"repos,omitempty"`
	Commits              int64    `protobuf:"varint,6,opt,name=commits,proto3" json:"commits,omitempty"`
	Files                int64    `protobuf:"varint,7,opt,name=files,proto3" json:"files,omitempty"`
	Bytes                uint64   `protobuf:"varint,8,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Jobs                 int64    `protobuf:"varint,9,opt,name=jobs,proto3" json:"jobs,omitempty"`
	Pipelines            int64    `protobuf:"varint,10,opt,name=pipelines,proto3" json:"pipelines,omitempty"`
	ArchivedCommits      int64    `protobuf:"varint,11,opt,name=archived_commits,json=archivedCommits,proto3" json:"archived_commits,omitempty"`
	CancelledCommits     int64    `protobuf:"varint,12,opt,name=cancelled_commits,json=cancelledCommits,proto3" json:"cancelled_commits,omitempty"`
	ActivationCode       string   `protobuf:"bytes,13,opt,name=activation_code,json=activationCode,proto3" json:"activation_code,omitempty"`
	MaxBranches          uint64   `protobuf:"varint,14,opt,name=max_branches,json=maxBranches,proto3" json:"max_branches,omitempty"`
	PpsSpout             int64    `protobuf:"varint,15,opt,name=pps_spout,json=ppsSpout,proto3" json:"pps_spout,omitempty"`
	PpsSpoutService      int64    `protobuf:"varint,16,opt,name=pps_spout_service,json=ppsSpoutService,proto3" json:"pps_spout_service,omitempty"`
	CfgEgress            int64    `protobuf:"varint,17,opt,name=cfg_egress,json=cfgEgress,proto3" json:"cfg_egress,omitempty"`
	CfgStandby           int64    `protobuf:"varint,18,opt,name=cfg_standby,json=cfgStandby,proto3" json:"cfg_standby,omitempty"`
	CfgS3Gateway         int64    `protobuf:"varint,19,opt,name=cfg_s3gateway,json=cfgS3gateway,proto3" json:"cfg_s3gateway,omitempty"`
	CfgServices          int64    `protobuf:"varint,20,opt,name=cfg_services,json=cfgServices,proto3" json:"cfg_services,omitempty"`
	CfgErrcmd            int64    `protobuf:"varint,21,opt,name=cfg_errcmd,json=cfgErrcmd,proto3" json:"cfg_errcmd,omitempty"`
	CfgStats             int64    `protobuf:"varint,22,opt,name=cfg_stats,json=cfgStats,proto3" json:"cfg_stats,omitempty"`
	CfgTfjob             int64    `protobuf:"varint,23,opt,name=cfg_tfjob,json=cfgTfjob,proto3" json:"cfg_tfjob,omitempty"`
	InputGroup           int64    `protobuf:"varint,24,opt,name=input_group,json=inputGroup,proto3" json:"input_group,omitempty"`
	InputJoin            int64    `protobuf:"varint,25,opt,name=input_join,json=inputJoin,proto3" json:"input_join,omitempty"`
	InputCross           int64    `protobuf:"varint,26,opt,name=input_cross,json=inputCross,proto3" json:"input_cross,omitempty"`
	InputUnion           int64    `protobuf:"varint,27,opt,name=input_union,json=inputUnion,proto3" json:"input_union,omitempty"`
	InputCron            int64    `protobuf:"varint,28,opt,name=input_cron,json=inputCron,proto3" json:"input_cron,omitempty"`
	InputGit             int64    `protobuf:"varint,29,opt,name=input_git,json=inputGit,proto3" json:"input_git,omitempty"`
	InputPfs             int64    `protobuf:"varint,30,opt,name=input_pfs,json=inputPfs,proto3" json:"input_pfs,omitempty"`
	InputCommit          int64    `protobuf:"varint,31,opt,name=input_commit,json=inputCommit,proto3" json:"input_commit,omitempty"`
	InputJoinOn          int64    `protobuf:"varint,32,opt,name=input_join_on,json=inputJoinOn,proto3" json:"input_join_on,omitempty"`
	InputOuterJoin       int64    `protobuf:"varint,33,opt,name=input_outer_join,json=inputOuterJoin,proto3" json:"input_outer_join,omitempty"`
	InputLazy            int64    `protobuf:"varint,34,opt,name=input_lazy,json=inputLazy,proto3" json:"input_lazy,omitempty"`
	InputEmptyFiles      int64    `protobuf:"varint,35,opt,name=input_empty_files,json=inputEmptyFiles,proto3" json:"input_empty_files,omitempty"`
	InputS3              int64    `protobuf:"varint,36,opt,name=input_s3,json=inputS3,proto3" json:"input_s3,omitempty"`
	InputTrigger         int64    `protobuf:"varint,37,opt,name=input_trigger,json=inputTrigger,proto3" json:"input_trigger,omitempty"`
	ResourceCpuReq       float32  `protobuf:"fixed32,38,opt,name=resource_cpu_req,json=resourceCpuReq,proto3" json:"resource_cpu_req,omitempty"`
	ResourceCpuReqMax    float32  `protobuf:"fixed32,39,opt,name=resource_cpu_req_max,json=resourceCpuReqMax,proto3" json:"resource_cpu_req_max,omitempty"`
	ResourceMemReq       string   `protobuf:"bytes,40,opt,name=resource_mem_req,json=resourceMemReq,proto3" json:"resource_mem_req,omitempty"`
	ResourceGpuReq       int64    `protobuf:"varint,41,opt,name=resource_gpu_req,json=resourceGpuReq,proto3" json:"resource_gpu_req,omitempty"`
	ResourceGpuReqMax    int64    `protobuf:"varint,42,opt,name=resource_gpu_req_max,json=resourceGpuReqMax,proto3" json:"resource_gpu_req_max,omitempty"`
	ResourceDiskReq      string   `protobuf:"bytes,43,opt,name=resource_disk_req,json=resourceDiskReq,proto3" json:"resource_disk_req,omitempty"`
	ResourceCpuLimit     float32  `protobuf:"fixed32,44,opt,name=resource_cpu_limit,json=resourceCpuLimit,proto3" json:"resource_cpu_limit,omitempty"`
	ResourceCpuLimitMax  float32  `protobuf:"fixed32,45,opt,name=resource_cpu_limit_max,json=resourceCpuLimitMax,proto3" json:"resource_cpu_limit_max,omitempty"`
	ResourceMemLimit     string   `protobuf:"bytes,46,opt,name=resource_mem_limit,json=resourceMemLimit,proto3" json:"resource_mem_limit,omitempty"`
	ResourceGpuLimit     int64    `protobuf:"varint,47,opt,name=resource_gpu_limit,json=resourceGpuLimit,proto3" json:"resource_gpu_limit,omitempty"`
	ResourceGpuLimitMax  int64    `protobuf:"varint,48,opt,name=resource_gpu_limit_max,json=resourceGpuLimitMax,proto3" json:"resource_gpu_limit_max,omitempty"`
	ResourceDiskLimit    string   `protobuf:"bytes,49,opt,name=resource_disk_limit,json=resourceDiskLimit,proto3" json:"resource_disk_limit,omitempty"`
	MaxParallelism       uint64   `protobuf:"varint,50,opt,name=max_parallelism,json=maxParallelism,proto3" json:"max_parallelism,omitempty"`
	MinParallelism       uint64   `protobuf:"varint,51,opt,name=min_parallelism,json=minParallelism,proto3" json:"min_parallelism,omitempty"`
	NumParallelism       uint64   `protobuf:"varint,52,opt,name=num_parallelism,json=numParallelism,proto3" json:"num_parallelism,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Metrics) Reset()         { *m = Metrics{} }
func (m *Metrics) String() string { return proto.CompactTextString(m) }
func (*Metrics) ProtoMessage()    {}
func (*Metrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_80696bde8ca4d1c7, []int{0}
}
func (m *Metrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metrics.Merge(m, src)
}
func (m *Metrics) XXX_Size() int {
	return m.Size()
}
func (m *Metrics) XXX_DiscardUnknown() {
	xxx_messageInfo_Metrics.DiscardUnknown(m)
}

var xxx_messageInfo_Metrics proto.InternalMessageInfo

func (m *Metrics) GetClusterID() string {
	if m != nil {
		return m.ClusterID
	}
	return ""
}

func (m *Metrics) GetPodID() string {
	if m != nil {
		return m.PodID
	}
	return ""
}

func (m *Metrics) GetNodes() int64 {
	if m != nil {
		return m.Nodes
	}
	return 0
}

func (m *Metrics) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Metrics) GetRepos() int64 {
	if m != nil {
		return m.Repos
	}
	return 0
}

func (m *Metrics) GetCommits() int64 {
	if m != nil {
		return m.Commits
	}
	return 0
}

func (m *Metrics) GetFiles() int64 {
	if m != nil {
		return m.Files
	}
	return 0
}

func (m *Metrics) GetBytes() uint64 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *Metrics) GetJobs() int64 {
	if m != nil {
		return m.Jobs
	}
	return 0
}

func (m *Metrics) GetPipelines() int64 {
	if m != nil {
		return m.Pipelines
	}
	return 0
}

func (m *Metrics) GetArchivedCommits() int64 {
	if m != nil {
		return m.ArchivedCommits
	}
	return 0
}

func (m *Metrics) GetCancelledCommits() int64 {
	if m != nil {
		return m.CancelledCommits
	}
	return 0
}

func (m *Metrics) GetActivationCode() string {
	if m != nil {
		return m.ActivationCode
	}
	return ""
}

func (m *Metrics) GetMaxBranches() uint64 {
	if m != nil {
		return m.MaxBranches
	}
	return 0
}

func (m *Metrics) GetPpsSpout() int64 {
	if m != nil {
		return m.PpsSpout
	}
	return 0
}

func (m *Metrics) GetPpsSpoutService() int64 {
	if m != nil {
		return m.PpsSpoutService
	}
	return 0
}

func (m *Metrics) GetCfgEgress() int64 {
	if m != nil {
		return m.CfgEgress
	}
	return 0
}

func (m *Metrics) GetCfgStandby() int64 {
	if m != nil {
		return m.CfgStandby
	}
	return 0
}

func (m *Metrics) GetCfgS3Gateway() int64 {
	if m != nil {
		return m.CfgS3Gateway
	}
	return 0
}

func (m *Metrics) GetCfgServices() int64 {
	if m != nil {
		return m.CfgServices
	}
	return 0
}

func (m *Metrics) GetCfgErrcmd() int64 {
	if m != nil {
		return m.CfgErrcmd
	}
	return 0
}

func (m *Metrics) GetCfgStats() int64 {
	if m != nil {
		return m.CfgStats
	}
	return 0
}

func (m *Metrics) GetCfgTfjob() int64 {
	if m != nil {
		return m.CfgTfjob
	}
	return 0
}

func (m *Metrics) GetInputGroup() int64 {
	if m != nil {
		return m.InputGroup
	}
	return 0
}

func (m *Metrics) GetInputJoin() int64 {
	if m != nil {
		return m.InputJoin
	}
	return 0
}

func (m *Metrics) GetInputCross() int64 {
	if m != nil {
		return m.InputCross
	}
	return 0
}

func (m *Metrics) GetInputUnion() int64 {
	if m != nil {
		return m.InputUnion
	}
	return 0
}

func (m *Metrics) GetInputCron() int64 {
	if m != nil {
		return m.InputCron
	}
	return 0
}

func (m *Metrics) GetInputGit() int64 {
	if m != nil {
		return m.InputGit
	}
	return 0
}

func (m *Metrics) GetInputPfs() int64 {
	if m != nil {
		return m.InputPfs
	}
	return 0
}

func (m *Metrics) GetInputCommit() int64 {
	if m != nil {
		return m.InputCommit
	}
	return 0
}

func (m *Metrics) GetInputJoinOn() int64 {
	if m != nil {
		return m.InputJoinOn
	}
	return 0
}

func (m *Metrics) GetInputOuterJoin() int64 {
	if m != nil {
		return m.InputOuterJoin
	}
	return 0
}

func (m *Metrics) GetInputLazy() int64 {
	if m != nil {
		return m.InputLazy
	}
	return 0
}

func (m *Metrics) GetInputEmptyFiles() int64 {
	if m != nil {
		return m.InputEmptyFiles
	}
	return 0
}

func (m *Metrics) GetInputS3() int64 {
	if m != nil {
		return m.InputS3
	}
	return 0
}

func (m *Metrics) GetInputTrigger() int64 {
	if m != nil {
		return m.InputTrigger
	}
	return 0
}

func (m *Metrics) GetResourceCpuReq() float32 {
	if m != nil {
		return m.ResourceCpuReq
	}
	return 0
}

func (m *Metrics) GetResourceCpuReqMax() float32 {
	if m != nil {
		return m.ResourceCpuReqMax
	}
	return 0
}

func (m *Metrics) GetResourceMemReq() string {
	if m != nil {
		return m.ResourceMemReq
	}
	return ""
}

func (m *Metrics) GetResourceGpuReq() int64 {
	if m != nil {
		return m.ResourceGpuReq
	}
	return 0
}

func (m *Metrics) GetResourceGpuReqMax() int64 {
	if m != nil {
		return m.ResourceGpuReqMax
	}
	return 0
}

func (m *Metrics) GetResourceDiskReq() string {
	if m != nil {
		return m.ResourceDiskReq
	}
	return ""
}

func (m *Metrics) GetResourceCpuLimit() float32 {
	if m != nil {
		return m.ResourceCpuLimit
	}
	return 0
}

func (m *Metrics) GetResourceCpuLimitMax() float32 {
	if m != nil {
		return m.ResourceCpuLimitMax
	}
	return 0
}

func (m *Metrics) GetResourceMemLimit() string {
	if m != nil {
		return m.ResourceMemLimit
	}
	return ""
}

func (m *Metrics) GetResourceGpuLimit() int64 {
	if m != nil {
		return m.ResourceGpuLimit
	}
	return 0
}

func (m *Metrics) GetResourceGpuLimitMax() int64 {
	if m != nil {
		return m.ResourceGpuLimitMax
	}
	return 0
}

func (m *Metrics) GetResourceDiskLimit() string {
	if m != nil {
		return m.ResourceDiskLimit
	}
	return ""
}

func (m *Metrics) GetMaxParallelism() uint64 {
	if m != nil {
		return m.MaxParallelism
	}
	return 0
}

func (m *Metrics) GetMinParallelism() uint64 {
	if m != nil {
		return m.MinParallelism
	}
	return 0
}

func (m *Metrics) GetNumParallelism() uint64 {
	if m != nil {
		return m.NumParallelism
	}
	return 0
}

func init() {
	proto.RegisterType((*Metrics)(nil), "metrics.Metrics")
}

func init() { proto.RegisterFile("internal/metrics/metrics.proto", fileDescriptor_80696bde8ca4d1c7) }

var fileDescriptor_80696bde8ca4d1c7 = []byte{
	// 955 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x64, 0x95, 0xcf, 0x72, 0xdb, 0x36,
	0x10, 0xc6, 0x47, 0x49, 0x6c, 0x47, 0xb0, 0x2d, 0x4b, 0xb0, 0x9b, 0x22, 0xff, 0x6c, 0xc5, 0x69,
	0x6b, 0xc5, 0x71, 0xad, 0x36, 0xea, 0xf4, 0x01, 0x2c, 0xa7, 0x19, 0x77, 0xe2, 0x89, 0x47, 0x4e,
	0x2f, 0xbd, 0x70, 0x28, 0x10, 0xa2, 0xe1, 0x90, 0x00, 0x03, 0x80, 0xaa, 0x94, 0x27, 0xec, 0xb1,
	0x4f, 0x90, 0xe9, 0xe8, 0xd2, 0xd7, 0xe8, 0xec, 0x82, 0x94, 0x28, 0xf9, 0x24, 0xee, 0xb7, 0x3f,
	0xec, 0x7e, 0xbb, 0x03, 0x52, 0x64, 0x5f, 0x2a, 0x27, 0x8c, 0x0a, 0x93, 0x6e, 0x2a, 0x9c, 0x91,
	0xdc, 0x96, 0xbf, 0xa7, 0x99, 0xd1, 0x4e, 0xd3, 0x8d, 0x22, 0x7c, 0xb2, 0x17, 0xeb, 0x58, 0xa3,
	0xd6, 0x85, 0x27, 0x9f, 0x3e, 0xfc, 0xaf, 0x41, 0x36, 0x2e, 0x3d, 0x41, 0x4f, 0x08, 0xe1, 0x49,
	0x6e, 0x9d, 0x30, 0x81, 0x8c, 0x58, 0xad, 0x5d, 0xeb, 0xd4, 0xcf, 0xb6, 0x67, 0x5f, 0x0f, 0xea,
	0x7d, 0xaf, 0x5e, 0x9c, 0x0f, 0xea, 0x05, 0x70, 0x11, 0xd1, 0x36, 0x59, 0xcf, 0x74, 0x04, 0xe4,
	0x3d, 0x24, 0xeb, 0xb3, 0xaf, 0x07, 0x6b, 0x57, 0x3a, 0xba, 0x38, 0x1f, 0xac, 0x65, 0x3a, 0xba,
	0x88, 0xe8, 0x1e, 0x59, 0x53, 0x3a, 0x12, 0x96, 0xdd, 0x6f, 0xd7, 0x3a, 0xf7, 0x07, 0x3e, 0xa0,
	0x8c, 0x6c, 0x8c, 0x85, 0xb1, 0x52, 0x2b, 0xf6, 0x00, 0x0e, 0x0e, 0xca, 0x10, 0x78, 0x23, 0x32,
	0x6d, 0xd9, 0x9a, 0xe7, 0x31, 0x00, 0x9e, 0xeb, 0x34, 0x95, 0xce, 0xb2, 0x75, 0xd4, 0xcb, 0x10,
	0xf8, 0x91, 0x4c, 0x84, 0x65, 0x1b, 0x9e, 0xc7, 0x00, 0xd4, 0xe1, 0xd4, 0x09, 0xcb, 0x1e, 0xb6,
	0x6b, 0x9d, 0x07, 0x03, 0x1f, 0x50, 0x4a, 0x1e, 0xdc, 0xea, 0xa1, 0x65, 0x75, 0x44, 0xf1, 0x99,
	0x3e, 0x23, 0xf5, 0x4c, 0x66, 0x22, 0x91, 0x4a, 0x58, 0x46, 0x30, 0xb1, 0x10, 0xe8, 0x2b, 0xd2,
	0x0c, 0x0d, 0xbf, 0x91, 0x63, 0x11, 0x05, 0xa5, 0x81, 0x4d, 0x84, 0x76, 0x4a, 0xbd, 0x5f, 0x18,
	0x79, 0x4d, 0x5a, 0x3c, 0x54, 0x5c, 0x24, 0x49, 0x85, 0xdd, 0x42, 0xb6, 0x39, 0x4f, 0x94, 0xf0,
	0x11, 0xd9, 0x09, 0xb9, 0x93, 0xe3, 0xd0, 0x49, 0xad, 0x02, 0xae, 0x23, 0xc1, 0xb6, 0x71, 0x0f,
	0x8d, 0x85, 0xdc, 0xd7, 0x91, 0xa0, 0x2f, 0xc8, 0x56, 0x1a, 0x4e, 0x82, 0xa1, 0x09, 0x15, 0xbf,
	0x11, 0x96, 0x35, 0x70, 0x9e, 0xcd, 0x34, 0x9c, 0x9c, 0x15, 0x12, 0x7d, 0x4a, 0xea, 0x59, 0x66,
	0x03, 0x9b, 0xe9, 0xdc, 0xb1, 0x1d, 0x6c, 0xf8, 0x30, 0xcb, 0xec, 0x35, 0xc4, 0xf4, 0x98, 0xb4,
	0xe6, 0xc9, 0xc0, 0x0a, 0x33, 0x96, 0x5c, 0xb0, 0xa6, 0x9f, 0xa0, 0x84, 0xae, 0xbd, 0x4c, 0x9f,
	0x13, 0xc2, 0x47, 0x71, 0x20, 0x62, 0x23, 0xac, 0x65, 0x2d, 0xbf, 0x0b, 0x3e, 0x8a, 0xdf, 0xa2,
	0x40, 0x0f, 0xc8, 0x26, 0xa4, 0xad, 0x0b, 0x55, 0x34, 0x9c, 0x32, 0x8a, 0x79, 0x38, 0x71, 0xed,
	0x15, 0xfa, 0x92, 0x6c, 0x23, 0xd0, 0x8b, 0x43, 0x27, 0xfe, 0x0a, 0xa7, 0x6c, 0x17, 0x91, 0x2d,
	0x40, 0x4a, 0x0d, 0x06, 0x42, 0xc8, 0xf7, 0xb4, 0x6c, 0x0f, 0x19, 0xa8, 0x5c, 0xd8, 0xb0, 0x73,
	0x1f, 0xc6, 0xf0, 0x34, 0x62, 0xdf, 0x2c, 0x7c, 0xa0, 0x00, 0xf3, 0x16, 0x3e, 0x9c, 0x65, 0x8f,
	0xfc, 0xbc, 0xde, 0x85, 0xb3, 0x65, 0xd2, 0x8d, 0x6e, 0xf5, 0x90, 0x7d, 0x3b, 0x4f, 0x7e, 0x84,
	0x18, 0x26, 0x90, 0x2a, 0xcb, 0x5d, 0x10, 0x1b, 0x9d, 0x67, 0x8c, 0xf9, 0x09, 0x50, 0x7a, 0x07,
	0x0a, 0x74, 0xf6, 0xc0, 0xad, 0x96, 0x8a, 0x3d, 0xf6, 0x9d, 0x51, 0xf9, 0x5d, 0x4b, 0xb5, 0x38,
	0xcf, 0x8d, 0xb6, 0x96, 0x3d, 0xa9, 0x9c, 0xef, 0x83, 0xb2, 0x00, 0x72, 0x05, 0x57, 0xfb, 0x69,
	0x05, 0xf8, 0x03, 0x94, 0x45, 0x03, 0x6e, 0xb4, 0x62, 0xcf, 0x2a, 0x0d, 0xfa, 0x46, 0x2b, 0x70,
	0x5f, 0x18, 0x94, 0x8e, 0x3d, 0xf7, 0xee, 0xbd, 0x3d, 0xe9, 0x16, 0xc9, 0x6c, 0x64, 0xd9, 0x7e,
	0x25, 0x79, 0x35, 0xb2, 0xb0, 0xd6, 0xa2, 0x30, 0xde, 0x30, 0x76, 0xe0, 0xd7, 0xea, 0x4b, 0xa3,
	0x44, 0x0f, 0xc9, 0xf6, 0x62, 0xb8, 0x40, 0x2b, 0xd6, 0xae, 0x30, 0x30, 0xdf, 0x07, 0x45, 0x3b,
	0xa4, 0xe9, 0x19, 0x9d, 0xc3, 0x17, 0x00, 0xd7, 0xf0, 0x02, 0xb1, 0x06, 0xea, 0x1f, 0x40, 0xc6,
	0x5d, 0xcc, 0x27, 0x49, 0xc2, 0x2f, 0x53, 0x76, 0x58, 0x99, 0xe4, 0x7d, 0xf8, 0x65, 0x0a, 0xf7,
	0xce, 0xa7, 0x45, 0x9a, 0xb9, 0x69, 0xe0, 0x5f, 0xd1, 0x97, 0xfe, 0xde, 0x61, 0xe2, 0x2d, 0xe8,
	0xbf, 0xe1, 0xcb, 0xfa, 0x98, 0xf8, 0x39, 0x02, 0xdb, 0x63, 0xdf, 0xf9, 0xb7, 0x1b, 0xe3, 0xeb,
	0x1e, 0x5c, 0x29, 0x9f, 0x72, 0x46, 0xc6, 0xb1, 0x30, 0xec, 0x7b, 0x7f, 0xa5, 0x50, 0xfc, 0xe8,
	0x35, 0x30, 0x6d, 0x84, 0xd5, 0xb9, 0xe1, 0x22, 0xe0, 0x59, 0x1e, 0x18, 0xf1, 0x99, 0xfd, 0xd0,
	0xae, 0x75, 0xee, 0x0d, 0x1a, 0xa5, 0xde, 0xcf, 0xf2, 0x81, 0xf8, 0x4c, 0xbb, 0x64, 0x6f, 0x95,
	0x0c, 0xd2, 0x70, 0xc2, 0x8e, 0x90, 0x6e, 0x2d, 0xd3, 0x97, 0xe1, 0x64, 0xa9, 0x74, 0x2a, 0x52,
	0x2c, 0xdd, 0xf1, 0x2f, 0x6a, 0xa9, 0x5f, 0x8a, 0x14, 0x4a, 0x57, 0xc9, 0xb8, 0x30, 0xf1, 0xca,
	0x6f, 0xae, 0xd4, 0xdf, 0xdd, 0x35, 0x11, 0x57, 0x4c, 0x1c, 0x23, 0xdd, 0x5a, 0xa6, 0xc1, 0xc4,
	0x31, 0x99, 0x8b, 0x41, 0x24, 0xed, 0x27, 0xac, 0xfd, 0x1a, 0x5d, 0xec, 0x94, 0x89, 0x73, 0x69,
	0x3f, 0x41, 0xf1, 0x13, 0x42, 0x97, 0x26, 0x4c, 0x24, 0xdc, 0x86, 0x13, 0x9c, 0xaf, 0x59, 0x99,
	0xef, 0x3d, 0xe8, 0xb4, 0x47, 0x1e, 0xdd, 0xa5, 0xd1, 0xcc, 0x8f, 0x78, 0x62, 0x77, 0xf5, 0x04,
	0xd8, 0xa9, 0xb6, 0x80, 0x9d, 0xf8, 0x16, 0xa7, 0xe8, 0xa7, 0x59, 0xd9, 0x8a, 0x6f, 0x51, 0xa5,
	0xe3, 0xb9, 0xa1, 0xae, 0xff, 0x2e, 0x56, 0x66, 0xbd, 0x6b, 0x28, 0x5e, 0x32, 0xf4, 0x13, 0x9e,
	0xd8, 0x5d, 0x3d, 0x01, 0x86, 0x4e, 0xc9, 0xee, 0xf2, 0x7e, 0x7c, 0x8f, 0x9f, 0xd1, 0x51, 0xab,
	0xba, 0x21, 0xdf, 0xe4, 0x88, 0xec, 0xc0, 0x37, 0x35, 0x0b, 0x4d, 0x98, 0x24, 0x22, 0x91, 0x36,
	0x65, 0x6f, 0xf0, 0xb3, 0xda, 0x48, 0xc3, 0xc9, 0xd5, 0x42, 0x45, 0x50, 0xaa, 0x25, 0xb0, 0x57,
	0x80, 0x52, 0xad, 0x80, 0x2a, 0x4f, 0x97, 0xc0, 0x5f, 0x3c, 0xa8, 0xf2, 0xb4, 0x02, 0x9e, 0x9d,
	0xff, 0x3d, 0xdb, 0xaf, 0xfd, 0x33, 0xdb, 0xaf, 0xfd, 0x3b, 0xdb, 0xaf, 0xfd, 0xf9, 0x6b, 0x2c,
	0xdd, 0x4d, 0x3e, 0x3c, 0xe5, 0x3a, 0xed, 0x66, 0x21, 0xbf, 0x99, 0x46, 0xc2, 0x54, 0x9f, 0xc6,
	0x6f, 0xba, 0xd6, 0xf0, 0xee, 0xea, 0x9f, 0xfb, 0x70, 0x1d, 0xff, 0xb6, 0x7b, 0xff, 0x07, 0x00,
	0x00, 0xff, 0xff, 0xe2, 0xb8, 0x78, 0x4d, 0xf7, 0x07, 0x00, 0x00,
}

func (m *Metrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NumParallelism != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.NumParallelism))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0xa0
	}
	if m.MinParallelism != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.MinParallelism))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x98
	}
	if m.MaxParallelism != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.MaxParallelism))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x90
	}
	if len(m.ResourceDiskLimit) > 0 {
		i -= len(m.ResourceDiskLimit)
		copy(dAtA[i:], m.ResourceDiskLimit)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ResourceDiskLimit)))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x8a
	}
	if m.ResourceGpuLimitMax != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ResourceGpuLimitMax))
		i--
		dAtA[i] = 0x3
		i--
		dAtA[i] = 0x80
	}
	if m.ResourceGpuLimit != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ResourceGpuLimit))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if len(m.ResourceMemLimit) > 0 {
		i -= len(m.ResourceMemLimit)
		copy(dAtA[i:], m.ResourceMemLimit)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ResourceMemLimit)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf2
	}
	if m.ResourceCpuLimitMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResourceCpuLimitMax))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xed
	}
	if m.ResourceCpuLimit != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResourceCpuLimit))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe5
	}
	if len(m.ResourceDiskReq) > 0 {
		i -= len(m.ResourceDiskReq)
		copy(dAtA[i:], m.ResourceDiskReq)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ResourceDiskReq)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xda
	}
	if m.ResourceGpuReqMax != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ResourceGpuReqMax))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.ResourceGpuReq != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ResourceGpuReq))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if len(m.ResourceMemReq) > 0 {
		i -= len(m.ResourceMemReq)
		copy(dAtA[i:], m.ResourceMemReq)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ResourceMemReq)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc2
	}
	if m.ResourceCpuReqMax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResourceCpuReqMax))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xbd
	}
	if m.ResourceCpuReq != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ResourceCpuReq))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb5
	}
	if m.InputTrigger != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputTrigger))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.InputS3 != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputS3))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.InputEmptyFiles != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputEmptyFiles))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.InputLazy != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputLazy))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if m.InputOuterJoin != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputOuterJoin))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.InputJoinOn != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputJoinOn))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.InputCommit != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputCommit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf8
	}
	if m.InputPfs != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputPfs))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.InputGit != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputGit))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe8
	}
	if m.InputCron != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputCron))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.InputUnion != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputUnion))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.InputCross != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputCross))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.InputJoin != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputJoin))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.InputGroup != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.InputGroup))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.CfgTfjob != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgTfjob))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.CfgStats != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgStats))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.CfgErrcmd != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgErrcmd))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.CfgServices != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgServices))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.CfgS3Gateway != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgS3Gateway))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.CfgStandby != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgStandby))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.CfgEgress != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CfgEgress))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.PpsSpoutService != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.PpsSpoutService))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PpsSpout != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.PpsSpout))
		i--
		dAtA[i] = 0x78
	}
	if m.MaxBranches != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.MaxBranches))
		i--
		dAtA[i] = 0x70
	}
	if len(m.ActivationCode) > 0 {
		i -= len(m.ActivationCode)
		copy(dAtA[i:], m.ActivationCode)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ActivationCode)))
		i--
		dAtA[i] = 0x6a
	}
	if m.CancelledCommits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.CancelledCommits))
		i--
		dAtA[i] = 0x60
	}
	if m.ArchivedCommits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.ArchivedCommits))
		i--
		dAtA[i] = 0x58
	}
	if m.Pipelines != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Pipelines))
		i--
		dAtA[i] = 0x50
	}
	if m.Jobs != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Jobs))
		i--
		dAtA[i] = 0x48
	}
	if m.Bytes != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x40
	}
	if m.Files != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Files))
		i--
		dAtA[i] = 0x38
	}
	if m.Commits != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Commits))
		i--
		dAtA[i] = 0x30
	}
	if m.Repos != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Repos))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if m.Nodes != 0 {
		i = encodeVarintMetrics(dAtA, i, uint64(m.Nodes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.PodID) > 0 {
		i -= len(m.PodID)
		copy(dAtA[i:], m.PodID)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.PodID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterID) > 0 {
		i -= len(m.ClusterID)
		copy(dAtA[i:], m.ClusterID)
		i = encodeVarintMetrics(dAtA, i, uint64(len(m.ClusterID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetrics(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetrics(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Metrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterID)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	l = len(m.PodID)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Nodes != 0 {
		n += 1 + sovMetrics(uint64(m.Nodes))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.Repos != 0 {
		n += 1 + sovMetrics(uint64(m.Repos))
	}
	if m.Commits != 0 {
		n += 1 + sovMetrics(uint64(m.Commits))
	}
	if m.Files != 0 {
		n += 1 + sovMetrics(uint64(m.Files))
	}
	if m.Bytes != 0 {
		n += 1 + sovMetrics(uint64(m.Bytes))
	}
	if m.Jobs != 0 {
		n += 1 + sovMetrics(uint64(m.Jobs))
	}
	if m.Pipelines != 0 {
		n += 1 + sovMetrics(uint64(m.Pipelines))
	}
	if m.ArchivedCommits != 0 {
		n += 1 + sovMetrics(uint64(m.ArchivedCommits))
	}
	if m.CancelledCommits != 0 {
		n += 1 + sovMetrics(uint64(m.CancelledCommits))
	}
	l = len(m.ActivationCode)
	if l > 0 {
		n += 1 + l + sovMetrics(uint64(l))
	}
	if m.MaxBranches != 0 {
		n += 1 + sovMetrics(uint64(m.MaxBranches))
	}
	if m.PpsSpout != 0 {
		n += 1 + sovMetrics(uint64(m.PpsSpout))
	}
	if m.PpsSpoutService != 0 {
		n += 2 + sovMetrics(uint64(m.PpsSpoutService))
	}
	if m.CfgEgress != 0 {
		n += 2 + sovMetrics(uint64(m.CfgEgress))
	}
	if m.CfgStandby != 0 {
		n += 2 + sovMetrics(uint64(m.CfgStandby))
	}
	if m.CfgS3Gateway != 0 {
		n += 2 + sovMetrics(uint64(m.CfgS3Gateway))
	}
	if m.CfgServices != 0 {
		n += 2 + sovMetrics(uint64(m.CfgServices))
	}
	if m.CfgErrcmd != 0 {
		n += 2 + sovMetrics(uint64(m.CfgErrcmd))
	}
	if m.CfgStats != 0 {
		n += 2 + sovMetrics(uint64(m.CfgStats))
	}
	if m.CfgTfjob != 0 {
		n += 2 + sovMetrics(uint64(m.CfgTfjob))
	}
	if m.InputGroup != 0 {
		n += 2 + sovMetrics(uint64(m.InputGroup))
	}
	if m.InputJoin != 0 {
		n += 2 + sovMetrics(uint64(m.InputJoin))
	}
	if m.InputCross != 0 {
		n += 2 + sovMetrics(uint64(m.InputCross))
	}
	if m.InputUnion != 0 {
		n += 2 + sovMetrics(uint64(m.InputUnion))
	}
	if m.InputCron != 0 {
		n += 2 + sovMetrics(uint64(m.InputCron))
	}
	if m.InputGit != 0 {
		n += 2 + sovMetrics(uint64(m.InputGit))
	}
	if m.InputPfs != 0 {
		n += 2 + sovMetrics(uint64(m.InputPfs))
	}
	if m.InputCommit != 0 {
		n += 2 + sovMetrics(uint64(m.InputCommit))
	}
	if m.InputJoinOn != 0 {
		n += 2 + sovMetrics(uint64(m.InputJoinOn))
	}
	if m.InputOuterJoin != 0 {
		n += 2 + sovMetrics(uint64(m.InputOuterJoin))
	}
	if m.InputLazy != 0 {
		n += 2 + sovMetrics(uint64(m.InputLazy))
	}
	if m.InputEmptyFiles != 0 {
		n += 2 + sovMetrics(uint64(m.InputEmptyFiles))
	}
	if m.InputS3 != 0 {
		n += 2 + sovMetrics(uint64(m.InputS3))
	}
	if m.InputTrigger != 0 {
		n += 2 + sovMetrics(uint64(m.InputTrigger))
	}
	if m.ResourceCpuReq != 0 {
		n += 6
	}
	if m.ResourceCpuReqMax != 0 {
		n += 6
	}
	l = len(m.ResourceMemReq)
	if l > 0 {
		n += 2 + l + sovMetrics(uint64(l))
	}
	if m.ResourceGpuReq != 0 {
		n += 2 + sovMetrics(uint64(m.ResourceGpuReq))
	}
	if m.ResourceGpuReqMax != 0 {
		n += 2 + sovMetrics(uint64(m.ResourceGpuReqMax))
	}
	l = len(m.ResourceDiskReq)
	if l > 0 {
		n += 2 + l + sovMetrics(uint64(l))
	}
	if m.ResourceCpuLimit != 0 {
		n += 6
	}
	if m.ResourceCpuLimitMax != 0 {
		n += 6
	}
	l = len(m.ResourceMemLimit)
	if l > 0 {
		n += 2 + l + sovMetrics(uint64(l))
	}
	if m.ResourceGpuLimit != 0 {
		n += 2 + sovMetrics(uint64(m.ResourceGpuLimit))
	}
	if m.ResourceGpuLimitMax != 0 {
		n += 2 + sovMetrics(uint64(m.ResourceGpuLimitMax))
	}
	l = len(m.ResourceDiskLimit)
	if l > 0 {
		n += 2 + l + sovMetrics(uint64(l))
	}
	if m.MaxParallelism != 0 {
		n += 2 + sovMetrics(uint64(m.MaxParallelism))
	}
	if m.MinParallelism != 0 {
		n += 2 + sovMetrics(uint64(m.MinParallelism))
	}
	if m.NumParallelism != 0 {
		n += 2 + sovMetrics(uint64(m.NumParallelism))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetrics(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetrics(x uint64) (n int) {
	return sovMetrics(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Metrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			m.Nodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nodes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Repos", wireType)
			}
			m.Repos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Repos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commits", wireType)
			}
			m.Commits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			m.Files = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Files |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			m.Jobs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Jobs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipelines", wireType)
			}
			m.Pipelines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pipelines |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ArchivedCommits", wireType)
			}
			m.ArchivedCommits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ArchivedCommits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelledCommits", wireType)
			}
			m.CancelledCommits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CancelledCommits |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActivationCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBranches", wireType)
			}
			m.MaxBranches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBranches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpsSpout", wireType)
			}
			m.PpsSpout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PpsSpout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PpsSpoutService", wireType)
			}
			m.PpsSpoutService = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PpsSpoutService |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgEgress", wireType)
			}
			m.CfgEgress = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgEgress |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgStandby", wireType)
			}
			m.CfgStandby = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgStandby |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgS3Gateway", wireType)
			}
			m.CfgS3Gateway = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgS3Gateway |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgServices", wireType)
			}
			m.CfgServices = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgServices |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgErrcmd", wireType)
			}
			m.CfgErrcmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgErrcmd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgStats", wireType)
			}
			m.CfgStats = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgStats |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CfgTfjob", wireType)
			}
			m.CfgTfjob = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CfgTfjob |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputGroup", wireType)
			}
			m.InputGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputGroup |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputJoin", wireType)
			}
			m.InputJoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputJoin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCross", wireType)
			}
			m.InputCross = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputCross |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputUnion", wireType)
			}
			m.InputUnion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputUnion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCron", wireType)
			}
			m.InputCron = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputCron |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputGit", wireType)
			}
			m.InputGit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputGit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputPfs", wireType)
			}
			m.InputPfs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputPfs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputCommit", wireType)
			}
			m.InputCommit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputCommit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputJoinOn", wireType)
			}
			m.InputJoinOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputJoinOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputOuterJoin", wireType)
			}
			m.InputOuterJoin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputOuterJoin |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputLazy", wireType)
			}
			m.InputLazy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputLazy |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputEmptyFiles", wireType)
			}
			m.InputEmptyFiles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputEmptyFiles |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputS3", wireType)
			}
			m.InputS3 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputS3 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputTrigger", wireType)
			}
			m.InputTrigger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InputTrigger |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCpuReq", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResourceCpuReq = float32(math.Float32frombits(v))
		case 39:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCpuReqMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResourceCpuReqMax = float32(math.Float32frombits(v))
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMemReq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceMemReq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGpuReq", wireType)
			}
			m.ResourceGpuReq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceGpuReq |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGpuReqMax", wireType)
			}
			m.ResourceGpuReqMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceGpuReqMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceDiskReq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceDiskReq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 44:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCpuLimit", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResourceCpuLimit = float32(math.Float32frombits(v))
		case 45:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCpuLimitMax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ResourceCpuLimitMax = float32(math.Float32frombits(v))
		case 46:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceMemLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceMemLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGpuLimit", wireType)
			}
			m.ResourceGpuLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceGpuLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceGpuLimitMax", wireType)
			}
			m.ResourceGpuLimitMax = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceGpuLimitMax |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceDiskLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetrics
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetrics
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceDiskLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxParallelism", wireType)
			}
			m.MaxParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxParallelism |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 51:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinParallelism", wireType)
			}
			m.MinParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinParallelism |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumParallelism", wireType)
			}
			m.NumParallelism = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumParallelism |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetrics(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetrics
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetrics(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetrics
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetrics
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetrics
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetrics
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetrics
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetrics        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetrics          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetrics = fmt.Errorf("proto: unexpected end of group")
)
